{
    "snippets": [
        {
            "title": "Simulation Application",
            "snippets": [
                {
                    "title": "Argument parser",
                    "description": "Parse command line strings into Python objects",
                    "snippet": "import argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--headless\", default=False, action=\"store_true\", help=\"Run stage headless\")\nparser.add_argument(\"--test\", default=False, action=\"store_true\", help=\"Run in test mode\")\n\nargs, unknown = parser.parse_known_args()  # get argument using `args`: e.g. args.headless\n"
                },
                {
                    "title": "SimulationApp template",
                    "description": "Helper class to launch Omniverse Toolkit",
                    "snippet": "from omni.isaac.kit import SimulationApp\n\n\nconfig = {\"headless\": False,\n          \"renderer\": \"RayTracedLighting\"}\n\n# Any Omniverse level imports must occur after the class is instantiated. \n# APIs are provided by the extension/runtime plugin system, \n# it must be loaded before they will be available to import.\nsimulation_app = SimulationApp(config)\n\nfor i in range(100):\n    simulation_app.update()\n\nsimulation_app.close()  # cleanup application\n"
                },
                {
                    "title": "SimulationApp",
                    "snippets": [
                        {
                        "title": "SimulationApp",
                        "description": "Helper class to launch Omniverse Toolkit.\n\nOmniverse loads various plugins at runtime which cannot be imported unless\nthe Toolkit is already running. Thus, it is necessary to launch the Toolkit first from\nyour python application and then import everything else.\n\nUsage:\n\n.. code-block:: python\n\n # At top of your application\n from omni.isaac.kit import SimulationApp\n config = {\n width: \"1280\",\n height: \"720\",\n headless: False,\n }\n simulation_app = SimulationApp(config)\n\n # Rest of the code follows\n ...\n simulation_app.close()\n\nNote:\n The settings in :obj:`DEFAULT_LAUNCHER_CONFIG` are overwritten by those in :obj:`config`.\n\nArguments:\n config (dict): A dictionary containing the configuration for the app. (default: None)\n experience (str): Path to the application config loaded by the launcher (default: \"\", will load app/omni.isaac.sim.python.kit if left blank)",
                        "snippet": "simulation_app = SimulationApp(launch_config=None,  # dict\n                               experience=\"\")  # str\n"
                        },
                        {
                        "title": "close",
                        "description": "Close the running Omniverse Toolkit.",
                        "snippet": "simulation_app.close()\n"
                        },
                        {
                        "title": "is_exiting",
                        "description": "  bool: True if close() was called previously, False otherwise\n  ",
                        "snippet": "simulation_app.is_exiting()\n"
                        },
                        {
                        "title": "is_running",
                        "description": "  bool: convenience function to see if app is running. True if running, False otherwise\n  ",
                        "snippet": "simulation_app.is_running()\n"
                        },
                        {
                        "title": "reset_render_settings",
                        "description": "Reset render settings to those in config.\n\n  Note:\n  This should be used in case a new stage is opened and the desired config needs\n  to be re-applied.\n  ",
                        "snippet": "simulation_app.reset_render_settings()\n"
                        },
                        {
                        "title": "set_setting",
                        "description": "  Set a carbonite setting\n\n  Args:\n  setting (str): carb setting path\n  value: value to set the setting to, type is used to properly set the setting.\n  ",
                        "snippet": "simulation_app.set_setting(setting=setting,  # str\n                           value=value)\n"
                        },
                        {
                        "title": "update",
                        "description": "  Convenience function to step the application forward one frame\n  ",
                        "snippet": "simulation_app.update()\n"
                        }
                    ]
                }
            ]
        },
        {
            "title": "Core",
            "snippets": [
                {
                "title": "Articulations",
                "snippets": [
                {
                "title": "Articulation",
                "snippets": [
                {
                "title": "Articulation",
                "description": " Provides high level functions to deal with an articulation prim and its attributes/ properties.\n \n Args:\n prim_path (str): prim path of the Prim to encapsulate or create.\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene. \n Defaults to \"articulation\".\n position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n Defaults to None, which means left unchanged.\n translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n (with respect to its parent prim). shape is (3, ).\n Defaults to None, which means left unchanged.\n orientation (Optional[Sequence[float]], optional): quaternion orientation in the world/ local frame of the prim\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (4, ).\n Defaults to None, which means left unchanged.\n scale (Optional[Sequence[float]], optional): local scale to be applied to the prim's dimensions. shape is (3, ).\n Defaults to None, which means left unchanged.\n visible (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n articulation_controller (Optional[ArticulationController], optional): a custom ArticulationController which\n inherits from it. Defaults to creating the\n basic ArticulationController.\n enable_dof_force_sensors (bool, optional): enables the solver computed dof force sensors on articulation joints.\n Defaults to False.\n Raises:\n Exception: [description]\n",
                "snippet": "articulation = Articulation(prim_path=prim_path,  # str\n                            name=\"articulation\",  # str\n                            position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            visible=None,  # typing.Union[bool, NoneType]\n                            articulation_controller=None,  # typing.Union[omni.isaac.core.controllers.articulation_controller.ArticulationController, NoneType]\n                            enable_dof_force_sensors=False)  # bool\n"
                },
                {
                "title": "apply_action",
                "description": "[summary]\n\n  Args:\n  control_actions (ArticulationAction): actions to be applied for next physics step.\n  indices (Optional[Union[list, np.ndarray]], optional): degree of freedom indices to apply actions to. \n   Defaults to all degrees of freedom.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation.apply_action(control_actions=control_actions)  # omni.isaac.core.utils.types.ArticulationAction\n"
                },
                {
                "title": "disable_gravity",
                "description": "Keep gravity from affecting the robot\n  ",
                "snippet": "articulation.disable_gravity()\n"
                },
                {
                "title": "enable_gravity",
                "description": "Gravity will affect the robot\n  ",
                "snippet": "articulation.enable_gravity()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "angular_velocity = articulation.get_angular_velocity()\n"
                },
                {
                "title": "get_applied_action",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  ArticulationAction: [description]\n  ",
                "snippet": "applied_action = articulation.get_applied_action()\n"
                },
                {
                "title": "get_applied_joint_efforts",
                "description": "Gets the efforts applied to the joints\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Raises:\n  Exception: _description_\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "applied_joint_efforts = articulation.get_applied_joint_efforts(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_articulation_body_count",
                "description": "[summary]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "articulation_body_count = articulation.get_articulation_body_count()\n"
                },
                {
                "title": "get_articulation_controller",
                "description": "  Returns:\n  ArticulationController: PD Controller of all degrees of freedom of an articulation, can apply position targets, velocity targets and efforts.\n  ",
                "snippet": "articulation_controller = articulation.get_articulation_controller()\n"
                },
                {
                "title": "get_dof_index",
                "description": "[summary]\n\n  Args:\n  dof_name (str): [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "dof_index = articulation.get_dof_index(dof_name=dof_name)  # str\n"
                },
                {
                "title": "get_enabled_self_collisions",
                "description": "[summary]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "enabled_self_collisions = articulation.get_enabled_self_collisions()\n"
                },
                {
                "title": "get_joint_efforts",
                "description": " Deprecated function. Please use get_applied_joint_efforts  instead.\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Raises:\n  Exception: _description_\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "joint_efforts = articulation.get_joint_efforts(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_joint_positions",
                "description": "_summary_\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "joint_positions = articulation.get_joint_positions(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_joint_velocities",
                "description": "_summary_\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "joint_velocities = articulation.get_joint_velocities(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_joints_default_state",
                "description": " Accessor for the default joints state.\n\n  Returns:\n  JointsState: The defaults that the robot is reset to when post_reset() is called (often\n  automatically called during world.reset()).\n  ",
                "snippet": "joints_default_state = articulation.get_joints_default_state()\n"
                },
                {
                "title": "get_joints_state",
                "description": "[summary]\n\n  Returns:\n  JointsState: [description]\n  ",
                "snippet": "joints_state = articulation.get_joints_state()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "linear_velocity = articulation.get_linear_velocity()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "sleep_threshold = articulation.get_sleep_threshold()\n"
                },
                {
                "title": "get_solver_position_iteration_count",
                "description": "[summary]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "solver_position_iteration_count = articulation.get_solver_position_iteration_count()\n"
                },
                {
                "title": "get_solver_velocity_iteration_count",
                "description": "[summary]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "solver_velocity_iteration_count = articulation.get_solver_velocity_iteration_count()\n"
                },
                {
                "title": "get_stabilization_threshold",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "stabilization_threshold = articulation.get_stabilization_threshold()\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates an articulation view using physX tensor api.\n  This needs to be called after each hard reset (i.e stop + play on the timeline) before interacting with any\n  of the functions of this class.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "articulation.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "[summary]\n\n  Args:\n  velocity (np.ndarray): [description]\n  ",
                "snippet": "articulation.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_enabled_self_collisions",
                "description": "[summary]\n\n  Args:\n  flag (bool): [description]\n  ",
                "snippet": "articulation.set_enabled_self_collisions(flag=flag)  # bool\n"
                },
                {
                "title": "set_joint_efforts",
                "description": "[summary]\n\n  Args:\n  efforts (np.ndarray): [description]\n  joint_indices (Optional[Union[list, np.ndarray]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation.set_joint_efforts(efforts=efforts,  # numpy.ndarray\n                               joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_joint_positions",
                "description": "[summary]\n\n  Args:\n  positions (np.ndarray): [description]\n  indices (Optional[Union[list, np.ndarray]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation.set_joint_positions(positions=positions,  # numpy.ndarray\n                                 joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_joint_velocities",
                "description": "[summary]\n\n  Args:\n  velocities (np.ndarray): [description]\n  indices (Optional[Union[list, np.ndarray]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation.set_joint_velocities(velocities=velocities,  # numpy.ndarray\n                                  joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_joints_default_state",
                "description": "[summary]\n\n  Args:\n  positions (Optional[np.ndarray], optional): [description]. Defaults to None.\n  velocities (Optional[np.ndarray], optional): [description]. Defaults to None.\n  efforts (Optional[np.ndarray], optional): [description]. Defaults to None.\n  ",
                "snippet": "articulation.set_joints_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                      velocities=None,  # typing.Union[numpy.ndarray, NoneType]\n                                      efforts=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n\n  Args:\n  velocity (np.ndarray):linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "articulation.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "[summary]\n\n  Args:\n  threshold (float): [description]\n  ",
                "snippet": "articulation.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "set_solver_position_iteration_count",
                "description": "[summary]\n\n  Args:\n  count (int): [description]\n  ",
                "snippet": "articulation.set_solver_position_iteration_count(count=count)  # int\n"
                },
                {
                "title": "set_solver_velocity_iteration_count",
                "description": "[summary]\n\n  Args:\n  count (int): [description]\n  ",
                "snippet": "articulation.set_solver_velocity_iteration_count(count=count)  # int\n"
                },
                {
                "title": "set_stabilization_threshold",
                "description": "[summary]\n\n  Args:\n  threshold (float): [description]\n  ",
                "snippet": "articulation.set_stabilization_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "articulation.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                   weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = articulation.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = articulation.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = articulation.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = articulation.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = articulation.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = articulation.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = articulation.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "articulation.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "articulation.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "articulation.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "articulation.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "articulation.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "articulation.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "articulation.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "articulation.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "articulation.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "ArticulationGripper",
                "snippets": [
                {
                "title": "ArticulationGripper",
                "description": "[summary]\n\n Args:\n gripper_dof_names (list): [description]\n gripper_open_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n gripper_closed_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n ",
                "snippet": "articulation_gripper = ArticulationGripper(gripper_dof_names=gripper_dof_names,  # list\n                                           gripper_open_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                                           gripper_closed_position=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "apply_action",
                "description": "[summary]\n\n  Args:\n  action (ArticulationAction): [description]\n  ",
                "snippet": "articulation_gripper.apply_action(action=action)  # omni.isaac.core.utils.types.ArticulationAction\n"
                },
                {
                "title": "get_positions",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "positions = articulation_gripper.get_positions()\n"
                },
                {
                "title": "get_velocities",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "velocities = articulation_gripper.get_velocities()\n"
                },
                {
                "title": "initialize",
                "description": "[summary]\n\n  Args:\n  root_prim_path (str): [description]\n  articulation_controller (ArticulationController): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation_gripper.initialize(root_prim_path=root_prim_path,  # str\n                                articulation_controller=articulation_controller)  # omni.isaac.core.controllers.articulation_controller.ArticulationController\n"
                },
                {
                "title": "set_positions",
                "description": "[summary]\n\n  Args:\n  positions (np.ndarray): [description]\n  ",
                "snippet": "articulation_gripper.set_positions(positions=positions)  # numpy.ndarray\n"
                },
                {
                "title": "set_velocities",
                "description": "[summary]\n\n  Args:\n  velocities (np.ndarray): [description]\n  ",
                "snippet": "articulation_gripper.set_velocities(velocities=velocities)  # numpy.ndarray\n"
                }
                ]
                },
                {
                "title": "ArticulationSubset",
                "snippets": [
                {
                "title": "ArticulationSubset",
                "description": " A utility class for viewing a subset of the joints in a robot Articulation object.\n\nThis class can be helpful in two ways:\n\n1) The order of joints returned by a robot Articulation may not match the order of joints\n expected by a function\n \n2) A function may only care about a subset of the joint states that are returned by a robot\n Articulation.\n\nExample:\n\n Suppose the robot Articulation returns positions [0,1,2] for joints [\"A\",\"B\",\"C\"], and\n suppose that we pass joint_names = [\"B\",\"A\"].\n\n ArticulationSubset.get_joint_positions() -> [1,0]\n ArticulationSubset.map_to_articulation_order([1,0]) -> [0,1,None]\n\nArgs:\n articulation (Articulation):\n An initialized Articulation object representing the simulated robot\n joint_names (List[str]):\n A list of joint names whose order determines the order of the joints returned by\n functions like get_joint_positions()",
                "snippet": "articulation_subset = ArticulationSubset(articulation=articulation,  # omni.isaac.core.articulations.articulation.Articulation\n                                         joint_names=joint_names)  # typing.List[str]\n"
                },
                {
                "title": "apply_action",
                "description": " Apply the specified control actions to this views joints.\n\n  Args:\n  joint_positions: Target joint positions for this subset's joints.\n  joint_velocities: Target joint velocities for this subset's joints.\n  ",
                "snippet": "articulation_subset.apply_action(joint_positions=None,  # typing.Union[<built-in function array>, NoneType]\n                                 joint_velocities=None)  # typing.Union[<built-in function array>, NoneType]\n"
                },
                {
                "title": "get_applied_action",
                "description": " Retrieves the latest applied action for this subset.\n\n  Returns: The ArticulationAction for this subset. Each commanded entry is either None or\n  contains one value for each of the subset's joints. The joint_indices is set to this\n  subset's joint indices.\n  ",
                "snippet": "applied_action = articulation_subset.get_applied_action()\n"
                },
                {
                "title": "get_joint_efforts",
                "description": "Get joint efforts for the joint names that were passed into this articulation view on\n  initialization.  The indices of the joint efforts returned correspond to the indices of the\n  joint names.\n\n  Returns:\n  np.array: joint efforts \n  ",
                "snippet": "joint_efforts = articulation_subset.get_joint_efforts()\n"
                },
                {
                "title": "get_joint_positions",
                "description": "Get joint positions for the joint names that were passed into this articulation view on\n  initialization.  The indices of the joint positions returned correspond to the indices of\n  the joint names.\n\n  Returns:\n  np.array: joint positions \n  ",
                "snippet": "joint_positions = articulation_subset.get_joint_positions()\n"
                },
                {
                "title": "get_joint_subset_indices",
                "description": "Accessor for the joint indices for this subset. These are the indices into the full\n  articulation degrees of freedom corresponding to this subset of joints.\n\n  Returns:\n  np.array: An array of joint indices defining the subset.\n  ",
                "snippet": "joint_subset_indices = articulation_subset.get_joint_subset_indices()\n"
                },
                {
                "title": "get_joint_velocities",
                "description": "Get joint velocities for the joint names that were passed into this articulation view on\n  initialization.  The indices of the joint velocities returned correspond to the indices of\n  the joint names.\n\n  Returns:\n  np.array: joint velocities \n  ",
                "snippet": "joint_velocities = articulation_subset.get_joint_velocities()\n"
                },
                {
                "title": "get_joints_state",
                "description": "",
                "snippet": "joints_state = articulation_subset.get_joints_state()\n"
                },
                {
                "title": "make_articulation_action",
                "description": " Make an articulation action for only this subset's joints using the given target\n  position and velocity values.\n\n  Args:\n  joint_positions: Target joint positions for this subset's joints.\n  joint_velocities: Target joint velocities for this subset's joints.\n\n  Returns: An ArticulationAction object specifying the action for this subset's joints.\n  ",
                "snippet": "articulation_subset.make_articulation_action(joint_positions=joint_positions,  # numpy.array\n                                             joint_velocities=joint_velocities)  # numpy.array\n"
                },
                {
                "title": "map_to_articulation_order",
                "description": "Map a set of joint values to a format consumable by the robot Articulation.  \n\n  Args:\n  joint_values (np.array): a set of joint values corresponding to the joint_names used to initialize this class. \n  joint_values may be either one or two dimensional.\n\n  If one dimensional with shape (k,): A vector will be returned with length (self.articulation.num_dof) that may\n  be consumed by the robot Articulation in an ArticulationAction.\n\n  If two dimensional with shape (N, k): A matrix will be returned with shape (N, self.articulation.num_dof) that may be\n  converted to N ArticulationActions\n\n  Returns:\n  np.array: a set of joint values that is padded with None to match the shape and order expected by the robot Articulation. \n  ",
                "snippet": "articulation_subset.map_to_articulation_order(joint_values=joint_values)  # numpy.array\n"
                },
                {
                "title": "set_joint_efforts",
                "description": " Set the joint efforts for this view.\n\n  Args:\n  efforts: The effort values, one for each view joint in the order specified on\n  construction.\n  ",
                "snippet": "articulation_subset.set_joint_efforts(efforts=efforts)  # numpy.array\n"
                },
                {
                "title": "set_joint_positions",
                "description": " Set the joint positions for this view.\n\n  Args:\n  positions: The position values, one for each view joint in the order specified on\n  construction.\n  ",
                "snippet": "articulation_subset.set_joint_positions(positions=positions)  # numpy.array\n"
                },
                {
                "title": "set_joint_velocities",
                "description": " Set the joint velocities for this view.\n\n  Args:\n  velocities: The velocity values, one for each view joint in the order specified on\n  construction.\n  ",
                "snippet": "articulation_subset.set_joint_velocities(velocities=velocities)  # numpy.array\n"
                }
                ]
                },
                {
                "title": "ArticulationView",
                "snippets": [
                {
                "title": "ArticulationView",
                "description": " Provides high level functions to deal with prims that has root articulation api applied to it (1 or more articulations) \n as well as its attributes/ properties.\n This object wraps all matching articulations found at the regex provided at the prim_paths_expr.\n\n Note: - each prim will have \"xformOp:orient\", \"xformOp:translate\" and \"xformOp:scale\" only post init,\n unless it is a non-root articulation link.\n\n Args:\n prim_paths_expr (str): prim paths regex to encapsulate all prims that match it.\n example: \"/World/Env[1-5]/Franka\" will match /World/Env1/Franka, \n /World/Env2/Franka..etc.\n (a non regex prim path can also be used to encapsulate one rigid prim).\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene. \n Defaults to \"articulation_prim_view\".\n positions (Optional[Union[np.ndarray, torch.Tensor]], optional): default positions in the world frame of the prims. \n shape is (N, 3). Defaults to None, which means left unchanged.\n translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default translations in the local frame of the prims\n (with respect to its parent prims). shape is (N, 3).\n Defaults to None, which means left unchanged.\n orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default quaternion orientations in the world/ local frame of the prims\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (N, 4).\n scales (Optional[Union[np.ndarray, torch.Tensor]], optional): local scales to be applied to \n the prim's dimensions in the view. shape is (N, 3).\n Defaults to None, which means left unchanged.\n visibilities (Optional[Union[np.ndarray, torch.Tensor]], optional): set to false for an invisible prim in \n the stage while rendering. shape is (N,). \n Defaults to None.\n reset_xform_properties (bool, optional): True if the prims don't have the right set of xform properties \n (i.e: translate, orient and scale) ONLY and in that order.\n Set this parameter to False if the object were cloned using using \n the cloner api in omni.isaac.cloner. Defaults to True.\n enable_dof_force_sensors (bool, optional): enables the solver computed dof force sensors on articulation joints. \n Defaults to False. \n ",
                "snippet": "articulation_view = ArticulationView(prim_paths_expr=prim_paths_expr,  # str\n                                     name=\"articulation_prim_view\",  # str\n                                     positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     visibilities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     reset_xform_properties=True,  # bool\n                                     enable_dof_force_sensors=False)  # bool\n"
                },
                {
                "title": "apply_action",
                "description": " Applies ArticulationActions which encapsulates joint position targets, velocity targets, efforts and joint indices in one object.\n  Can be used instead of the seperate set_joint_position_targets..etc.\n\n  Args:\n  control_actions (ArticulationActions): actions to be applied for next physics step.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.apply_action(control_actions=control_actions,  # omni.isaac.core.utils.types.ArticulationActions\n                               indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_angular_velocities",
                "description": "Gets the angular velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: angular velocities of the prims in the view. shape is (M, 3).\n  ",
                "snippet": "angular_velocities = articulation_view.get_angular_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                              clone=True)  # bool\n"
                },
                {
                "title": "get_applied_actions",
                "description": "Gets current applied actions in an ArticulationActions object.\n\n  Args:\n  clone (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n  Returns:\n  ArticulationActions: current applied actions (i.e: current position targets and velocity targets)\n  ",
                "snippet": "applied_actions = articulation_view.get_applied_actions(clone=True)  # bool\n"
                },
                {
                "title": "get_applied_joint_efforts",
                "description": "Gets the joint efforts of articulations in the view. The method will return the efforts set by the set_joint_efforts.\n  \n  Args:\n  efforts (Optional[Union[np.ndarray, torch.Tensor]]): efforts of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: joint efforts of articulations in the view assigned via set_joint_efforts. shape is (M, K).\n  ",
                "snippet": "applied_joint_efforts = articulation_view.get_applied_joint_efforts(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                    joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                    clone=True)  # bool\n"
                },
                {
                "title": "get_armatures",
                "description": "Gets armatures for articulation in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (Optional[bool]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: maximum efforts for articulations in the view. shape (M, K).\n  ",
                "snippet": "armatures = articulation_view.get_armatures(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            clone=True)  # bool\n"
                },
                {
                "title": "get_articulation_body_count",
                "description": "  Returns:\n  int: number of links in the articulation.\n  ",
                "snippet": "articulation_body_count = articulation_view.get_articulation_body_count()\n"
                },
                {
                "title": "get_body_coms",
                "description": "Gets rigid body center of mass of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body center of mass positions and orientations of articulations in the view. \n  position shape is (M, K, 3), orientation shape is (M, k, 4).\n  ",
                "snippet": "body_coms = articulation_view.get_body_coms(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            clone=True)  # bool\n"
                },
                {
                "title": "get_body_index",
                "description": "Gets the body index in the articulation given its name.\n\n  Args:\n  body_name (str): name of the body/link to query.\n\n  Returns:\n  int: index of the body/link in the articulation buffers.\n  ",
                "snippet": "body_index = articulation_view.get_body_index(body_name=body_name)  # str\n"
                },
                {
                "title": "get_body_inertias",
                "description": "Gets rigid body inertias of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inertias of articulations in the view. \n  shape is (M, K, 9).\n  ",
                "snippet": "body_inertias = articulation_view.get_body_inertias(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                    body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                    clone=True)  # bool\n"
                },
                {
                "title": "get_body_inv_inertias",
                "description": "Gets rigid body inverse inertias of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inverse inertias of articulations in the view. \n  shape is (M, K, 9).\n  ",
                "snippet": "body_inv_inertias = articulation_view.get_body_inv_inertias(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                            body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                            clone=True)  # bool\n"
                },
                {
                "title": "get_body_inv_masses",
                "description": "Gets rigid body inverse masses of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inverse masses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "body_inv_masses = articulation_view.get_body_inv_masses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                        body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                        clone=True)  # bool\n"
                },
                {
                "title": "get_body_masses",
                "description": "Gets rigid body masses of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body masses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "body_masses = articulation_view.get_body_masses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                clone=True)  # bool\n"
                },
                {
                "title": "get_coriolis_and_centrifugal_forces",
                "description": "Gets the coriolis and centrifugal forces of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Coriolis and centrifugal forces of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "coriolis_and_centrifugal_forces = articulation_view.get_coriolis_and_centrifugal_forces(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                                        joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                                        clone=True)  # bool\n"
                },
                {
                "title": "get_dof_index",
                "description": "Gets the dof index in the joint buffers given its name.\n\n  Args:\n  dof_name (str): name of the joint that corresponds to the degree of freedom to query.\n\n  Returns:\n  int: index of the degree of freedom in the joint buffers.\n  ",
                "snippet": "dof_index = articulation_view.get_dof_index(dof_name=dof_name)  # str\n"
                },
                {
                "title": "get_dof_limits",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: degrees of freedom position limits. \n  shape is (N, num_dof, 2) where index 0 corresponds to the lower limit and index 1 corresponds to the upper limit. \n  ",
                "snippet": "dof_limits = articulation_view.get_dof_limits()\n"
                },
                {
                "title": "get_dof_types",
                "description": "Gets the dof types given the dof names.\n\n  Args:\n  dof_names (List[str], optional): names of the joints that corresponds to the degrees of freedom to query. Defaults to None.\n\n  Returns:\n  List[str]: types of the joints that corresponds to the degrees of freedom. Types can be invalid, translation or rotation.\n  ",
                "snippet": "dof_types = articulation_view.get_dof_types(dof_names=None)  # typing.List[str]\n"
                },
                {
                "title": "get_effort_modes",
                "description": "  Gets effort modes for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n\n  Returns:\n  List: Returns a List of size (M, K) indicating the effort modes. accelaration or force.\n  ",
                "snippet": "effort_modes = articulation_view.get_effort_modes(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                  joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_enabled_self_collisions",
                "description": "  Gets the enable self collisions flag\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: true if self collisions enabled. otherwise false. shape (M,)\n  ",
                "snippet": "enabled_self_collisions = articulation_view.get_enabled_self_collisions(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_fixed_tendon_dampings",
                "description": "Gets the dampings of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon dampings of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_dampings = articulation_view.get_fixed_tendon_dampings(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                    clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_limit_stiffnesses",
                "description": "Gets the limit stiffness of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_limit_stiffnesses = articulation_view.get_fixed_tendon_limit_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_limits",
                "description": "Gets the limits of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K, 2).\n  ",
                "snippet": "fixed_tendon_limits = articulation_view.get_fixed_tendon_limits(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_offsets",
                "description": "Gets the offsets of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_offsets = articulation_view.get_fixed_tendon_offsets(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                  clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_rest_lengths",
                "description": "Gets the rest length of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_rest_lengths = articulation_view.get_fixed_tendon_rest_lengths(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                            clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_stiffnesses",
                "description": "Gets the stiffness of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_stiffnesses = articulation_view.get_fixed_tendon_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                          clone=True)  # bool\n"
                },
                {
                "title": "get_friction_coefficients",
                "description": "Gets friction coefficients for articulation in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (Optional[bool]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: maximum efforts for articulations in the view. shape (M, K).\n  ",
                "snippet": "friction_coefficients = articulation_view.get_friction_coefficients(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                    joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                    clone=True)  # bool\n"
                },
                {
                "title": "get_gains",
                "description": "  Gets stiffness and damping of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n  Returns:\n  Tuple[Union[np.ndarray, torch.Tensor], Union[np.ndarray, torch.Tensor]]: stiffness and damping of\n   articulations in the view respectively. shapes are (M, K).\n  ",
                "snippet": "gains = articulation_view.get_gains(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                    joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                    clone=True)  # bool\n"
                },
                {
                "title": "get_generalized_gravity_forces",
                "description": "Gets the generalized gravity forces of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: generalized gravity forces of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "generalized_gravity_forces = articulation_view.get_generalized_gravity_forces(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                              joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                              clone=True)  # bool\n"
                },
                {
                "title": "get_jacobian_shape",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: shape of jacobian for a single articulation. \n  ",
                "snippet": "jacobian_shape = articulation_view.get_jacobian_shape()\n"
                },
                {
                "title": "get_jacobians",
                "description": "Gets the jacobians of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: jacobians of articulations in the view. \n  shape is (M, jacobian_shape).\n  ",
                "snippet": "jacobians = articulation_view.get_jacobians(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            clone=True)  # bool\n"
                },
                {
                "title": "get_joint_positions",
                "description": "Gets the joint positions of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: joint positions of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "joint_positions = articulation_view.get_joint_positions(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                        joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                        clone=True)  # bool\n"
                },
                {
                "title": "get_joint_velocities",
                "description": "Gets the joint velocities of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: joint velocities of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "joint_velocities = articulation_view.get_joint_velocities(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                          joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                          clone=True)  # bool\n"
                },
                {
                "title": "get_joints_default_state",
                "description": "  Returns:\n  JointsState: current joints default state. (i.e: the joint positions and velocities after a reset).\n  ",
                "snippet": "joints_default_state = articulation_view.get_joints_default_state()\n"
                },
                {
                "title": "get_joints_state",
                "description": "  Returns:\n  JointsState: current joint positions and velocities.\n  ",
                "snippet": "joints_state = articulation_view.get_joints_state()\n"
                },
                {
                "title": "get_linear_velocities",
                "description": "Gets the linear velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: linear velocities of the prims in the view. shape is (M, 3).\n  ",
                "snippet": "linear_velocities = articulation_view.get_linear_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                            clone=True)\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local frame (the prim's parent frame).\n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is positions in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = articulation_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_mass_matrices",
                "description": "Gets the mass matrices of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: mass matrices of articulations in the view. \n  shape is (M, mass_matrix_shape).\n  ",
                "snippet": "mass_matrices = articulation_view.get_mass_matrices(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                    clone=True)  # bool\n"
                },
                {
                "title": "get_mass_matrix_shape",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: shape of mass matrix for a single articulation. \n  ",
                "snippet": "mass_matrix_shape = articulation_view.get_mass_matrix_shape()\n"
                },
                {
                "title": "get_max_efforts",
                "description": "Gets maximum efforts for articulation in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (Optional[bool]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: maximum efforts for articulations in the view. shape (M, K).\n  ",
                "snippet": "max_efforts = articulation_view.get_max_efforts(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                clone=True)  # bool\n"
                },
                {
                "title": "get_sleep_thresholds",
                "description": "Gets sleep thresholds for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: current sleep thresholds. shape (M,).\n  ",
                "snippet": "sleep_thresholds = articulation_view.get_sleep_thresholds(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_solver_position_iteration_counts",
                "description": "Gets the physics solver itertion counts for joint positions.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: number of iterations for the solver. Shape (M,).\n  ",
                "snippet": "solver_position_iteration_counts = articulation_view.get_solver_position_iteration_counts(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_solver_velocity_iteration_counts",
                "description": "  Gets the physics solver itertion counts for joint velocities.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: number of iterations for the solver. Shape (M,).\n  ",
                "snippet": "solver_velocity_iteration_counts = articulation_view.get_solver_velocity_iteration_counts(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_stabilization_thresholds",
                "description": "Gets the stabilizaion thresholds.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: current stabilization thresholds. Shape (M,).\n  ",
                "snippet": "stabilization_thresholds = articulation_view.get_stabilization_thresholds(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_velocities",
                "description": "Gets the linear and angular velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: linear and angular velocities of the prims in the view concatenated. shape is (M, 6).\n  ",
                "snippet": "velocities = articulation_view.get_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                              clone=True)  # bool\n"
                },
                {
                "title": "get_world_poses",
                "description": "Gets the poses of the prims in the view with respect to the world's frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = articulation_view.get_world_poses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                clone=True)  # bool\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates an articulation view using physX tensor api.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "articulation_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: False if .initialize() needs to be called again for the physics handle to be valid. Otherwise True.\n  Note: if physics handle is not valid many of the methods that requires physX will return None.\n  ",
                "snippet": "articulation_view.is_physics_handle_valid()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state.\n  ",
                "snippet": "articulation_view.post_reset()\n"
                },
                {
                "title": "set_angular_velocities",
                "description": "Sets the angular velocities of the prims in the view. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n  Note: This method is not supported for the gpu pipeline. set_velocities method should be used instead.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): angular velocities to set the rigid prims to. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_angular_velocities(velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                         indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_armatures",
                "description": "Sets armatures for articulation joints in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): armatures for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_armatures(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_body_coms",
                "description": "Sets body center of mass positions and orientations for articulation bodies in the view.\n\n  Args:\n  positions (Union[np.ndarray, torch.Tensor]): body center of mass positions for articulations in the view. shape (M, K, 3).\n  orientations (Union[np.ndarray, torch.Tensor]): body center of mass orientations for articulations in the view. shape (M, K, 4).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to manipulate. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  ",
                "snippet": "articulation_view.set_body_coms(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                body_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_body_inertias",
                "description": "Sets body inertias for articulation bodies in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): body inertias for articulations in the view. shape (M, K, 9).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to manipulate. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  ",
                "snippet": "articulation_view.set_body_inertias(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                    indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                    body_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_body_masses",
                "description": "Sets body masses for articulation bodies in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): body masses for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to manipulate. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  ",
                "snippet": "articulation_view.set_body_masses(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                  indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                  body_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_effort_modes",
                "description": "  Sets effort modes for articulations in the view.\n\n  Args:\n  mode (str): effort mode to be applied to prims in the view. force or acceleration.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n\n  Raises:\n  Exception: _description_\n  ",
                "snippet": "articulation_view.set_effort_modes(mode=mode,  # str\n                                   indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                   joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_enabled_self_collisions",
                "description": " Sets the enable self collisions flag\n\n  Args:\n  flags (Union[np.ndarray, torch.Tensor]): true to enable self collision. otherwise false. shape (M,)\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_enabled_self_collisions(flags=flags,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_fixed_tendon_properties",
                "description": "Sets fixed tendon properties for articulations in the view.\n\n  Args:\n  stiffnesses (Union[np.ndarray, torch.Tensor]): fixed tendon stiffnesses for articulations in the view. shape (M, K).\n  dampings (Union[np.ndarray, torch.Tensor]): fixed tendon dampings for articulations in the view. shape (M, K).\n  limit_stiffnesses (Union[np.ndarray, torch.Tensor]): fixed tendon limit stiffnesses for articulations in the view. shape (M, K).\n  limits (Union[np.ndarray, torch.Tensor]): fixed tendon limits for articulations in the view. shape (M, K, 2).\n  rest_lengths (Union[np.ndarray, torch.Tensor]): fixed tendon rest lengths for articulations in the view. shape (M, K).\n  offsets (Union[np.ndarray, torch.Tensor]): fixed tendon offsets for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_fixed_tendon_properties(stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              dampings=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              limit_stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              limits=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              rest_lengths=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                              indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_friction_coefficients",
                "description": "Sets friction coefficients for articulation joints in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): friction coefficients for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_friction_coefficients(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                            indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_gains",
                "description": "  Sets stiffness and damping of articulations in the view.\n\n  Args:\n  kps (Optional[Union[np.ndarray, torch.Tensor]], optional): stiffness of the drives. shape is (M, K). Defaults to None.\n  kds (Optional[Union[np.ndarray, torch.Tensor]], optional): damping of the drives. shape is (M, K).. Defaults to None.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  save_to_usd (bool, optional): True to save the gains in the usd. otherwise False.\n  ",
                "snippet": "articulation_view.set_gains(kps=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                            kds=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                            indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                            joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                            save_to_usd=False)  # bool\n"
                },
                {
                "title": "set_joint_efforts",
                "description": "Sets the joint efforts of articulations in the view.\n\n  Args:\n  efforts (Optional[Union[np.ndarray, torch.Tensor]]): efforts of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_joint_efforts(efforts=efforts,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                    joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_position_targets",
                "description": "  Sets the joint position targets for the implicit pd controllers.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]]): joint position targets for the implicit pd controller. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_joint_position_targets(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                             indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                             joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_positions",
                "description": "Sets the joint positions of articulations in the view.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]]): joint positions of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_joint_positions(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                      joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_velocities",
                "description": "Sets the joint velocities of articulations in the view.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): joint velocities of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_joint_velocities(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                       indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                       joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_velocity_targets",
                "description": "  Sets the joint velocity targets for the implicit pd controllers.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): joint velocity targets for the implicit pd controller. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_joint_velocity_targets(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                             indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                             joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joints_default_state",
                "description": "Sets the joints default state (joint positions, velocities and efforts) to be applied after each reset.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): default joint positions.\n   shape is (N, num of dofs). Defaults to None.\n  velocities (Optional[Union[np.ndarray, torch.Tensor]], optional): default joint velocities.\n   shape is (N, num of dofs). Defaults to None.\n  efforts (Optional[Union[np.ndarray, torch.Tensor]], optional): default joint efforts.\n   shape is (N, num of dofs). Defaults to None.\n  ",
                "snippet": "articulation_view.set_joints_default_state(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                           velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                           efforts=None)  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_linear_velocities",
                "description": "Sets the linear velocities of the prims in the view. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n  Note: This method is not supported for the gpu pipeline. set_velocities method should be used instead.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): linear velocities to set the rigid prims to. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_linear_velocities(velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                        indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_max_efforts",
                "description": "Sets maximum efforts for articulation in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): maximum efforts for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.set_max_efforts(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                  indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                  joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_sleep_thresholds",
                "description": " Sets sleep thresholds for articulations in the view.\n\n  Args:\n  thresholds (Union[np.ndarray, torch.Tensor]): sleep thresholds to be applied. shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_sleep_thresholds(thresholds=thresholds,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_solver_position_iteration_counts",
                "description": "  Sets the physics solver itertion counts for joint positions.\n\n  Args:\n  counts (Union[np.ndarray, torch.Tensor]): number of iterations for the solver. Shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_solver_position_iteration_counts(counts=counts,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                       indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_solver_velocity_iteration_counts",
                "description": "  Sets the physics solver itertion counts for joint velocities.\n\n  Args:\n  counts (Union[np.ndarray, torch.Tensor]): number of iterations for the solver. Shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_solver_velocity_iteration_counts(counts=counts,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                       indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_stabilization_thresholds",
                "description": "Sets the stabilizaion thresholds.\n\n  Args:\n  thresholds (Union[np.ndarray, torch.Tensor]): stabilization thresholds to be applied. Shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_stabilization_thresholds(thresholds=thresholds,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                               indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_velocities",
                "description": "Sets the linear and angular velocities of the prims in the view at once. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): linear and angular velocities respectively to set the rigid prims to. shape is (M, 6).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_velocities(velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets poses of prims in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "switch_control_mode",
                "description": " Switches control mode between velocity, position or effort.\n\n  Args:\n  mode (str): control mode to switch the articulations specified to. mode can be velocity, position or effort.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "articulation_view.switch_control_mode(mode=mode,  # str\n                                      indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                      joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "switch_dof_control_mode",
                "description": "Switches dof control mode between velocity, position or effort.\n\n  Args:\n  mode (str): control mode to switch the dof in articulations specified to. mode an be velocity, position or effort.\n  dof_index (int): dof index to swith the control mode of.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.switch_dof_control_mode(mode=mode,  # str\n                                          dof_index=dof_index,  # int\n                                          indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_visual_materials",
                "description": "Used to apply visual material to the prims and optionally its prim descendants.\n\n  Args:\n  visual_materials (Union[VisualMaterial, List[VisualMaterial]]): visual materials to be applied to the prims. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass. If a list is provided then\n  its size has to be equal the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional):  True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of visual materials != length of prims indexed\n  Exception: length of visual materials != length of weaker descendants bools arg\n  ",
                "snippet": "articulation_view.apply_visual_materials(visual_materials=visual_materials,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, typing.List[omni.isaac.core.materials.visual_material.VisualMaterial]]\n                                         weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                         indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_visual_materials",
                "description": "\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[VisualMaterial]: a list of the current applied visual materials to the prims if its type is currently supported.\n  ",
                "snippet": "applied_visual_materials = articulation_view.get_applied_visual_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimViewState: returns the default state of the prims (positions and orientations) that is used after each reset.\n  ",
                "snippet": "default_state = articulation_view.get_default_state()\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local's frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is translations in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = articulation_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_local_scales",
                "description": "Gets prim scales in the view with respect to the local frame (the parent's frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n  ",
                "snippet": "local_scales = articulation_view.get_local_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_visibilities",
                "description": "Returns the current visibilities of the prims in stage.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Shape (M,) with type bool, where each item holds True \n   if the prim is visible in stage. False otherwise.\n  ",
                "snippet": "visibilities = articulation_view.get_visibilities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_poses",
                "description": " Returns the poses (positions and orientations) of the prims in the view with respect to the world frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = articulation_view.get_world_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_scales",
                "description": "Gets prim scales in the view with respect to the world's frame.\n\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n  ",
                "snippet": "world_scales = articulation_view.get_world_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "articulation_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "articulation_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[bool]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n  ",
                "snippet": "articulation_view.is_visual_material_applied(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state (positions and orientations).\n  ",
                "snippet": "articulation_view.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prims (positions and orientations), that will be used after each reset.\n\n  Args:\n  positions (Optional[np.ndarray], optional):  positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[np.ndarray], optional): quaternion orientations in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                    orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_scales",
                "description": "Sets prim scales in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scales (Optional[Union[np.ndarray, torch.Tensor]]): scales to be applied to the prim's dimensions in the view. \n  shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_local_scales(scales=scales,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                   indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_visibilities",
                "description": "Sets the visibilities of the prims in stage.\n\n  Args:\n  visibilities (Union[np.ndarray, torch.Tensor]): flag to set the visibilities of the usd prims in stage. \n  Shape (M,). Where M <= size of the encapsulated prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_visibilities(visibilities=visibilities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                   indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets prim poses in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prims. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "articulation_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                }
                ]
                },
                {
                "title": "Controllers",
                "snippets": [
                {
                "title": "ArticulationController",
                "snippets": [
                {
                "title": "ArticulationController",
                "description": "PD Controller of all degrees of freedom of an articulation, can apply position targets, velocity targets and efforts.\n\n Checkout the required tutorials at \n https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html \n ",
                "snippet": "articulation_controller = ArticulationController()\n"
                },
                {
                "title": "apply_action",
                "description": "[summary]\n\n  Args:\n  control_actions (ArticulationAction): actions to be applied for next physics step.\n  indices (Optional[Union[list, np.ndarray]], optional): degree of freedom indices to apply actions to.\n   Defaults to all degrees of freedom.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation_controller.apply_action(control_actions=control_actions)  # omni.isaac.core.utils.types.ArticulationAction\n"
                },
                {
                "title": "get_applied_action",
                "description": "\n  Raises:\n  Exception: [description]\n\n  Returns:\n  ArticulationAction: Gets last applied action.\n  ",
                "snippet": "applied_action = articulation_controller.get_applied_action()\n"
                },
                {
                "title": "get_effort_modes",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n  NotImplementedError: [description]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "effort_modes = articulation_controller.get_effort_modes()\n"
                },
                {
                "title": "get_gains",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: [description]\n  ",
                "snippet": "gains = articulation_controller.get_gains()\n"
                },
                {
                "title": "get_joint_limits",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: [description]\n  ",
                "snippet": "joint_limits = articulation_controller.get_joint_limits()\n"
                },
                {
                "title": "get_max_efforts",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "max_efforts = articulation_controller.get_max_efforts()\n"
                },
                {
                "title": "initialize",
                "description": "[summary]\n\n  Args:\n  handle ([type]): [description]\n  dof_infos ([type]): [description]\n  ",
                "snippet": "articulation_controller.initialize(handle=handle,\n                                   articulation_view=articulation_view)\n"
                },
                {
                "title": "set_effort_modes",
                "description": "[summary]\n\n  Args:\n  mode (str): [description]\n  indices (Optional[Union[np.ndarray, list]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  Exception: [description]\n  ",
                "snippet": "articulation_controller.set_effort_modes(mode=mode,  # str\n                                         joint_indices=None)  # typing.Union[numpy.ndarray, list, NoneType]\n"
                },
                {
                "title": "set_gains",
                "description": "[summary]\n\n  Args:\n  kps (Optional[np.ndarray], optional): [description]. Defaults to None.\n  kds (Optional[np.ndarray], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation_controller.set_gains(kps=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  kds=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  save_to_usd=False)  # bool\n"
                },
                {
                "title": "set_max_efforts",
                "description": "[summary]\n\n  Args:\n  value (float, optional): [description]. Defaults to None.\n  indices (Optional[Union[np.ndarray, list]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation_controller.set_max_efforts(values=values,  # numpy.ndarray\n                                        joint_indices=None)  # typing.Union[numpy.ndarray, list, NoneType]\n"
                },
                {
                "title": "switch_control_mode",
                "description": "[summary]\n\n  Args:\n  mode (str): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation_controller.switch_control_mode(mode=mode)  # str\n"
                },
                {
                "title": "switch_dof_control_mode",
                "description": "[summary]\n\n  Args:\n  dof_index (int): [description]\n  mode (str): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "articulation_controller.switch_dof_control_mode(dof_index=dof_index,  # int\n                                                mode=mode)  # str\n"
                }
                ]
                },
                {
                "title": "BaseController",
                "snippets": [
                {
                "title": "BaseController",
                "description": "[summary]\n\n Args:\n name (str): [description]\n ",
                "snippet": "base_controller = BaseController(name=name)  # str\n"
                },
                {
                "title": "forward",
                "description": "A controller should take inputs and returns an ArticulationAction to be then passed to the \n   ArticulationController.\n\n  Args:\n  observations (dict): [description]\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  ArticulationAction: [description]\n  ",
                "snippet": "base_controller.forward()\n"
                },
                {
                "title": "reset",
                "description": "Resets state of the controller.\n  ",
                "snippet": "base_controller.reset()\n"
                }
                ]
                },
                {
                "title": "BaseGripperController",
                "snippets": [
                {
                "title": "BaseGripperController",
                "description": "[summary]\n\n Args:\n name (str): [description]\n ",
                "snippet": "base_gripper_controller = BaseGripperController(name=name)  # str\n"
                },
                {
                "title": "close",
                "description": "[summary]\n\n  Args:\n  current_joint_positions (np.ndarray): [description]\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  ArticulationAction: [description]\n  ",
                "snippet": "base_gripper_controller.close(current_joint_positions=current_joint_positions)  # numpy.ndarray\n"
                },
                {
                "title": "forward",
                "description": "Action has be \"open\" or \"close\"\n\n  Args:\n  action (str): \"open\" or \"close\"\n  current_joint_positions (np.ndarray): [description]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  ArticulationAction: [description]\n  ",
                "snippet": "base_gripper_controller.forward(action=action,  # str\n                                current_joint_positions=current_joint_positions)  # numpy.ndarray\n"
                },
                {
                "title": "open",
                "description": "[summary]\n\n  Args:\n  current_joint_positions (np.ndarray): [description]\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  ArticulationAction: [description]\n  ",
                "snippet": "base_gripper_controller.open(current_joint_positions=current_joint_positions)  # numpy.ndarray\n"
                },
                {
                "title": "reset",
                "description": "[summary]\n  ",
                "snippet": "base_gripper_controller.reset()\n"
                }
                ]
                }
                ]
                },
                {
                "title": "DataLogger",
                "snippets": [
                {
                "title": "DataLogger",
                "description": " This class takes care of collecting data as well as reading already saved data in order to replay it for instance.",
                "snippet": "data_logger = DataLogger()\n"
                },
                {
                "title": "add_data",
                "description": " Adds data to the log\n\n  Args:\n  data (dict): Dictionary representing the data to be logged at this time index.\n  current_time_step (float): time step corresponding to the data collected.\n  current_time (float): time in seconds corresponding to the data collected.\n  ",
                "snippet": "data_logger.add_data(data=data,  # dict\n                     current_time_step=current_time_step,  # float\n                     current_time=current_time)  # float\n"
                },
                {
                "title": "add_data_frame_logging_func",
                "description": "\n  Args:\n  func (Callable[[list[BaseTask], Scene], None]): function to be called at every step when the logger is started.\n  should follow:\n\n  def dummy_data_collection_fn(tasks, scene):\n  return {\"data 1\": [data]}\n  ",
                "snippet": "data_logger.add_data_frame_logging_func(func=func)  # typing.Callable[[typing.List[omni.isaac.core.tasks.base_task.BaseTask], omni.isaac.core.scenes.scene.Scene], typing.Dict]\n"
                },
                {
                "title": "get_data_frame",
                "description": "\n  Args:\n  data_frame_index (int): index of the data frame to retrieve.\n\n  Returns:\n  DataFrame: Data Frame collected/ retrieved at the specified data frame index.\n  ",
                "snippet": "data_frame = data_logger.get_data_frame(data_frame_index=data_frame_index)  # int\n"
                },
                {
                "title": "get_num_of_data_frames",
                "description": "\n  Returns:\n  int: the number of data frames collected/ retrieved in the data logger.\n  ",
                "snippet": "num_of_data_frames = data_logger.get_num_of_data_frames()\n"
                },
                {
                "title": "is_started",
                "description": "  Returns:\n  bool: True if data collection is started/ resumed. False otherwise.\n  ",
                "snippet": "data_logger.is_started()\n"
                },
                {
                "title": "load",
                "description": "Loads data from a json file to read back a previous saved data or to resume recording data from another time step.\n\n  Args:\n  log_path (str): path of the json file to be used to load the data.\n  ",
                "snippet": "data_logger.load(log_path=log_path)  # str\n"
                },
                {
                "title": "pause",
                "description": "Pauses data collection.\n  ",
                "snippet": "data_logger.pause()\n"
                },
                {
                "title": "reset",
                "description": "Clears the data in the logger.\n  ",
                "snippet": "data_logger.reset()\n"
                },
                {
                "title": "save",
                "description": "  Saves the current data in the logger to a json file\n\n  Args:\n  log_path (str): path of the json file to be used to save the data.\n  ",
                "snippet": "data_logger.save(log_path=log_path)  # str\n"
                },
                {
                "title": "start",
                "description": "Resumes/ starts data collection.\n  ",
                "snippet": "data_logger.start()\n"
                }
                ]
                },
                {
                "title": "Materials",
                "snippets": [
                {
                "title": "OmniGlass",
                "snippets": [
                {
                "title": "OmniGlass",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"omni_glass\".\n shader (Optional[UsdShade.Shader], optional): [description]. Defaults to None.\n color (Optional[np.ndarray], optional): [description]. Defaults to None.\n ior (Optional[float], optional): [description]. Defaults to None.\n depth (Optional[float], optional): [description]. Defaults to None.\n thin_walled (Optional[bool], optional): [description]. Defaults to None.\n\n Raises:\n Exception: [description]\n ",
                "snippet": "omni_glass = OmniGlass(prim_path=prim_path,  # str\n                       name=\"omni_glass\",  # str\n                       shader=None,  # typing.Union[pxr.UsdShade.Shader, NoneType]\n                       color=None,  # typing.Union[numpy.ndarray, NoneType]\n                       ior=None,  # typing.Union[float, NoneType]\n                       depth=None,  # typing.Union[float, NoneType]\n                       thin_walled=None)  # typing.Union[bool, NoneType]\n"
                },
                {
                "title": "get_color",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "color = omni_glass.get_color()\n"
                },
                {
                "title": "get_depth",
                "description": "",
                "snippet": "depth = omni_glass.get_depth()\n"
                },
                {
                "title": "get_ior",
                "description": "",
                "snippet": "ior = omni_glass.get_ior()\n"
                },
                {
                "title": "get_thin_walled",
                "description": "",
                "snippet": "thin_walled = omni_glass.get_thin_walled()\n"
                },
                {
                "title": "set_color",
                "description": "[summary]\n\n  Args:\n  color (np.ndarray): [description]\n  ",
                "snippet": "omni_glass.set_color(color=color)  # numpy.ndarray\n"
                },
                {
                "title": "set_depth",
                "description": "",
                "snippet": "omni_glass.set_depth(depth=depth)  # float\n"
                },
                {
                "title": "set_ior",
                "description": "",
                "snippet": "omni_glass.set_ior(ior=ior)  # float\n"
                },
                {
                "title": "set_thin_walled",
                "description": "",
                "snippet": "omni_glass.set_thin_walled(thin_walled=thin_walled)  # float\n"
                }
                ]
                },
                {
                "title": "OmniPBR",
                "snippets": [
                {
                "title": "OmniPBR",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"omni_pbr\".\n shader (Optional[UsdShade.Shader], optional): [description]. Defaults to None.\n texture_path (Optional[str], optional): [description]. Defaults to None.\n texture_scale (Optional[np.ndarray], optional): [description]. Defaults to None.\n color (Optional[np.ndarray], optional): [description]. Defaults to None.\n ",
                "snippet": "omni_pbr = OmniPBR(prim_path=prim_path,  # str\n                   name=\"omni_pbr\",  # str\n                   shader=None,  # typing.Union[pxr.UsdShade.Shader, NoneType]\n                   texture_path=None,  # typing.Union[str, NoneType]\n                   texture_scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                   color=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_color",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "color = omni_pbr.get_color()\n"
                },
                {
                "title": "get_metallic_constant",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "metallic_constant = omni_pbr.get_metallic_constant()\n"
                },
                {
                "title": "get_project_uvw",
                "description": "[summary]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "project_uvw = omni_pbr.get_project_uvw()\n"
                },
                {
                "title": "get_reflection_roughness",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "reflection_roughness = omni_pbr.get_reflection_roughness()\n"
                },
                {
                "title": "get_texture",
                "description": "[summary]\n\n  Returns:\n  str: [description]\n  ",
                "snippet": "texture = omni_pbr.get_texture()\n"
                },
                {
                "title": "get_texture_scale",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "texture_scale = omni_pbr.get_texture_scale()\n"
                },
                {
                "title": "set_color",
                "description": "[summary]\n\n  Args:\n  color (np.ndarray): [description]\n  ",
                "snippet": "omni_pbr.set_color(color=color)  # numpy.ndarray\n"
                },
                {
                "title": "set_metallic_constant",
                "description": "[summary]\n\n  Args:\n  amount (float): [description]\n  ",
                "snippet": "omni_pbr.set_metallic_constant(amount=amount)  # float\n"
                },
                {
                "title": "set_project_uvw",
                "description": "[summary]\n\n  Args:\n  flag (bool): [description]\n  ",
                "snippet": "omni_pbr.set_project_uvw(flag=flag)  # bool\n"
                },
                {
                "title": "set_reflection_roughness",
                "description": "[summary]\n\n  Args:\n  amount (float): [description]\n  ",
                "snippet": "omni_pbr.set_reflection_roughness(amount=amount)  # float\n"
                },
                {
                "title": "set_texture",
                "description": "[summary]\n\n  Args:\n  path (str): [description]\n  ",
                "snippet": "omni_pbr.set_texture(path=path)  # str\n"
                },
                {
                "title": "set_texture_scale",
                "description": "[summary]\n\n  Args:\n  x (float): [description]\n  y (float): [description]\n  ",
                "snippet": "omni_pbr.set_texture_scale(x=x,  # float\n                           y=y)  # float\n"
                }
                ]
                },
                {
                "title": "ParticleMaterial",
                "snippets": [
                {
                "title": "ParticleMaterial",
                "description": "A wrapper around position-based-dynamics (PBD) material for particles used to\nsimulate fluids, cloth and inflatables.\n\nNote:\n Currently, only a single material per particle system is supported which applies\n to all objects that are associated with the system.",
                "snippet": "particle_material = ParticleMaterial(prim_path=prim_path,  # str\n                                     name=\"particle_material\",  # typing.Union[str, NoneType]\n                                     friction=None,  # typing.Union[float, NoneType]\n                                     particle_friction_scale=None,  # typing.Union[float, NoneType]\n                                     damping=None,  # typing.Union[float, NoneType]\n                                     viscosity=None,  # typing.Union[float, NoneType]\n                                     vorticity_confinement=None,  # typing.Union[float, NoneType]\n                                     surface_tension=None,  # typing.Union[float, NoneType]\n                                     cohesion=None,  # typing.Union[float, NoneType]\n                                     adhesion=None,  # typing.Union[float, NoneType]\n                                     particle_adhesion_scale=None,  # typing.Union[float, NoneType]\n                                     adhesion_offset_scale=None,  # typing.Union[float, NoneType]\n                                     gravity_scale=None,  # typing.Union[float, NoneType]\n                                     lift=None,  # typing.Union[float, NoneType]\n                                     drag=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "get_adhesion",
                "description": "  Returns:\n  float: The adhesion for interaction between particles (solid or fluid), and rigids or deformables.\n  ",
                "snippet": "adhesion = particle_material.get_adhesion()\n"
                },
                {
                "title": "get_adhesion_offset_scale",
                "description": "  Returns:\n  float: The adhesion offset scale.\n  ",
                "snippet": "adhesion_offset_scale = particle_material.get_adhesion_offset_scale()\n"
                },
                {
                "title": "get_cohesion",
                "description": "  Returns:\n  float: The cohesion for interaction between fluid particles.\n  ",
                "snippet": "cohesion = particle_material.get_cohesion()\n"
                },
                {
                "title": "get_damping",
                "description": "  Returns:\n  float: The global velocity damping coefficient.\n  ",
                "snippet": "damping = particle_material.get_damping()\n"
                },
                {
                "title": "get_drag",
                "description": "  Returns:\n  float: The drag coefficient, basic aerodynamic drag model coefficient.\n  ",
                "snippet": "drag = particle_material.get_drag()\n"
                },
                {
                "title": "get_friction",
                "description": "  Returns:\n  float: The friction coefficient.\n  ",
                "snippet": "friction = particle_material.get_friction()\n"
                },
                {
                "title": "get_gravity_scale",
                "description": "  Returns:\n  float: The gravitational acceleration scaling factor.\n  ",
                "snippet": "gravity_scale = particle_material.get_gravity_scale()\n"
                },
                {
                "title": "get_lift",
                "description": "  Returns:\n  float: The lift coefficient, basic aerodynamic lift model coefficient.\n  ",
                "snippet": "lift = particle_material.get_lift()\n"
                },
                {
                "title": "get_particle_adhesion_scale",
                "description": "  Returns:\n  float: The particle adhesion scale.\n  ",
                "snippet": "particle_adhesion_scale = particle_material.get_particle_adhesion_scale()\n"
                },
                {
                "title": "get_particle_friction_scale",
                "description": "  Returns:\n  float: The particle friction scale.\n  ",
                "snippet": "particle_friction_scale = particle_material.get_particle_friction_scale()\n"
                },
                {
                "title": "get_surface_tension",
                "description": "  Returns:\n  float: The surface tension for fluid particles.\n  ",
                "snippet": "surface_tension = particle_material.get_surface_tension()\n"
                },
                {
                "title": "get_viscosity",
                "description": "  Returns:\n  float: The viscosity.\n  ",
                "snippet": "viscosity = particle_material.get_viscosity()\n"
                },
                {
                "title": "get_vorticity_confinement",
                "description": "  Returns:\n  float: The vorticity confinement for fluid particles.\n  ",
                "snippet": "vorticity_confinement = particle_material.get_vorticity_confinement()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "particle_material.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "particle_material.is_valid()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state.\n  ",
                "snippet": "particle_material.post_reset()\n"
                },
                {
                "title": "set_adhesion",
                "description": "Sets the adhesion for interaction between particles (solid or fluid), and rigid or deformable objects.\n\n  Note:\n  Adhesion also applies to solid-solid particle interactions, but is multiplied with the\n  particle adhesion scale.\n\n  Args:\n  value (float): The adhesion.\n  Range: [0, inf), Units: dimensionless\n\n  ",
                "snippet": "particle_material.set_adhesion(value=value)  # float\n"
                },
                {
                "title": "set_adhesion_offset_scale",
                "description": "Sets the adhesion offset scale.\n\n  It defines the offset at which adhesion ceases to take effect. For interactions between\n  particles (fluid or solid), and rigids or deformables, the adhesion offset is defined\n  relative to the rest offset. For solid particle-particle interactions, the adhesion\n  offset is defined relative to the solid rest offset.\n\n  Args:\n  value (float): The adhesion offset scale.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_adhesion_offset_scale(value=value)  # float\n"
                },
                {
                "title": "set_cohesion",
                "description": "Sets the cohesion for interaction between fluid particles.\n\n  Args:\n  value (float): The cohesion.\n  Range: [0, inf), Units: dimensionless\n\n  ",
                "snippet": "particle_material.set_cohesion(value=value)  # float\n"
                },
                {
                "title": "set_damping",
                "description": "Sets the global velocity damping coefficient.\n\n  Args:\n  value (float): The damping coefficient.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_damping(value=value)  # float\n"
                },
                {
                "title": "set_drag",
                "description": "Sets the drag coefficient, i.e. basic aerodynamic drag model coefficient.\n\n  It is useful for cloth and inflatable particle objects.\n\n  Args:\n  value (float): The drag coefficient.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_drag(value=value)  # float\n"
                },
                {
                "title": "set_friction",
                "description": "Sets the friction coefficient.\n\n  The friction takes effect in all interactions between particles and rigids or deformables.\n  For solid particle-particle interactions it is multiplied by the particle friction scale.\n\n  Args:\n  value (float): The friction coefficient.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_friction(value=value)  # float\n"
                },
                {
                "title": "set_gravity_scale",
                "description": "Sets the gravitational acceleration scaling factor.\n\n  It can be used to approximate lighter-than-air inflatable.\n  For example (-1.0 would invert gravity).\n\n  Args:\n  value (float): The gravity scale.\n  Range: (-inf , inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_gravity_scale(value=value)  # float\n"
                },
                {
                "title": "set_lift",
                "description": "Sets the lift coefficient, i.e. basic aerodynamic lift model coefficient.\n\n  It is useful for cloth and inflatable particle objects.\n\n  Args:\n  value (float): The lift coefficient.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_lift(value=value)  # float\n"
                },
                {
                "title": "set_particle_adhesion_scale",
                "description": "Sets the particle adhesion scale.\n\n  This coefficient scales the adhesion for solid particle-particle interaction.\n\n  Args:\n  value (float): The adhesion scale.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_particle_adhesion_scale(value=value)  # float\n"
                },
                {
                "title": "set_particle_friction_scale",
                "description": "Sets the particle friction scale.\n\n  The coefficient that scales friction for solid particle-particle interaction.\n\n  Args:\n  value (float): The particle friction scale.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_particle_friction_scale(value=value)  # float\n"
                },
                {
                "title": "set_surface_tension",
                "description": "Sets the surface tension for fluid particles.\n\n  Args:\n  value (float): The surface tension.\n  Range: [0, inf), Units: 1 / (distance * distance * distance)\n  ",
                "snippet": "particle_material.set_surface_tension(value=value)  # float\n"
                },
                {
                "title": "set_viscosity",
                "description": "Sets the viscosity for fluid particles.\n\n  Args:\n  value (float): The viscosity.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_viscosity(value=value)  # float\n"
                },
                {
                "title": "set_vorticity_confinement",
                "description": "Sets the vorticity confinement for fluid particles.\n\n  This helps prevent energy loss due to numerical solver by adding vortex-like\n  accelerations to the particles.\n\n  Args:\n  value (float): The vorticity confinement.\n  Range: [0, inf), Units: dimensionless\n  ",
                "snippet": "particle_material.set_vorticity_confinement(value=value)  # float\n"
                }
                ]
                },
                {
                "title": "ParticleMaterialView",
                "snippets": [
                {
                "title": "ParticleMaterialView",
                "description": "The view class to deal with particleMaterial prims.\n Provides high level functions to deal with particle material (1 or more particle materials) \n as well as its attributes/ properties. This object wraps all matching materials found at the regex provided at the prim_paths_expr.\n This object wraps all matching materials Prims found at the regex provided at the prim_paths_expr.",
                "snippet": "particle_material_view = ParticleMaterialView(prim_paths_expr=prim_paths_expr,  # str\n                                              name=\"particle_material_view\",  # str\n                                              frictions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              particle_friction_scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              dampings=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              viscosities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              vorticity_confinements=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              surface_tensions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              cohesions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              adhesions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              particle_adhesion_scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              adhesion_offset_scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              gravity_scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              lifts=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                              drags=None)  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_adhesion_offset_scales",
                "description": "Gets the adhesion offset scale of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: adhesion offset scale tensor with shape (M, )\n  ",
                "snippet": "adhesion_offset_scales = particle_material_view.get_adhesion_offset_scales(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                           clone=True)  # bool\n"
                },
                {
                "title": "get_adhesions",
                "description": "Gets the adhesion of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: adhesion tensor with shape (M, )\n  ",
                "snippet": "adhesions = particle_material_view.get_adhesions(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_cohesions",
                "description": "Gets the cohesion of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: cohesion tensor with shape (M, )\n  ",
                "snippet": "cohesions = particle_material_view.get_cohesions(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_dampings",
                "description": "Gets the dampings of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: dampings tensor with shape (M, )\n  ",
                "snippet": "dampings = particle_material_view.get_dampings(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                               clone=True)  # bool\n"
                },
                {
                "title": "get_drags",
                "description": "Gets the drags of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: drag tensor with shape (M, )\n  ",
                "snippet": "drags = particle_material_view.get_drags(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                         clone=True)  # bool\n"
                },
                {
                "title": "get_frictions",
                "description": "Gets the friction of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n   Union[np.ndarray, torch.Tensor]: friction tensor with shape (M, )\n  ",
                "snippet": "frictions = particle_material_view.get_frictions(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_gravity_scales",
                "description": "Gets the gravity scale of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: gravity scale tensor with shape (M, )\n  ",
                "snippet": "gravity_scales = particle_material_view.get_gravity_scales(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                           clone=True)  # bool\n"
                },
                {
                "title": "get_lifts",
                "description": "Gets the lifts of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: lift tensor with shape (M, )\n  ",
                "snippet": "lifts = particle_material_view.get_lifts(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                         clone=True)  # bool\n"
                },
                {
                "title": "get_particle_adhesion_scales",
                "description": "Gets the adhesion scale of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: adhesion scale tensor with shape (M, )\n  ",
                "snippet": "particle_adhesion_scales = particle_material_view.get_particle_adhesion_scales(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                               clone=True)  # bool\n"
                },
                {
                "title": "get_particle_friction_scales",
                "description": "Gets the particle friction scale of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: particle friction scale tensor with shape (M, )\n  ",
                "snippet": "particle_friction_scales = particle_material_view.get_particle_friction_scales(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                               clone=True)  # bool\n"
                },
                {
                "title": "get_surface_tensions",
                "description": "Gets the surface tension of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: surface tension tensor with shape (M, )\n  ",
                "snippet": "surface_tensions = particle_material_view.get_surface_tensions(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                               clone=True)  # bool\n"
                },
                {
                "title": "get_viscosities",
                "description": "Gets the viscosity of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: viscosity tensor with shape (M, )\n  ",
                "snippet": "viscosities = particle_material_view.get_viscosities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                     clone=True)  # bool\n"
                },
                {
                "title": "get_vorticity_confinements",
                "description": "Gets the vorticity confinement of materials indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: vorticity confinement tensor with shape (M, )\n  ",
                "snippet": "vorticity_confinements = particle_material_view.get_vorticity_confinements(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                           clone=True)  # bool\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates a rigid body view in physX.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "particle_material_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n  ",
                "snippet": "particle_material_view.is_physics_handle_valid()\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "particle_material_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the particles to their initial states.\n  ",
                "snippet": "particle_material_view.post_reset()\n"
                },
                {
                "title": "set_adhesion_offset_scales",
                "description": "Sets the adhesion offset scale for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material adhesion offset scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_adhesion_offset_scales(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_adhesions",
                "description": "Sets the particle adhesion for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle adhesion scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_adhesions(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_cohesions",
                "description": "Sets the particle cohesion for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle cohesion scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_cohesions(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_dampings",
                "description": "Sets the dampings for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material damping tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_dampings(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_drags",
                "description": "Sets the drags for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material drag tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_drags(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_frictions",
                "description": "Sets the friction for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material friction tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_frictions(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_gravity_scales",
                "description": "Sets the gravity scale for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material gravity scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_gravity_scales(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_lifts",
                "description": "Sets the lifts for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material lift tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_lifts(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_particle_adhesion_scales",
                "description": "Sets the particle adhesion for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle adhesion scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_particle_adhesion_scales(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_particle_friction_scales",
                "description": "Sets the particle friction scale for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle friction scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_particle_friction_scales(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_surface_tensions",
                "description": "Sets the particle surface tension for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle surface tension scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_surface_tensions(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                            indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_viscosities",
                "description": "Sets the particle viscosity for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle viscosity scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_viscosities(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                       indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_vorticity_confinements",
                "description": "Sets the vorticity confinement for the material prims indicated by the indices.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]], optional): material particle vorticity confinement scale tensor with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which material prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "particle_material_view.set_vorticity_confinements(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                },
                {
                "title": "PhysicsMaterial",
                "snippets": [
                {
                "title": "PhysicsMaterial",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"physics_material\".\n static_friction (Optional[float], optional): [description]. Defaults to None.\n dynamic_friction (Optional[float], optional): [description]. Defaults to None.\n restitution (Optional[float], optional): [description]. Defaults to None.\n ",
                "snippet": "physics_material = PhysicsMaterial(prim_path=prim_path,  # str\n                                   name=\"physics_material\",  # str\n                                   static_friction=None,  # typing.Union[float, NoneType]\n                                   dynamic_friction=None,  # typing.Union[float, NoneType]\n                                   restitution=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "get_dynamic_friction",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "dynamic_friction = physics_material.get_dynamic_friction()\n"
                },
                {
                "title": "get_restitution",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "restitution = physics_material.get_restitution()\n"
                },
                {
                "title": "get_static_friction",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "static_friction = physics_material.get_static_friction()\n"
                },
                {
                "title": "set_dynamic_friction",
                "description": "[summary]\n\n  Args:\n  friction (float): [description]\n  ",
                "snippet": "physics_material.set_dynamic_friction(friction=friction)  # float\n"
                },
                {
                "title": "set_restitution",
                "description": "[summary]\n\n  Args:\n  restitution (float): [description]\n  ",
                "snippet": "physics_material.set_restitution(restitution=restitution)  # float\n"
                },
                {
                "title": "set_static_friction",
                "description": "[summary]\n\n  Args:\n  friction (float): [description]\n  ",
                "snippet": "physics_material.set_static_friction(friction=friction)  # float\n"
                }
                ]
                },
                {
                "title": "PreviewSurface",
                "snippets": [
                {
                "title": "PreviewSurface",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"preview_surface\".\n shader (Optional[UsdShade.Shader], optional): [description]. Defaults to None.\n color (Optional[np.ndarray], optional): [description]. Defaults to None.\n roughness (Optional[float], optional): [description]. Defaults to None.\n metallic (Optional[float], optional): [description]. Defaults to None.\n ",
                "snippet": "preview_surface = PreviewSurface(prim_path=prim_path,  # str\n                                 name=\"preview_surface\",  # str\n                                 shader=None,  # typing.Union[pxr.UsdShade.Shader, NoneType]\n                                 color=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 roughness=None,  # typing.Union[float, NoneType]\n                                 metallic=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "get_color",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "color = preview_surface.get_color()\n"
                },
                {
                "title": "get_metallic",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "metallic = preview_surface.get_metallic()\n"
                },
                {
                "title": "get_roughness",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "roughness = preview_surface.get_roughness()\n"
                },
                {
                "title": "set_color",
                "description": "[summary]\n\n  Args:\n  color (np.ndarray): [description]\n  ",
                "snippet": "preview_surface.set_color(color=color)  # numpy.ndarray\n"
                },
                {
                "title": "set_metallic",
                "description": "[summary]\n\n  Args:\n  metallic (float): [description]\n  ",
                "snippet": "preview_surface.set_metallic(metallic=metallic)  # float\n"
                },
                {
                "title": "set_roughness",
                "description": "[summary]\n\n  Args:\n  roughness (float): [description]\n  ",
                "snippet": "preview_surface.set_roughness(roughness=roughness)  # float\n"
                }
                ]
                },
                {
                "title": "VisualMaterial",
                "snippets": [
                {
                "title": "VisualMaterial",
                "description": "[summary]\n\n Args:\n name (str): [description]\n prim_path (str): [description]\n prim (Usd.Prim): [description]\n shaders_list (list[UsdShade.Shader]): [description]\n material (UsdShade.Material): [description]\n ",
                "snippet": "visual_material = VisualMaterial(name=name,  # str\n                                 prim_path=prim_path,  # str\n                                 prim=prim,  # pxr.Usd.Prim\n                                 shaders_list=shaders_list,  # typing.List[pxr.UsdShade.Shader]\n                                 material=material)  # pxr.UsdShade.Material\n"
                }
                ]
                }
                ]
                },
                {
                "title": "Objects",
                "snippets": [
                {
                "title": "DynamicCapsule",
                "snippets": [
                {
                "title": "DynamicCapsule",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"dynamic_capsule\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n height (Optional[np.ndarray], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n mass (Optional[float], optional): _description_. Defaults to None.\n density (Optional[float], optional): _description_. Defaults to None.\n linear_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n angular_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n ",
                "snippet": "dynamic_capsule = DynamicCapsule(prim_path=prim_path,  # str\n                                 name=\"dynamic_capsule\",  # str\n                                 position=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 visible=None,  # typing.Union[bool, NoneType]\n                                 color=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 height=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                                 physics_material=None,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n                                 mass=None,  # typing.Union[float, NoneType]\n                                 density=None,  # typing.Union[float, NoneType]\n                                 linear_velocity=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 angular_velocity=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_capsule.disable_rigid_body_physics()\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": " enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_capsule.enable_rigid_body_physics()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "  Returns:\n  np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "angular_velocity = dynamic_capsule.get_angular_velocity()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid body including position, orientation, linear_velocity and angular_velocity.\n  ",
                "snippet": "current_dynamic_state = dynamic_capsule.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  DynamicState: returns the default state of the prim (position, orientation, linear_velocity and \n  angular_velocity) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_capsule.get_default_state()\n"
                },
                {
                "title": "get_density",
                "description": "  Returns:\n  float: density of the rigid body.\n  ",
                "snippet": "density = dynamic_capsule.get_density()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "  Returns:\n  np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "linear_velocity = dynamic_capsule.get_linear_velocity()\n"
                },
                {
                "title": "get_mass",
                "description": "  Returns:\n  float: mass of the rigid body in kg.\n  ",
                "snippet": "mass = dynamic_capsule.get_mass()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "  Returns:\n  float: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "sleep_threshold = dynamic_capsule.get_sleep_threshold()\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "Sets the angular velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_capsule.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_default_state",
                "description": " Sets the default state of the prim, that will be used after each reset. \n  \n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  linear_velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  angular_velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_capsule.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                  orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                  linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_density",
                "description": "  Args:\n  mass (float): density of the rigid body.\n  ",
                "snippet": "dynamic_capsule.set_density(density=density)  # float\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_capsule.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_mass",
                "description": "  Args:\n  mass (float): mass of the rigid body in kg.\n  ",
                "snippet": "dynamic_capsule.set_mass(mass=mass)  # float\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "  Args:\n  threshold (float): Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "dynamic_capsule.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = dynamic_capsule.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = dynamic_capsule.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "dynamic_capsule.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "dynamic_capsule.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_capsule.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                       weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = dynamic_capsule.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = dynamic_capsule.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = dynamic_capsule.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = dynamic_capsule.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = dynamic_capsule.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = dynamic_capsule.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = dynamic_capsule.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = dynamic_capsule.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = dynamic_capsule.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "dynamic_capsule.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "dynamic_capsule.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "dynamic_capsule.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_capsule.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "dynamic_capsule.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_capsule.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_capsule.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                      weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = dynamic_capsule.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_capsule.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = dynamic_capsule.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = dynamic_capsule.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = dynamic_capsule.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = dynamic_capsule.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = dynamic_capsule.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "dynamic_capsule.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "dynamic_capsule.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "dynamic_capsule.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "dynamic_capsule.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_capsule.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                  orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_capsule.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_capsule.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "dynamic_capsule.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_capsule.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "DynamicCone",
                "snippets": [
                {
                "title": "DynamicCone",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"dynamic_cone\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n height (Optional[np.ndarray], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n mass (Optional[float], optional): _description_. Defaults to None.\n density (Optional[float], optional): _description_. Defaults to None.\n linear_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n angular_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n ",
                "snippet": "dynamic_cone = DynamicCone(prim_path=prim_path,  # str\n                           name=\"dynamic_cone\",  # str\n                           position=None,  # typing.Union[numpy.ndarray, NoneType]\n                           translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                           orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                           scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                           visible=None,  # typing.Union[bool, NoneType]\n                           color=None,  # typing.Union[numpy.ndarray, NoneType]\n                           radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                           height=None,  # typing.Union[numpy.ndarray, NoneType]\n                           visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                           physics_material=None,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n                           mass=None,  # typing.Union[float, NoneType]\n                           density=None,  # typing.Union[float, NoneType]\n                           linear_velocity=None,  # typing.Union[typing.Sequence[float], NoneType]\n                           angular_velocity=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_cone.disable_rigid_body_physics()\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": " enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_cone.enable_rigid_body_physics()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "  Returns:\n  np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "angular_velocity = dynamic_cone.get_angular_velocity()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid body including position, orientation, linear_velocity and angular_velocity.\n  ",
                "snippet": "current_dynamic_state = dynamic_cone.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  DynamicState: returns the default state of the prim (position, orientation, linear_velocity and \n  angular_velocity) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_cone.get_default_state()\n"
                },
                {
                "title": "get_density",
                "description": "  Returns:\n  float: density of the rigid body.\n  ",
                "snippet": "density = dynamic_cone.get_density()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "  Returns:\n  np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "linear_velocity = dynamic_cone.get_linear_velocity()\n"
                },
                {
                "title": "get_mass",
                "description": "  Returns:\n  float: mass of the rigid body in kg.\n  ",
                "snippet": "mass = dynamic_cone.get_mass()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "  Returns:\n  float: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "sleep_threshold = dynamic_cone.get_sleep_threshold()\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "Sets the angular velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cone.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_default_state",
                "description": " Sets the default state of the prim, that will be used after each reset. \n  \n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  linear_velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  angular_velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cone.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                               angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_density",
                "description": "  Args:\n  mass (float): density of the rigid body.\n  ",
                "snippet": "dynamic_cone.set_density(density=density)  # float\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cone.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_mass",
                "description": "  Args:\n  mass (float): mass of the rigid body in kg.\n  ",
                "snippet": "dynamic_cone.set_mass(mass=mass)  # float\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "  Args:\n  threshold (float): Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "dynamic_cone.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = dynamic_cone.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = dynamic_cone.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "dynamic_cone.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "dynamic_cone.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_cone.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = dynamic_cone.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = dynamic_cone.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = dynamic_cone.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = dynamic_cone.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = dynamic_cone.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = dynamic_cone.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = dynamic_cone.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = dynamic_cone.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = dynamic_cone.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "dynamic_cone.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "dynamic_cone.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "dynamic_cone.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_cone.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "dynamic_cone.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_cone.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_cone.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                   weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = dynamic_cone.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_cone.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = dynamic_cone.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = dynamic_cone.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = dynamic_cone.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = dynamic_cone.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = dynamic_cone.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "dynamic_cone.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "dynamic_cone.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "dynamic_cone.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "dynamic_cone.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cone.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cone.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cone.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "dynamic_cone.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cone.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "DynamicCuboid",
                "snippets": [
                {
                "title": "DynamicCuboid",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"dynamic_cube\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n size (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n mass (Optional[float], optional): _description_. Defaults to None.\n density (Optional[float], optional): _description_. Defaults to None.\n linear_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n angular_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n ",
                "snippet": "dynamic_cuboid = DynamicCuboid(prim_path=prim_path,  # str\n                               name=\"dynamic_cube\",  # str\n                               position=None,  # typing.Union[numpy.ndarray, NoneType]\n                               translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                               orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                               scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                               visible=None,  # typing.Union[bool, NoneType]\n                               color=None,  # typing.Union[numpy.ndarray, NoneType]\n                               size=None,  # typing.Union[float, NoneType]\n                               visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                               physics_material=None,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n                               mass=None,  # typing.Union[float, NoneType]\n                               density=None,  # typing.Union[float, NoneType]\n                               linear_velocity=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               angular_velocity=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_cuboid.disable_rigid_body_physics()\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": " enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_cuboid.enable_rigid_body_physics()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "  Returns:\n  np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "angular_velocity = dynamic_cuboid.get_angular_velocity()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid body including position, orientation, linear_velocity and angular_velocity.\n  ",
                "snippet": "current_dynamic_state = dynamic_cuboid.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  DynamicState: returns the default state of the prim (position, orientation, linear_velocity and \n  angular_velocity) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_cuboid.get_default_state()\n"
                },
                {
                "title": "get_density",
                "description": "  Returns:\n  float: density of the rigid body.\n  ",
                "snippet": "density = dynamic_cuboid.get_density()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "  Returns:\n  np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "linear_velocity = dynamic_cuboid.get_linear_velocity()\n"
                },
                {
                "title": "get_mass",
                "description": "  Returns:\n  float: mass of the rigid body in kg.\n  ",
                "snippet": "mass = dynamic_cuboid.get_mass()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "  Returns:\n  float: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "sleep_threshold = dynamic_cuboid.get_sleep_threshold()\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "Sets the angular velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cuboid.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_default_state",
                "description": " Sets the default state of the prim, that will be used after each reset. \n  \n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  linear_velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  angular_velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cuboid.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_density",
                "description": "  Args:\n  mass (float): density of the rigid body.\n  ",
                "snippet": "dynamic_cuboid.set_density(density=density)  # float\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cuboid.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_mass",
                "description": "  Args:\n  mass (float): mass of the rigid body in kg.\n  ",
                "snippet": "dynamic_cuboid.set_mass(mass=mass)  # float\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "  Args:\n  threshold (float): Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "dynamic_cuboid.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "get_size",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "size = dynamic_cuboid.get_size()\n"
                },
                {
                "title": "set_size",
                "description": "[summary]\n\n  Args:\n  size (float): [description]\n  ",
                "snippet": "dynamic_cuboid.set_size(size=size)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_cuboid.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                      weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = dynamic_cuboid.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = dynamic_cuboid.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = dynamic_cuboid.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = dynamic_cuboid.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = dynamic_cuboid.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = dynamic_cuboid.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = dynamic_cuboid.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = dynamic_cuboid.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = dynamic_cuboid.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "dynamic_cuboid.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "dynamic_cuboid.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "dynamic_cuboid.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_cuboid.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "dynamic_cuboid.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_cuboid.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_cuboid.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = dynamic_cuboid.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_cuboid.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = dynamic_cuboid.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = dynamic_cuboid.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = dynamic_cuboid.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = dynamic_cuboid.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = dynamic_cuboid.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "dynamic_cuboid.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "dynamic_cuboid.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "dynamic_cuboid.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "dynamic_cuboid.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cuboid.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cuboid.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cuboid.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "dynamic_cuboid.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cuboid.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "DynamicCylinder",
                "snippets": [
                {
                "title": "DynamicCylinder",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"dynamic_cylinder\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n height (Optional[np.ndarray], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n mass (Optional[float], optional): _description_. Defaults to None.\n density (Optional[float], optional): _description_. Defaults to None.\n linear_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n angular_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n ",
                "snippet": "dynamic_cylinder = DynamicCylinder(prim_path=prim_path,  # str\n                                   name=\"dynamic_cylinder\",  # str\n                                   position=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   visible=None,  # typing.Union[bool, NoneType]\n                                   color=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   height=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                                   physics_material=None,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n                                   mass=None,  # typing.Union[float, NoneType]\n                                   density=None,  # typing.Union[float, NoneType]\n                                   linear_velocity=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                   angular_velocity=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_cylinder.disable_rigid_body_physics()\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": " enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_cylinder.enable_rigid_body_physics()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "  Returns:\n  np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "angular_velocity = dynamic_cylinder.get_angular_velocity()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid body including position, orientation, linear_velocity and angular_velocity.\n  ",
                "snippet": "current_dynamic_state = dynamic_cylinder.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  DynamicState: returns the default state of the prim (position, orientation, linear_velocity and \n  angular_velocity) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_cylinder.get_default_state()\n"
                },
                {
                "title": "get_density",
                "description": "  Returns:\n  float: density of the rigid body.\n  ",
                "snippet": "density = dynamic_cylinder.get_density()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "  Returns:\n  np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "linear_velocity = dynamic_cylinder.get_linear_velocity()\n"
                },
                {
                "title": "get_mass",
                "description": "  Returns:\n  float: mass of the rigid body in kg.\n  ",
                "snippet": "mass = dynamic_cylinder.get_mass()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "  Returns:\n  float: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "sleep_threshold = dynamic_cylinder.get_sleep_threshold()\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "Sets the angular velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cylinder.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_default_state",
                "description": " Sets the default state of the prim, that will be used after each reset. \n  \n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  linear_velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  angular_velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cylinder.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                   orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                   linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                                   angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_density",
                "description": "  Args:\n  mass (float): density of the rigid body.\n  ",
                "snippet": "dynamic_cylinder.set_density(density=density)  # float\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_cylinder.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_mass",
                "description": "  Args:\n  mass (float): mass of the rigid body in kg.\n  ",
                "snippet": "dynamic_cylinder.set_mass(mass=mass)  # float\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "  Args:\n  threshold (float): Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "dynamic_cylinder.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = dynamic_cylinder.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = dynamic_cylinder.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "dynamic_cylinder.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "dynamic_cylinder.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_cylinder.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                        weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = dynamic_cylinder.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = dynamic_cylinder.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = dynamic_cylinder.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = dynamic_cylinder.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = dynamic_cylinder.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = dynamic_cylinder.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = dynamic_cylinder.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = dynamic_cylinder.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = dynamic_cylinder.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "dynamic_cylinder.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "dynamic_cylinder.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "dynamic_cylinder.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_cylinder.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "dynamic_cylinder.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_cylinder.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_cylinder.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                       weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = dynamic_cylinder.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_cylinder.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = dynamic_cylinder.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = dynamic_cylinder.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = dynamic_cylinder.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = dynamic_cylinder.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = dynamic_cylinder.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "dynamic_cylinder.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "dynamic_cylinder.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "dynamic_cylinder.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "dynamic_cylinder.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cylinder.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                   orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cylinder.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cylinder.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "dynamic_cylinder.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_cylinder.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "DynamicSphere",
                "snippets": [
                {
                "title": "DynamicSphere",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"dynamic_sphere\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n mass (Optional[float], optional): _description_. Defaults to None.\n density (Optional[float], optional): _description_. Defaults to None.\n linear_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n angular_velocity (Optional[Sequence[float]], optional): _description_. Defaults to None.\n ",
                "snippet": "dynamic_sphere = DynamicSphere(prim_path=prim_path,  # str\n                               name=\"dynamic_sphere\",  # str\n                               position=None,  # typing.Union[numpy.ndarray, NoneType]\n                               translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                               orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                               scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                               visible=None,  # typing.Union[bool, NoneType]\n                               color=None,  # typing.Union[numpy.ndarray, NoneType]\n                               radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                               visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                               physics_material=None,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n                               mass=None,  # typing.Union[float, NoneType]\n                               density=None,  # typing.Union[float, NoneType]\n                               linear_velocity=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               angular_velocity=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_sphere.disable_rigid_body_physics()\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": " enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n  ",
                "snippet": "dynamic_sphere.enable_rigid_body_physics()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "  Returns:\n  np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "angular_velocity = dynamic_sphere.get_angular_velocity()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid body including position, orientation, linear_velocity and angular_velocity.\n  ",
                "snippet": "current_dynamic_state = dynamic_sphere.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  DynamicState: returns the default state of the prim (position, orientation, linear_velocity and \n  angular_velocity) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_sphere.get_default_state()\n"
                },
                {
                "title": "get_density",
                "description": "  Returns:\n  float: density of the rigid body.\n  ",
                "snippet": "density = dynamic_sphere.get_density()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "  Returns:\n  np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "linear_velocity = dynamic_sphere.get_linear_velocity()\n"
                },
                {
                "title": "get_mass",
                "description": "  Returns:\n  float: mass of the rigid body in kg.\n  ",
                "snippet": "mass = dynamic_sphere.get_mass()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "  Returns:\n  float: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "sleep_threshold = dynamic_sphere.get_sleep_threshold()\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "Sets the angular velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_sphere.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_default_state",
                "description": " Sets the default state of the prim, that will be used after each reset. \n  \n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  linear_velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  angular_velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_sphere.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_density",
                "description": "  Args:\n  mass (float): density of the rigid body.\n  ",
                "snippet": "dynamic_sphere.set_density(density=density)  # float\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "dynamic_sphere.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_mass",
                "description": "  Args:\n  mass (float): mass of the rigid body in kg.\n  ",
                "snippet": "dynamic_sphere.set_mass(mass=mass)  # float\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "  Args:\n  threshold (float): Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "dynamic_sphere.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = dynamic_sphere.get_radius()\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "dynamic_sphere.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_sphere.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                      weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = dynamic_sphere.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = dynamic_sphere.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = dynamic_sphere.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = dynamic_sphere.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = dynamic_sphere.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = dynamic_sphere.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = dynamic_sphere.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = dynamic_sphere.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = dynamic_sphere.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "dynamic_sphere.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "dynamic_sphere.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "dynamic_sphere.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_sphere.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "dynamic_sphere.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "dynamic_sphere.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "dynamic_sphere.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = dynamic_sphere.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = dynamic_sphere.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = dynamic_sphere.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = dynamic_sphere.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = dynamic_sphere.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = dynamic_sphere.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = dynamic_sphere.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "dynamic_sphere.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "dynamic_sphere.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "dynamic_sphere.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "dynamic_sphere.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_sphere.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_sphere.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_sphere.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "dynamic_sphere.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "dynamic_sphere.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "FixedCapsule",
                "snippets": [
                {
                "title": "FixedCapsule",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"fixed_capsule\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n height (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n ",
                "snippet": "fixed_capsule = FixedCapsule(prim_path=prim_path,  # str\n                             name=\"fixed_capsule\",  # str\n                             position=None,  # typing.Union[numpy.ndarray, NoneType]\n                             translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                             orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                             scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                             visible=None,  # typing.Union[bool, NoneType]\n                             color=None,  # typing.Union[numpy.ndarray, NoneType]\n                             radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                             height=None,  # typing.Union[float, NoneType]\n                             visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                             physics_material=None)  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = fixed_capsule.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = fixed_capsule.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "fixed_capsule.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "fixed_capsule.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_capsule.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = fixed_capsule.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = fixed_capsule.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = fixed_capsule.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = fixed_capsule.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = fixed_capsule.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = fixed_capsule.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = fixed_capsule.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = fixed_capsule.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = fixed_capsule.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "fixed_capsule.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "fixed_capsule.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "fixed_capsule.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_capsule.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "fixed_capsule.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_capsule.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_capsule.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = fixed_capsule.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = fixed_capsule.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = fixed_capsule.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = fixed_capsule.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = fixed_capsule.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = fixed_capsule.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = fixed_capsule.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "fixed_capsule.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "fixed_capsule.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "fixed_capsule.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "fixed_capsule.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_capsule.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_capsule.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_capsule.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "fixed_capsule.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_capsule.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "FixedCone",
                "snippets": [
                {
                "title": "FixedCone",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"fixed_cone\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n height (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n ",
                "snippet": "fixed_cone = FixedCone(prim_path=prim_path,  # str\n                       name=\"fixed_cone\",  # str\n                       position=None,  # typing.Union[numpy.ndarray, NoneType]\n                       translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                       orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                       scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                       visible=None,  # typing.Union[bool, NoneType]\n                       color=None,  # typing.Union[numpy.ndarray, NoneType]\n                       radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                       height=None,  # typing.Union[float, NoneType]\n                       visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                       physics_material=None)  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = fixed_cone.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = fixed_cone.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "fixed_cone.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "fixed_cone.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_cone.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                  weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = fixed_cone.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = fixed_cone.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = fixed_cone.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = fixed_cone.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = fixed_cone.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = fixed_cone.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = fixed_cone.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = fixed_cone.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = fixed_cone.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "fixed_cone.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "fixed_cone.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "fixed_cone.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_cone.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "fixed_cone.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_cone.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_cone.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                 weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = fixed_cone.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = fixed_cone.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = fixed_cone.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = fixed_cone.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = fixed_cone.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = fixed_cone.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = fixed_cone.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "fixed_cone.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "fixed_cone.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "fixed_cone.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "fixed_cone.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cone.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cone.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cone.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "fixed_cone.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cone.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "FixedCuboid",
                "snippets": [
                {
                "title": "FixedCuboid",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"fixed_cube\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n size (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n ",
                "snippet": "fixed_cuboid = FixedCuboid(prim_path=prim_path,  # str\n                           name=\"fixed_cube\",  # str\n                           position=None,  # typing.Union[numpy.ndarray, NoneType]\n                           translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                           orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                           scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                           visible=None,  # typing.Union[bool, NoneType]\n                           color=None,  # typing.Union[numpy.ndarray, NoneType]\n                           size=None,  # typing.Union[float, NoneType]\n                           visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                           physics_material=None)  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n"
                },
                {
                "title": "get_size",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "size = fixed_cuboid.get_size()\n"
                },
                {
                "title": "set_size",
                "description": "[summary]\n\n  Args:\n  size (float): [description]\n  ",
                "snippet": "fixed_cuboid.set_size(size=size)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_cuboid.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = fixed_cuboid.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = fixed_cuboid.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = fixed_cuboid.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = fixed_cuboid.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = fixed_cuboid.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = fixed_cuboid.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = fixed_cuboid.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = fixed_cuboid.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = fixed_cuboid.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "fixed_cuboid.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "fixed_cuboid.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "fixed_cuboid.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_cuboid.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "fixed_cuboid.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_cuboid.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_cuboid.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                   weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = fixed_cuboid.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = fixed_cuboid.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = fixed_cuboid.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = fixed_cuboid.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = fixed_cuboid.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = fixed_cuboid.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = fixed_cuboid.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "fixed_cuboid.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "fixed_cuboid.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "fixed_cuboid.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "fixed_cuboid.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cuboid.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cuboid.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cuboid.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "fixed_cuboid.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cuboid.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "FixedCylinder",
                "snippets": [
                {
                "title": "FixedCylinder",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"fixed_cylinder\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n height (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n ",
                "snippet": "fixed_cylinder = FixedCylinder(prim_path=prim_path,  # str\n                               name=\"fixed_cylinder\",  # str\n                               position=None,  # typing.Union[numpy.ndarray, NoneType]\n                               translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                               orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                               scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                               visible=None,  # typing.Union[bool, NoneType]\n                               color=None,  # typing.Union[numpy.ndarray, NoneType]\n                               radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                               height=None,  # typing.Union[float, NoneType]\n                               visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                               physics_material=None)  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = fixed_cylinder.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = fixed_cylinder.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "fixed_cylinder.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "fixed_cylinder.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_cylinder.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                      weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = fixed_cylinder.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = fixed_cylinder.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = fixed_cylinder.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = fixed_cylinder.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = fixed_cylinder.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = fixed_cylinder.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = fixed_cylinder.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = fixed_cylinder.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = fixed_cylinder.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "fixed_cylinder.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "fixed_cylinder.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "fixed_cylinder.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_cylinder.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "fixed_cylinder.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_cylinder.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_cylinder.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = fixed_cylinder.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = fixed_cylinder.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = fixed_cylinder.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = fixed_cylinder.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = fixed_cylinder.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = fixed_cylinder.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = fixed_cylinder.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "fixed_cylinder.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "fixed_cylinder.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "fixed_cylinder.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "fixed_cylinder.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cylinder.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cylinder.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cylinder.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "fixed_cylinder.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_cylinder.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "FixedSphere",
                "snippets": [
                {
                "title": "FixedSphere",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"fixed_sphere\".\n position (Optional[np.ndarray], optional): _description_. Defaults to None.\n translation (Optional[np.ndarray], optional): _description_. Defaults to None.\n orientation (Optional[np.ndarray], optional): _description_. Defaults to None.\n scale (Optional[np.ndarray], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[np.ndarray], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n physics_material (Optional[PhysicsMaterial], optional): _description_. Defaults to None.\n ",
                "snippet": "fixed_sphere = FixedSphere(prim_path=prim_path,  # str\n                           name=\"fixed_sphere\",  # str\n                           position=None,  # typing.Union[numpy.ndarray, NoneType]\n                           translation=None,  # typing.Union[numpy.ndarray, NoneType]\n                           orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                           scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                           visible=None,  # typing.Union[bool, NoneType]\n                           color=None,  # typing.Union[numpy.ndarray, NoneType]\n                           radius=None,  # typing.Union[numpy.ndarray, NoneType]\n                           visual_material=None,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n                           physics_material=None)  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = fixed_sphere.get_radius()\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "fixed_sphere.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_sphere.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = fixed_sphere.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = fixed_sphere.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = fixed_sphere.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = fixed_sphere.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = fixed_sphere.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = fixed_sphere.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = fixed_sphere.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = fixed_sphere.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = fixed_sphere.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "fixed_sphere.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "fixed_sphere.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "fixed_sphere.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_sphere.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "fixed_sphere.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "fixed_sphere.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "fixed_sphere.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                   weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = fixed_sphere.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = fixed_sphere.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = fixed_sphere.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = fixed_sphere.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = fixed_sphere.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = fixed_sphere.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = fixed_sphere.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "fixed_sphere.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "fixed_sphere.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "fixed_sphere.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "fixed_sphere.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_sphere.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_sphere.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_sphere.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "fixed_sphere.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "fixed_sphere.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "GroundPlane",
                "snippets": [
                {
                "title": "GroundPlane",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"ground_plane\".\n size (Optional[float], optional): [description]. Defaults to 5000.0.\n z_position (float, optional): [description]. Defaults to 0.\n scale (Optional[np.ndarray], optional): [description]. Defaults to None.\n visible (bool, optional): [description]. Defaults to True.\n color (Optional[np.ndarray], optional): [description]. Defaults to None.\n physics_material_path (Optional[PhysicsMaterial], optional): [description]. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): [description]. Defaults to None.\n static_friction (float, optional): [description]. Defaults to 0.5.\n dynamic_friction (float, optional): [description]. Defaults to 0.5.\n restitution (float, optional): [description]. Defaults to 0.8.\n ",
                "snippet": "ground_plane = GroundPlane(prim_path=prim_path,  # str\n                           name=\"ground_plane\",  # str\n                           size=None,  # typing.Union[float, NoneType]\n                           z_position=None,  # typing.Union[float, NoneType]\n                           scale=None,  # typing.Union[numpy.ndarray, NoneType]\n                           visible=None,  # typing.Union[bool, NoneType]\n                           color=None,  # typing.Union[numpy.ndarray, NoneType]\n                           physics_material=None,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, NoneType]\n                           visual_material=None)  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "ground_plane.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = ground_plane.get_applied_physics_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = ground_plane.get_default_state()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = ground_plane.get_world_pose()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "ground_plane.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "ground_plane.is_valid()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "ground_plane.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "ground_plane.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "ground_plane.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                            orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "VisualCapsule",
                "snippets": [
                {
                "title": "VisualCapsule",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"visual_capsule\".\n position (Optional[Sequence[float]], optional): _description_. Defaults to None.\n translation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n orientation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n scale (Optional[Sequence[float]], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[float], optional): _description_. Defaults to None.\n height (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n\n Raises:\n Exception: _description_",
                "snippet": "visual_capsule = VisualCapsule(prim_path=prim_path,  # str\n                               name=\"visual_capsule\",  # str\n                               position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               visible=None,  # typing.Union[bool, NoneType]\n                               color=None,  # typing.Union[numpy.ndarray, NoneType]\n                               radius=None,  # typing.Union[float, NoneType]\n                               height=None,  # typing.Union[float, NoneType]\n                               visual_material=None)  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = visual_capsule.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = visual_capsule.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "visual_capsule.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "visual_capsule.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_capsule.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                      weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = visual_capsule.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = visual_capsule.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = visual_capsule.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = visual_capsule.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = visual_capsule.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = visual_capsule.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = visual_capsule.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = visual_capsule.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = visual_capsule.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "visual_capsule.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "visual_capsule.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "visual_capsule.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_capsule.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "visual_capsule.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_capsule.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_capsule.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = visual_capsule.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = visual_capsule.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = visual_capsule.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = visual_capsule.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = visual_capsule.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = visual_capsule.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = visual_capsule.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "visual_capsule.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "visual_capsule.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "visual_capsule.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "visual_capsule.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_capsule.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_capsule.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_capsule.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "visual_capsule.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_capsule.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "VisualCone",
                "snippets": [
                {
                "title": "VisualCone",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"visual_cone\".\n position (Optional[Sequence[float]], optional): _description_. Defaults to None.\n translation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n orientation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n scale (Optional[Sequence[float]], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[float], optional): _description_. Defaults to None.\n height (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n\n Raises:\n Exception: _description_\n ",
                "snippet": "visual_cone = VisualCone(prim_path=prim_path,  # str\n                         name=\"visual_cone\",  # str\n                         position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         visible=None,  # typing.Union[bool, NoneType]\n                         color=None,  # typing.Union[numpy.ndarray, NoneType]\n                         radius=None,  # typing.Union[float, NoneType]\n                         height=None,  # typing.Union[float, NoneType]\n                         visual_material=None)  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = visual_cone.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = visual_cone.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "visual_cone.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "visual_cone.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_cone.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                   weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = visual_cone.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = visual_cone.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = visual_cone.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = visual_cone.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = visual_cone.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = visual_cone.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = visual_cone.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = visual_cone.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = visual_cone.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "visual_cone.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "visual_cone.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "visual_cone.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_cone.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "visual_cone.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_cone.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_cone.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                  weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = visual_cone.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = visual_cone.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = visual_cone.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = visual_cone.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = visual_cone.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = visual_cone.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = visual_cone.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "visual_cone.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "visual_cone.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "visual_cone.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "visual_cone.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cone.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cone.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                           orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cone.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "visual_cone.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cone.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                           orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "VisualCuboid",
                "snippets": [
                {
                "title": "VisualCuboid",
                "description": "_summary_\n\nArgs:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"visual_cube\".\n position (Optional[Sequence[float]], optional): _description_. Defaults to None.\n translation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n orientation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n scale (Optional[Sequence[float]], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n size (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n\nRaises:\n Exception: _description_",
                "snippet": "visual_cuboid = VisualCuboid(prim_path=prim_path,  # str\n                             name=\"visual_cube\",  # str\n                             position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             visible=None,  # typing.Union[bool, NoneType]\n                             color=None,  # typing.Union[numpy.ndarray, NoneType]\n                             size=None,  # typing.Union[float, NoneType]\n                             visual_material=None)  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n"
                },
                {
                "title": "get_size",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "size = visual_cuboid.get_size()\n"
                },
                {
                "title": "set_size",
                "description": "[summary]\n\n  Args:\n  size (float): [description]\n  ",
                "snippet": "visual_cuboid.set_size(size=size)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_cuboid.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = visual_cuboid.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = visual_cuboid.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = visual_cuboid.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = visual_cuboid.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = visual_cuboid.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = visual_cuboid.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = visual_cuboid.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = visual_cuboid.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = visual_cuboid.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "visual_cuboid.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "visual_cuboid.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "visual_cuboid.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_cuboid.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "visual_cuboid.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_cuboid.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_cuboid.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = visual_cuboid.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = visual_cuboid.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = visual_cuboid.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = visual_cuboid.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = visual_cuboid.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = visual_cuboid.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = visual_cuboid.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "visual_cuboid.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "visual_cuboid.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "visual_cuboid.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "visual_cuboid.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cuboid.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cuboid.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cuboid.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "visual_cuboid.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cuboid.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "VisualCylinder",
                "snippets": [
                {
                "title": "VisualCylinder",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"visual_cylinder\".\n position (Optional[Sequence[float]], optional): _description_. Defaults to None.\n translation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n orientation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n scale (Optional[Sequence[float]], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to None.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[float], optional): _description_. Defaults to None.\n height (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n\n Raises:\n Exception: _description_\n ",
                "snippet": "visual_cylinder = VisualCylinder(prim_path=prim_path,  # str\n                                 name=\"visual_cylinder\",  # str\n                                 position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                 visible=None,  # typing.Union[bool, NoneType]\n                                 color=None,  # typing.Union[numpy.ndarray, NoneType]\n                                 radius=None,  # typing.Union[float, NoneType]\n                                 height=None,  # typing.Union[float, NoneType]\n                                 visual_material=None)  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n"
                },
                {
                "title": "get_height",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "height = visual_cylinder.get_height()\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = visual_cylinder.get_radius()\n"
                },
                {
                "title": "set_height",
                "description": "[summary]\n\n  Args:\n  height (float): [description]\n  ",
                "snippet": "visual_cylinder.set_height(height=height)  # float\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "visual_cylinder.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_cylinder.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                       weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = visual_cylinder.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = visual_cylinder.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = visual_cylinder.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = visual_cylinder.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = visual_cylinder.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = visual_cylinder.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = visual_cylinder.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = visual_cylinder.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = visual_cylinder.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "visual_cylinder.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "visual_cylinder.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "visual_cylinder.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_cylinder.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "visual_cylinder.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_cylinder.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_cylinder.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                      weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = visual_cylinder.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = visual_cylinder.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = visual_cylinder.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = visual_cylinder.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = visual_cylinder.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = visual_cylinder.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = visual_cylinder.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "visual_cylinder.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "visual_cylinder.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "visual_cylinder.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "visual_cylinder.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cylinder.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                  orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cylinder.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cylinder.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "visual_cylinder.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_cylinder.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                               orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "VisualSphere",
                "snippets": [
                {
                "title": "VisualSphere",
                "description": "_summary_\n\n Args:\n prim_path (str): _description_\n name (str, optional): _description_. Defaults to \"visual_sphere\".\n position (Optional[Sequence[float]], optional): _description_. Defaults to None.\n translation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n orientation (Optional[Sequence[float]], optional): _description_. Defaults to None.\n scale (Optional[Sequence[float]], optional): _description_. Defaults to None.\n visible (Optional[bool], optional): _description_. Defaults to True.\n color (Optional[np.ndarray], optional): _description_. Defaults to None.\n radius (Optional[float], optional): _description_. Defaults to None.\n visual_material (Optional[VisualMaterial], optional): _description_. Defaults to None.\n\n Raises:\n Exception: _description_\n ",
                "snippet": "visual_sphere = VisualSphere(prim_path=prim_path,  # str\n                             name=\"visual_sphere\",  # str\n                             position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             visible=True,  # typing.Union[bool, NoneType]\n                             color=None,  # typing.Union[numpy.ndarray, NoneType]\n                             radius=None,  # typing.Union[float, NoneType]\n                             visual_material=None)  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, NoneType]\n"
                },
                {
                "title": "get_radius",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "radius = visual_sphere.get_radius()\n"
                },
                {
                "title": "set_radius",
                "description": "[summary]\n\n  Args:\n  radius (float): [description]\n  ",
                "snippet": "visual_sphere.set_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_sphere.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = visual_sphere.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = visual_sphere.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = visual_sphere.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = visual_sphere.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = visual_sphere.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = visual_sphere.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = visual_sphere.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = visual_sphere.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = visual_sphere.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "visual_sphere.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "visual_sphere.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "visual_sphere.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_sphere.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "visual_sphere.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "visual_sphere.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "visual_sphere.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = visual_sphere.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = visual_sphere.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = visual_sphere.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = visual_sphere.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = visual_sphere.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = visual_sphere.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = visual_sphere.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "visual_sphere.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "visual_sphere.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "visual_sphere.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "visual_sphere.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_sphere.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_sphere.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_sphere.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "visual_sphere.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "visual_sphere.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                }
                ]
                },
                {
                "title": "PhysicsContext",
                "snippets": [
                {
                "title": "PhysicsContext",
                "description": "Provides high level functions to deal with a physics scene and its settings. This will create a \n a PhysicsScene prim at the specified prim path in case there is no PhysicsScene present in the current\n stage. \n If there is a PhysicsScene present, it will discard the prim_path specified and sets the\n default settings on the current PhysicsScene found.\n\n Args:\n physics_dt (float, optional): specifies the physics_dt of the simulation. Defaults to 1.0 / 60.0.\n prim_path (Optional[str], optional): specifies the prim path to create a PhysicsScene at, \n only in the case where no PhysicsScene already defined. \n Defaults to \"/physicsScene\".\n set_defaults (bool, optional): set to True to use the defaults physics parameters\n [physics_dt = 1.0/ 60.0,\n gravity = -9.81 m / s\n ccd_enabled,\n stabilization_enabled,\n gpu dynamics turned off,\n broadcast type is MBP,\n solver type is TGS]. Defaults to True.\n backend (str, optional): specifies the backend to be used (numpy or torch). Defaults to numpy.\n device (Optional[str], optional): specifies the device to be used if running on the gpu with torch backend.\n\n Raises:\n Exception: If prim_path is not absolute.\n Exception: if prim_path already exists and its type is not a PhysicsScene.\n ",
                "snippet": "physics_context = PhysicsContext(physics_dt=None,  # typing.Union[float, NoneType]\n                                 prim_path=\"/physicsScene\",  # str\n                                 sim_params=None,  # dict\n                                 set_defaults=True,  # bool\n                                 backend=\"numpy\",  # str\n                                 device=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "enable_ccd",
                "description": "Enables a second broad phase after integration that makes it possible to prevent objects from tunneling\n   through each other.\n\n  Args:\n  flag (bool): enables or diables ccd on the PhysicsScene\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ",
                "snippet": "physics_context.enable_ccd(flag=flag)  # bool\n"
                },
                {
                "title": "enable_flatcache",
                "description": "",
                "snippet": "physics_context.enable_flatcache(enable=enable)\n"
                },
                {
                "title": "enable_gpu_dynamics",
                "description": "Enables gpu dynamics pipeline, required for deformables for instance.\n\n  Args:\n  flag (bool): enables or diables gpu dynamics on the PhysicsScene\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ",
                "snippet": "physics_context.enable_gpu_dynamics(flag=flag)  # bool\n"
                },
                {
                "title": "enable_stablization",
                "description": "Enables additional stabilization pass in the solver.\n\n  Args:\n  flag (bool): enables or diables stabilization on the PhysicsScene\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ",
                "snippet": "physics_context.enable_stablization(flag=flag)  # bool\n"
                },
                {
                "title": "get_bounce_threshold",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "bounce_threshold = physics_context.get_bounce_threshold()\n"
                },
                {
                "title": "get_broadphase_type",
                "description": "Gets current broadcast phase algorithm type.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  str: Broadcast phase algorithm used.\n  ",
                "snippet": "broadphase_type = physics_context.get_broadphase_type()\n"
                },
                {
                "title": "get_current_physics_scene_prim",
                "description": "Used to return the PhysicsScene prim in stage by traversing the stage.\n\n  Returns:\n  Optional[Usd.Prim]: returns a PhysicsScene prim if found in current stage. Otherwise, None.\n  ",
                "snippet": "current_physics_scene_prim = physics_context.get_current_physics_scene_prim()\n"
                },
                {
                "title": "get_enable_scene_query_support",
                "description": " Retrieves the Enable Scene Query Support attribute in Physx Scene\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  bool: enable scene query support attribute\n  ",
                "snippet": "enable_scene_query_support = physics_context.get_enable_scene_query_support()\n"
                },
                {
                "title": "get_friction_correlation_distance",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "friction_correlation_distance = physics_context.get_friction_correlation_distance()\n"
                },
                {
                "title": "get_friction_offset_threshold",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "friction_offset_threshold = physics_context.get_friction_offset_threshold()\n"
                },
                {
                "title": "get_gpu_found_lost_aggregate_pairs_capacity",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_found_lost_aggregate_pairs_capacity = physics_context.get_gpu_found_lost_aggregate_pairs_capacity()\n"
                },
                {
                "title": "get_gpu_found_lost_pairs_capacity",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_found_lost_pairs_capacity = physics_context.get_gpu_found_lost_pairs_capacity()\n"
                },
                {
                "title": "get_gpu_heap_capacity",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_heap_capacity = physics_context.get_gpu_heap_capacity()\n"
                },
                {
                "title": "get_gpu_max_num_partitions",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_max_num_partitions = physics_context.get_gpu_max_num_partitions()\n"
                },
                {
                "title": "get_gpu_max_particle_contacts",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_max_particle_contacts = physics_context.get_gpu_max_particle_contacts()\n"
                },
                {
                "title": "get_gpu_max_rigid_contact_count",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_max_rigid_contact_count = physics_context.get_gpu_max_rigid_contact_count()\n"
                },
                {
                "title": "get_gpu_max_rigid_patch_count",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_max_rigid_patch_count = physics_context.get_gpu_max_rigid_patch_count()\n"
                },
                {
                "title": "get_gpu_max_soft_body_contacts",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_max_soft_body_contacts = physics_context.get_gpu_max_soft_body_contacts()\n"
                },
                {
                "title": "get_gpu_temp_buffer_capacity",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_temp_buffer_capacity = physics_context.get_gpu_temp_buffer_capacity()\n"
                },
                {
                "title": "get_gpu_total_aggregate_pairs_capacity",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "gpu_total_aggregate_pairs_capacity = physics_context.get_gpu_total_aggregate_pairs_capacity()\n"
                },
                {
                "title": "get_gravity",
                "description": "Gets current gravity.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  Tuple[list, float]: returns a tuple, first element corresponds to the gravity direction vector and second element is the magnitude.\n  ",
                "snippet": "gravity = physics_context.get_gravity()\n"
                },
                {
                "title": "get_invert_collision_group_filter",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "invert_collision_group_filter = physics_context.get_invert_collision_group_filter()\n"
                },
                {
                "title": "get_physics_dt",
                "description": "Returns the current physics dt.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  float: physics dt.\n  ",
                "snippet": "physics_dt = physics_context.get_physics_dt()\n"
                },
                {
                "title": "get_physx_update_transformations_settings",
                "description": "Gets how physx syncs with the usd when transformations are updated.\n\n  Returns:\n  Tuple[bool, bool, bool, bool]: [update_to_fast_cache, update_to_usd, update_velocities_to_usd, output_velocities_local_space]\n  ",
                "snippet": "physx_update_transformations_settings = physics_context.get_physx_update_transformations_settings()\n"
                },
                {
                "title": "get_solver_type",
                "description": "Gets current solver type.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  str: solver used for simulation.\n  ",
                "snippet": "solver_type = physics_context.get_solver_type()\n"
                },
                {
                "title": "is_ccd_enabled",
                "description": "Checks if ccd is enabled.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  bool: True if ccd is enabled, otherwise False.\n  ",
                "snippet": "physics_context.is_ccd_enabled()\n"
                },
                {
                "title": "is_gpu_dynamics_enabled",
                "description": "Checks if Gpu Dynamics is enabled.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  bool: True if Gpu Dynamics is enabled, otherwise False.\n  ",
                "snippet": "physics_context.is_gpu_dynamics_enabled()\n"
                },
                {
                "title": "is_stablization_enabled",
                "description": "Checks if stabilization is enabled.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n\n  Returns:\n  bool: True if stabilization is enabled, otherwise False.\n  ",
                "snippet": "physics_context.is_stablization_enabled()\n"
                },
                {
                "title": "set_bounce_threshold",
                "description": "[summary]\n\n  Args:\n  value (float): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_bounce_threshold(value=value)  # float\n"
                },
                {
                "title": "set_broadphase_type",
                "description": "Broadcast phase algorithm used in simulation.\n\n  Args:\n  broadcast_type (str): type of broadcasting to be used, can be \"MBP\"\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ",
                "snippet": "physics_context.set_broadphase_type(broadcast_type=broadcast_type)  # str\n"
                },
                {
                "title": "set_enable_scene_query_support",
                "description": " Sets the Enable Scene Query Support attribute in Physx Scene\n\n  Args:\n  enable_scene_query_support (bool): Whether to enable scene query support\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_enable_scene_query_support(enable_scene_query_support=enable_scene_query_support)  # bool\n"
                },
                {
                "title": "set_friction_correlation_distance",
                "description": "[summary]\n\n  Args:\n  value (float): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_friction_correlation_distance(value=value)  # float\n"
                },
                {
                "title": "set_friction_offset_threshold",
                "description": "[summary]\n\n  Args:\n  value (float): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_friction_offset_threshold(value=value)  # float\n"
                },
                {
                "title": "set_gpu_found_lost_aggregate_pairs_capacity",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_found_lost_aggregate_pairs_capacity(value=value)  # int\n"
                },
                {
                "title": "set_gpu_found_lost_pairs_capacity",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_found_lost_pairs_capacity(value=value)  # int\n"
                },
                {
                "title": "set_gpu_heap_capacity",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_heap_capacity(value=value)  # int\n"
                },
                {
                "title": "set_gpu_max_num_partitions",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_max_num_partitions(value=value)  # int\n"
                },
                {
                "title": "set_gpu_max_particle_contacts",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_max_particle_contacts(value=value)  # int\n"
                },
                {
                "title": "set_gpu_max_rigid_contact_count",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_max_rigid_contact_count(value=value)  # int\n"
                },
                {
                "title": "set_gpu_max_rigid_patch_count",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_max_rigid_patch_count(value=value)  # int\n"
                },
                {
                "title": "set_gpu_max_soft_body_contacts",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_max_soft_body_contacts(value=value)  # int\n"
                },
                {
                "title": "set_gpu_temp_buffer_capacity",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_temp_buffer_capacity(value=value)  # int\n"
                },
                {
                "title": "set_gpu_total_aggregate_pairs_capacity",
                "description": "[summary]\n\n  Args:\n  value (int): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_gpu_total_aggregate_pairs_capacity(value=value)  # int\n"
                },
                {
                "title": "set_gravity",
                "description": "sets the gravity direction and magnitude.\n\n  Args:\n  value (float): gravity value to be used in simulation.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ",
                "snippet": "physics_context.set_gravity(value=value)  # float\n"
                },
                {
                "title": "set_invert_collision_group_filter",
                "description": "[summary]\n\n  Args:\n  invert_collision_group_filter (bool): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "physics_context.set_invert_collision_group_filter(invert_collision_group_filter=invert_collision_group_filter)  # bool\n"
                },
                {
                "title": "set_physics_dt",
                "description": "Sets the physics dt on the PhysicsScene\n\n  Args:\n  dt (float, optional): physics dt. Defaults to 1.0/60.0.\n  substeps (int, optional): number of physics steps to run for before rendering a frame. Defaults to 1.\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ValueError: Physics dt must be a >= 0.\n  ValueError: Physics dt must be a <= 1.0.\n  ",
                "snippet": "physics_context.set_physics_dt(dt=0.016666666666666666,  # float\n                               substeps=1)  # int\n"
                },
                {
                "title": "set_physx_update_transformations_settings",
                "description": "Sets how physx syncs with the usd when transformations are updated.\n\n  Args:\n  update_to_fast_cache (bool, optional): Uses Fast cache if set to True. Defaults to True.\n  update_to_usd (bool, optional): Updates to USD the transformations. Defaults to True.\n  update_velocities_to_usd (bool, optional): Updates Velocities to USD. Defaults to True.\n  output_velocities_local_space (bool, optional): Output the velocities in the local frame and not the world frame. Defaults to False.\n  ",
                "snippet": "physics_context.set_physx_update_transformations_settings(update_to_fast_cache=None,  # typing.Union[bool, NoneType]\n                                                          update_to_usd=None,  # typing.Union[bool, NoneType]\n                                                          update_velocities_to_usd=None,  # typing.Union[bool, NoneType]\n                                                          output_velocities_local_space=None)  # typing.Union[bool, NoneType]\n"
                },
                {
                "title": "set_solver_type",
                "description": "solver used for simulation.\n\n  Args:\n  solver_type (str): can be \"TGS\" or \"PGS\". for references look at..\n\n  Raises:\n  Exception: If the prim path registered in context doesn't correspond to a valid prim path currently.\n  ",
                "snippet": "physics_context.set_solver_type(solver_type=solver_type)  # str\n"
                },
                {
                "title": "warm_start",
                "description": "",
                "snippet": "physics_context.warm_start()\n"
                }
                ]
                },
                {
                "title": "Prims",
                "snippets": [
                {
                "title": "BaseSensor",
                "snippets": [
                {
                "title": "BaseSensor",
                "description": "",
                "snippet": "base_sensor = BaseSensor(prim_path=prim_path,  # str\n                         name=\"base_sensor\",  # str\n                         position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                         visible=None)  # typing.Union[bool, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "base_sensor.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "post_reset",
                "description": "",
                "snippet": "base_sensor.post_reset()\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "base_sensor.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                  weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = base_sensor.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = base_sensor.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = base_sensor.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = base_sensor.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = base_sensor.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = base_sensor.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = base_sensor.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "base_sensor.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "base_sensor.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "base_sensor.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "base_sensor.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "base_sensor.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                              orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "base_sensor.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                           orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "base_sensor.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "base_sensor.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "base_sensor.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                           orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "ClothPrim",
                "snippets": [
                {
                "title": "ClothPrim",
                "description": "Cloth primitive object provide functionalities to create and control cloth parameters",
                "snippet": "cloth_prim = ClothPrim(prim_path=prim_path,  # str\n                       particle_system=particle_system,  # omni.isaac.core.prims.soft.particle_system.ParticleSystem\n                       particle_material=None,  # typing.Union[omni.isaac.core.materials.particle_material.ParticleMaterial, NoneType]\n                       name=\"cloth\",  # typing.Union[str, NoneType]\n                       position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       visible=None,  # typing.Union[bool, NoneType]\n                       particle_mass=0.01,  # typing.Union[float, NoneType]\n                       pressure=None,  # typing.Union[float, NoneType]\n                       particle_group=0,  # typing.Union[int, NoneType]\n                       self_collision=True,  # typing.Union[bool, NoneType]\n                       self_collision_filter=True,  # typing.Union[bool, NoneType]\n                       stretch_stiffness=None,  # typing.Union[float, NoneType]\n                       bend_stiffness=None,  # typing.Union[float, NoneType]\n                       shear_stiffness=None,  # typing.Union[float, NoneType]\n                       spring_damping=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "get_cloth_bend_stiffness",
                "description": "  \n  Reports a single value that would be used to generate the stiffnesses. This API does not report the actually created stiffnesses.\n  Returns:\n  float: The bend stiffness.\n  ",
                "snippet": "cloth_bend_stiffness = cloth_prim.get_cloth_bend_stiffness()\n"
                },
                {
                "title": "get_cloth_damping",
                "description": " \n  Reports a single value that would be used to generate the dampings. This API does not report the actually created dampings.\n  Returns:\n  float: The spring damping.\n  ",
                "snippet": "cloth_damping = cloth_prim.get_cloth_damping()\n"
                },
                {
                "title": "get_cloth_shear_stiffness",
                "description": "  \n  Reports a single value that would be used to generate the stiffnesses. This API does not report the actually created stiffnesses.\n  Returns:\n  float: The shear stiffness.\n  ",
                "snippet": "cloth_shear_stiffness = cloth_prim.get_cloth_shear_stiffness()\n"
                },
                {
                "title": "get_cloth_stretch_stiffness",
                "description": "  \n  Reports a single value that would be used to generate the stiffnesses. This API does not report the actually created stiffnesses.\n  Returns:\n  float: The stretch stiffness.\n  ",
                "snippet": "cloth_stretch_stiffness = cloth_prim.get_cloth_stretch_stiffness()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": "Return the DynamicState that contains the position and orientation of the cloth prim\n\n  Returns:\n  DynamicState:\n  position (np.ndarray, optional): \n  position in the world frame of the prim. shape is (3, ). \n  Defaults to None, which means left unchanged.\n  orientation (np.ndarray, optional): \n  quaternion orientation in the world frame of the prim.\n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "current_dynamic_state = cloth_prim.get_current_dynamic_state()\n"
                },
                {
                "title": "get_particle_group",
                "description": "  Returns:\n  bool: self collision.\n  ",
                "snippet": "particle_group = cloth_prim.get_particle_group()\n"
                },
                {
                "title": "get_pressure",
                "description": "  Returns:\n  float: pressure value.\n  ",
                "snippet": "pressure = cloth_prim.get_pressure()\n"
                },
                {
                "title": "get_self_collision",
                "description": "  Returns:\n  bool: self collision.\n  ",
                "snippet": "self_collision = cloth_prim.get_self_collision()\n"
                },
                {
                "title": "get_self_collision_filter",
                "description": "  Returns:\n  bool: self collision filter.\n  ",
                "snippet": "self_collision_filter = cloth_prim.get_self_collision_filter()\n"
                },
                {
                "title": "get_spring_damping",
                "description": " \n  Gets damping values of spring constraints\n  Returns:\n  Union[np.ndarray, torch.Tensor]: The spring damping.\n  ",
                "snippet": "spring_damping = cloth_prim.get_spring_damping()\n"
                },
                {
                "title": "get_stretch_stiffness",
                "description": "  Gets stretch stiffness values of spring constraints\n  Returns:\n  float: The stretch stiffness.\n  ",
                "snippet": "stretch_stiffness = cloth_prim.get_stretch_stiffness()\n"
                },
                {
                "title": "set_cloth_bend_stiffness",
                "description": "Sets a single bend stiffness value to all springs constraints in the cloth\n  Args:\n  stiffness (float): The cloth springs bend stiffness value.\n  Range: [0 , inf), Units: force/distance = mass/second/second\n  ",
                "snippet": "cloth_prim.set_cloth_bend_stiffness(stiffness=stiffness)  # float\n"
                },
                {
                "title": "set_cloth_damping",
                "description": "Sets a single damping value to all springs constraints in the cloth\n  Args:\n  damping (float): The cloth springs damping value.\n  Range: [0 , inf), Units: force/velocity = mass/second\n  ",
                "snippet": "cloth_prim.set_cloth_damping(damping=damping)  # float\n"
                },
                {
                "title": "set_cloth_shear_stiffness",
                "description": "Sets a single shear stiffness value to all springs constraints in the cloth\n  Args:\n  stiffness (float): The cloth springs shear stiffness value.\n  Range: [0 , inf), Units: force/distance = mass/second/second\n  ",
                "snippet": "cloth_prim.set_cloth_shear_stiffness(stiffness=stiffness)  # float\n"
                },
                {
                "title": "set_cloth_stretch_stiffness",
                "description": "Sets a single stretch stiffness value to all springs constraints in the cloth\n  Args:\n  stiffness (Union[np.ndarray, torch.Tensor]): The cloth springs stretch stiffness value.\n  Range: [0 , inf), Units: force/distance = mass/second/second\n  ",
                "snippet": "cloth_prim.set_cloth_stretch_stiffness(stiffness=stiffness)  # typing.Union[numpy.ndarray, torch.Tensor]\n"
                },
                {
                "title": "set_particle_group",
                "description": "  Args:\n  particle_group(int): particle group.\n  ",
                "snippet": "cloth_prim.set_particle_group(particle_group=particle_group)  # int\n"
                },
                {
                "title": "set_pressure",
                "description": "  Args:\n  pressure(float): pressure value.\n  ",
                "snippet": "cloth_prim.set_pressure(pressure=pressure)  # float\n"
                },
                {
                "title": "set_self_collision",
                "description": "  Args:\n  self_collision(bool): self collision.\n  ",
                "snippet": "cloth_prim.set_self_collision(self_collision=self_collision)  # bool\n"
                },
                {
                "title": "set_self_collision_filter",
                "description": "  Args:\n  self_collision_filter(bool): self collision filter.\n  ",
                "snippet": "cloth_prim.set_self_collision_filter(self_collision_filter=self_collision_filter)  # bool\n"
                },
                {
                "title": "set_spring_damping",
                "description": "  Sets damping values of spring constraints in the cloth\n  Args:\n  damping (List[float]): The damping values of springs.\n  Range: [0 , inf), Units: force/distance = mass/second\n  ",
                "snippet": "cloth_prim.set_spring_damping(damping=damping)  # typing.Union[numpy.ndarray, torch.Tensor]\n"
                },
                {
                "title": "set_stretch_stiffness",
                "description": "  Sets stretch stiffness values of spring constraints in the cloth\n  It represents a stiffness for linear springs placed between particles to counteract stretching.\n\n  Args:\n  stiffness (Union[np.ndarray, torch.Tensor]): The stretch stiffnesses.\n  Range: [0 , inf), Units: force/distance = mass/second/second\n  ",
                "snippet": "cloth_prim.set_stretch_stiffness(stiffness=stiffness)  # typing.Union[numpy.ndarray, torch.Tensor]\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "cloth_prim.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                 weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = cloth_prim.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = cloth_prim.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = cloth_prim.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = cloth_prim.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = cloth_prim.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = cloth_prim.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = cloth_prim.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "cloth_prim.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "cloth_prim.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "cloth_prim.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "cloth_prim.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "cloth_prim.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "cloth_prim.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "cloth_prim.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "cloth_prim.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "cloth_prim.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "ClothPrimView",
                "snippets": [
                {
                "title": "ClothPrimView",
                "description": "The view class for cloth prims.",
                "snippet": "cloth_prim_view = ClothPrimView(prim_paths_expr=prim_paths_expr,  # str\n                                particle_systems=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                particle_materials=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                name=\"cloth_prim_view\",  # str\n                                reset_xform_properties=True,  # bool\n                                positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                visibilities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                particle_masses=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                pressures=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                particle_groups=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                self_collisions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                self_collision_filters=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                stretch_stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                bend_stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                shear_stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                spring_dampings=None)  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_cloths_bend_stiffnesses",
                "description": "Gets the value of bend stiffness set to all the springs within cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: bend stiffness tensor with shape (M, )\n  ",
                "snippet": "cloths_bend_stiffnesses = cloth_prim_view.get_cloths_bend_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_cloths_dampings",
                "description": "Gets the value of damping set for all the springs within cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: damping tensor with shape (M, )\n  ",
                "snippet": "cloths_dampings = cloth_prim_view.get_cloths_dampings(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_cloths_shear_stiffnesses",
                "description": "Gets the value of shear stiffness set to all the springs within cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: shear stiffness tensor with shape (M, )\n  ",
                "snippet": "cloths_shear_stiffnesses = cloth_prim_view.get_cloths_shear_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                        clone=True)  # bool\n"
                },
                {
                "title": "get_cloths_stretch_stiffnesses",
                "description": "Gets the value of stretch stiffness set to all the springs within cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: stretch stiffness tensor with shape (M, )\n  ",
                "snippet": "cloths_stretch_stiffnesses = cloth_prim_view.get_cloths_stretch_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                            clone=True)  # bool\n"
                },
                {
                "title": "get_particle_groups",
                "description": "Gets the particle groups of the cloths indicated by the indices.\n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: particle groups with shape (M, ).\n  ",
                "snippet": "particle_groups = cloth_prim_view.get_particle_groups(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_particle_masses",
                "description": "Gets the particle masses for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: mass tensor with shape (M, max_particles_per_cloth)\n  ",
                "snippet": "particle_masses = cloth_prim_view.get_particle_masses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_pressures",
                "description": "Gets the pressures of the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: cloths pressure with shape (M, ).\n  ",
                "snippet": "pressures = cloth_prim_view.get_pressures(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                          clone=True)  # bool\n"
                },
                {
                "title": "get_self_collision_filters",
                "description": "Gets the self collision filters for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: the self collision filters tensor with shape (M, )\n  ",
                "snippet": "self_collision_filters = cloth_prim_view.get_self_collision_filters(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                    clone=True)  # bool\n"
                },
                {
                "title": "get_self_collisions",
                "description": "Gets the self collision for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: the self collision tensor with shape (M, )\n  ",
                "snippet": "self_collisions = cloth_prim_view.get_self_collisions(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_spring_dampings",
                "description": "Gets the spring damping for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: damping tensor with shape (M, max_springs_per_cloth)\n  ",
                "snippet": "spring_dampings = cloth_prim_view.get_spring_dampings(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                      clone=True)  # bool\n"
                },
                {
                "title": "get_stretch_stiffnesses",
                "description": "Gets the spring stretch stiffness for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: stiffness tensor with shape (M, max_springs_per_cloth)\n  ",
                "snippet": "stretch_stiffnesses = cloth_prim_view.get_stretch_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                              clone=True)  # bool\n"
                },
                {
                "title": "get_velocities",
                "description": "Gets the particle velocities for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: velocity tensor with shape (M, max_particles_per_cloth, 3)\n  ",
                "snippet": "velocities = cloth_prim_view.get_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                            clone=True)  # bool\n"
                },
                {
                "title": "get_world_positions",
                "description": "Gets the particle world positions for the cloths indicated by the indices.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: position tensor with shape (M, max_particles_per_cloth, 3)\n  ",
                "snippet": "world_positions = cloth_prim_view.get_world_positions(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                      clone=True)  # bool\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates a rigid body view in physX.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "cloth_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n  ",
                "snippet": "cloth_prim_view.is_physics_handle_valid()\n"
                },
                {
                "title": "set_cloths_bend_stiffnesses",
                "description": "Sets a single value of bend stiffnesses to all the springs within cloths indicated by the indices.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): cloth spring bend stiffness values with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_cloths_bend_stiffnesses(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                            indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_cloths_dampings",
                "description": "Sets a single value of damping to all the springs within cloths indicated by the indices.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): cloth spring damping with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_cloths_dampings(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_cloths_shear_stiffnesses",
                "description": "Sets a single value of shear stiffnesses to all the springs within cloths indicated by the indices.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): cloth spring shear stiffness values with the shape  (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_cloths_shear_stiffnesses(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                             indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_cloths_stretch_stiffnesses",
                "description": "Sets a single value of stretch stiffnesses to all the springs within cloths indicated by the indices.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): cloth spring stretch stiffness values with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_cloths_stretch_stiffnesses(values=values,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                               indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_particle_groups",
                "description": "Sets the particle group of the cloths indicated by the indices.\n\n  Args:\n  particle_groups (Union[np.ndarray, torch.Tensor]): particle group with shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_particle_groups(particle_groups=particle_groups,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_particle_masses",
                "description": "Sets the particle masses for the cloths indicated by the indices.\n\n  Args:\n  masses (Union[np.ndarray, torch.Tensor]): cloth particle masses with the shape \n  (M, max_particles_per_cloth, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_particle_masses(masses=masses,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_pressures",
                "description": "Sets the pressures of the cloths indicated by the indices.\n\n  Args:\n  pressures (Union[np.ndarray, torch.Tensor]): cloths pressure with shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_pressures(pressures=pressures,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                              indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_self_collision_filters",
                "description": "Sets the self collision filters for the cloths indicated by the indices.\n\n  Args:\n  self_collision_filters (Union[np.ndarray, torch.Tensor]): self collision filters with the shape (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_self_collision_filters(self_collision_filters=self_collision_filters,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                           indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_self_collisions",
                "description": "Sets the self collision flags for the cloths indicated by the indices.\n\n  Args:\n  self_collisions (Union[np.ndarray, torch.Tensor]): self collision flag with the shape  (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_self_collisions(self_collisions=self_collisions,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_spring_dampings",
                "description": "Sets the spring damping for the cloths indicated by the indices.\n\n  Args:\n  damping (Union[np.ndarray, torch.Tensor]): cloth spring damping with the shape \n  (M, max_springs_per_cloth).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_spring_dampings(damping=damping,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_stretch_stiffnesses",
                "description": "Sets the spring stretch stiffness values for springs within the cloths indicated by the indices.\n\n  Args:\n  stiffness (Union[np.ndarray, torch.Tensor]): cloth spring stiffness with the shape  (M, max_springs_per_cloth).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_stretch_stiffnesses(stiffness=stiffness,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                        indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_velocities",
                "description": "Sets the particle velocities for the cloths indicated by the indices.\n\n  Args:\n  velocities (Union[np.ndarray, torch.Tensor]): particle velocities with the shape \n  (M, max_particles_per_cloth, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_velocities(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                               indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_positions",
                "description": "Sets the particle world positions for the cloths indicated by the indices.\n\n  Args:\n  positions (Union[np.ndarray, torch.Tensor]): particle positions with the shape \n  (M, max_particles_per_cloth, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indices to specify which cloth prims to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_world_positions(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_visual_materials",
                "description": "Used to apply visual material to the prims and optionally its prim descendants.\n\n  Args:\n  visual_materials (Union[VisualMaterial, List[VisualMaterial]]): visual materials to be applied to the prims. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass. If a list is provided then\n  its size has to be equal the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional):  True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of visual materials != length of prims indexed\n  Exception: length of visual materials != length of weaker descendants bools arg\n  ",
                "snippet": "cloth_prim_view.apply_visual_materials(visual_materials=visual_materials,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, typing.List[omni.isaac.core.materials.visual_material.VisualMaterial]]\n                                       weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                       indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_visual_materials",
                "description": "\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[VisualMaterial]: a list of the current applied visual materials to the prims if its type is currently supported.\n  ",
                "snippet": "applied_visual_materials = cloth_prim_view.get_applied_visual_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimViewState: returns the default state of the prims (positions and orientations) that is used after each reset.\n  ",
                "snippet": "default_state = cloth_prim_view.get_default_state()\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local's frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is translations in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = cloth_prim_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_local_scales",
                "description": "Gets prim scales in the view with respect to the local frame (the parent's frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n  ",
                "snippet": "local_scales = cloth_prim_view.get_local_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_visibilities",
                "description": "Returns the current visibilities of the prims in stage.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Shape (M,) with type bool, where each item holds True \n   if the prim is visible in stage. False otherwise.\n  ",
                "snippet": "visibilities = cloth_prim_view.get_visibilities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_poses",
                "description": " Returns the poses (positions and orientations) of the prims in the view with respect to the world frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = cloth_prim_view.get_world_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_scales",
                "description": "Gets prim scales in the view with respect to the world's frame.\n\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n  ",
                "snippet": "world_scales = cloth_prim_view.get_world_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "cloth_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "cloth_prim_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[bool]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n  ",
                "snippet": "cloth_prim_view.is_visual_material_applied(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state (positions and orientations).\n  ",
                "snippet": "cloth_prim_view.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prims (positions and orientations), that will be used after each reset.\n\n  Args:\n  positions (Optional[np.ndarray], optional):  positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[np.ndarray], optional): quaternion orientations in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_scales",
                "description": "Sets prim scales in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scales (Optional[Union[np.ndarray, torch.Tensor]]): scales to be applied to the prim's dimensions in the view. \n  shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_local_scales(scales=scales,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_visibilities",
                "description": "Sets the visibilities of the prims in stage.\n\n  Args:\n  visibilities (Union[np.ndarray, torch.Tensor]): flag to set the visibilities of the usd prims in stage. \n  Shape (M,). Where M <= size of the encapsulated prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_visibilities(visibilities=visibilities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets prim poses in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prims. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "cloth_prim_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                },
                {
                "title": "GeometryPrim",
                "snippets": [
                {
                "title": "GeometryPrim",
                "description": "Provides high level functions to deal with a Geom prim and its attributes/ properties.\n The prim_path should correspond to type UsdGeom.Cube, UsdGeom.Capsule, UsdGeom.Cone, UsdGeom.Cylinder,\n UsdGeom.Sphere or UsdGeom.Mesh.\n\n Args:\n prim_path (str): prim path of the Prim to encapsulate or create.\n name (str, optional): shortname to be used as a key by Scene class.\n Note: needs to be unique if the object is added to the Scene.\n Defaults to \"xform_prim\".\n position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n Defaults to None, which means left unchanged.\n translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n (with respect to its parent prim). shape is (3, ).\n Defaults to None, which means left unchanged.\n orientation (Optional[Sequence[float]], optional): quaternion orientation in the world/ local frame of the prim\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (4, ).\n Defaults to None, which means left unchanged.\n scale (Optional[Sequence[float]], optional): local scale to be applied to the prim's dimensions. shape is (3, ).\n Defaults to None, which means left unchanged.\n visible (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n collision (bool, optional): Set to True if the geometry should have a collider (i.e not only a visual geometry).\n Defaults to False.\n track_contact_forces (bool, Optional) : if enabled, the view will track the net contact forces on each geometry prim in the view. \n Note that the collision flag should be set to True to report contact forces. Defaults to False.\n prepare_contact_sensors (bool, Optional): applies contact reporter API to the prim if it already does not have one. Defaults to False.\n disable_stablization (bool, optional): disables the contact stablization parameter in the physics context. Defaults to True.\n contact_filter_prim_paths_expr (Optional[List[str]], Optional): a list of filter expressions which allows for tracking contact forces \n between the geometry prim and this subset through get_contact_force_matrix(). \n ",
                "snippet": "geometry_prim = GeometryPrim(prim_path=prim_path,  # str\n                             name=\"geometry_prim\",  # str\n                             position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             visible=None,  # typing.Union[bool, NoneType]\n                             collision=False,  # bool\n                             track_contact_forces=False,  # bool\n                             prepare_contact_sensor=False,  # bool\n                             disable_stablization=True,  # bool\n                             contact_filter_prim_paths_expr=[])  # typing.Union[typing.List[str], NoneType]\n"
                },
                {
                "title": "apply_physics_material",
                "description": "Used to apply physics material to the held prim and optionally its descendants.\n\n  Args:\n  physics_material (PhysicsMaterial): physics material to be applied to the held prim. This where you want to\n  define friction, restitution..etc. Note: if a physics material is not\n  defined, the defaults will be used from PhysX.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants\n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "geometry_prim.apply_physics_material(physics_material=physics_material,  # omni.isaac.core.materials.physics_material.PhysicsMaterial\n                                     weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_physics_material",
                "description": "Returns the current applied physics material in case it was applied using apply_physics_material or not.\n\n  Returns:\n  PhysicsMaterial: the current applied physics material.\n  ",
                "snippet": "applied_physics_material = geometry_prim.get_applied_physics_material()\n"
                },
                {
                "title": "get_collision_approximation",
                "description": "  Returns:\n  str: approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "collision_approximation = geometry_prim.get_collision_approximation()\n"
                },
                {
                "title": "get_collision_enabled",
                "description": "  Returns:\n  ",
                "snippet": "collision_enabled = geometry_prim.get_collision_enabled()\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (self._geometry_prim_view._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = geometry_prim.get_contact_force_matrix(dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: contact offset of the collision shape.\n  ",
                "snippet": "contact_offset = geometry_prim.get_contact_offset()\n"
                },
                {
                "title": "get_min_torsional_patch_radius",
                "description": "  Returns:\n  float: minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "min_torsional_patch_radius = geometry_prim.get_min_torsional_patch_radius()\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (1, 3)\n\n  Args:\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (3).\n\n  ",
                "snippet": "net_contact_forces = geometry_prim.get_net_contact_forces(dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: rest offset of the collision shape.\n  ",
                "snippet": "rest_offset = geometry_prim.get_rest_offset()\n"
                },
                {
                "title": "get_torsional_patch_radius",
                "description": "  Returns:\n  float: radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "torsional_patch_radius = geometry_prim.get_torsional_patch_radius()\n"
                },
                {
                "title": "set_collision_approximation",
                "description": "\n  Args:\n  approximation_type (str): approximation used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\"\n  ",
                "snippet": "geometry_prim.set_collision_approximation(approximation_type=approximation_type)  # str\n"
                },
                {
                "title": "set_collision_enabled",
                "description": "\n  Args:\n  ",
                "snippet": "geometry_prim.set_collision_enabled(enabled=enabled)  # bool\n"
                },
                {
                "title": "set_contact_offset",
                "description": "  Args:\n  offset (float): Contact offset of a collision shape. Allowed range [maximum(0, rest_offset), 0].\n  Default value is -inf, means default is picked by simulation based on the shape extent.\n  ",
                "snippet": "geometry_prim.set_contact_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_min_torsional_patch_radius",
                "description": "  Args:\n  radius (float): minimum radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "geometry_prim.set_min_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "set_rest_offset",
                "description": "  Args:\n  offset (float): Rest offset of a collision shape. Allowed range [-max_float, contact_offset.\n  Default value is -inf, means default is picked by simulatiion. For rigid bodies its zero.\n  ",
                "snippet": "geometry_prim.set_rest_offset(offset=offset)  # float\n"
                },
                {
                "title": "set_torsional_patch_radius",
                "description": "  Args:\n  radius (float): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float].\n  ",
                "snippet": "geometry_prim.set_torsional_patch_radius(radius=radius)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "geometry_prim.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                    weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = geometry_prim.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = geometry_prim.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = geometry_prim.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = geometry_prim.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = geometry_prim.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = geometry_prim.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = geometry_prim.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "geometry_prim.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "geometry_prim.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "geometry_prim.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "geometry_prim.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "geometry_prim.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "geometry_prim.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "geometry_prim.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "geometry_prim.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "geometry_prim.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "GeometryPrimView",
                "snippets": [
                {
                "title": "GeometryPrimView",
                "description": " Provides high level functions to deal with geom prims (1 or more prims) \n as well as its attributes/ properties.\n This object wraps all matching geom prims found at the regex provided at the prim_paths_expr.\n\n Note: - each prim will have \"xformOp:orient\", \"xformOp:translate\" and \"xformOp:scale\" only post init,\n unless it is a non-root articulation link.\n\n Args:\n prim_paths_expr (str): prim paths regex to encapsulate all prims that match it.\n example: \"/World/Env[1-5]/Microwave\" will match /World/Env1/Microwave, \n /World/Env2/Microwave..etc.\n (a non regex prim path can also be used to encapsulate one XForm).\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene.\n Defaults to \"geometry_prim_view\".\n positions (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default positions in the world frame of the prim. \n shape is (N, 3).\n Defaults to None, which means left unchanged.\n translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default translations in the local frame of the prims\n (with respect to its parent prims). shape is (N, 3).\n Defaults to None, which means left unchanged.\n orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default quaternion orientations in the world/ local frame of the prim\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (N, 4).\n Defaults to None, which means left unchanged.\n scales (Optional[Union[np.ndarray, torch.Tensor]], optional): local scales to be applied to \n the prim's dimensions. shape is (N, 3).\n Defaults to None, which means left unchanged.\n visibilities (Optional[Union[np.ndarray, torch.Tensor]], optional): set to false for an invisible prim in \n the stage while rendering. shape is (N,). \n Defaults to None.\n reset_xform_properties (bool, optional): True if the prims don't have the right set of xform properties \n (i.e: translate, orient and scale) ONLY and in that order.\n Set this parameter to False if the object were cloned using using \n the cloner api in omni.isaac.cloner. Defaults to True.\n collisions (Optional[Union[np.ndarray, torch.Tensor]], optional): Set to True if the geometry already have/\n should have a collider (i.e not only a visual geometry). shape is (N,).\n Defaults to None.\n track_contact_forces (bool, Optional) : if enabled, the view will track the net contact forces on each geometry prim \n in the view. Note that the collision flag should be set to True to report \n contact forces. Defaults to False.\n prepare_contact_sensors (bool, Optional): applies contact reporter API to the prim if it already does not have one. \n Defaults to False.\n disable_stablization (bool, optional): disables the contact stablization parameter in the physics context.\n Defaults to True.\n contact_filter_prim_paths_expr (Optional[List[str]], Optional): a list of filter expressions which allows for tracking \n contact forces between the geometry prim and this subset \n through get_contact_force_matrix(). \n ",
                "snippet": "geometry_prim_view = GeometryPrimView(prim_paths_expr=prim_paths_expr,  # str\n                                      name=\"geometry_prim_view\",  # str\n                                      positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      visibilities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      reset_xform_properties=True,  # bool\n                                      collisions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      track_contact_forces=False,  # bool\n                                      prepare_contact_sensors=False,  # bool\n                                      disable_stablization=True,  # bool\n                                      contact_filter_prim_paths_expr=[])  # typing.Union[typing.List[str], NoneType]\n"
                },
                {
                "title": "apply_collision_apis",
                "description": "retrieves the collision apis applied to prims already \n  or applies collision apis to prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.apply_collision_apis(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_physics_materials",
                "description": "Used to apply physics material to prims in the view and optionally its descendants.\n\n  Args:\n  physics_materials (Union[PhysicsMaterial, List[PhysicsMaterial]]): physics materials to be applied to prims in the view.\n  Physics material can be used to define friction, restitution..etc.\n  Note: if a physics material is not defined, the defaults will be used\n  from PhysX. If a list is provided then its size has to be equal\n  the view's size or indices size.\n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of physics materials != length of prims indexed\n  Exception: length of physics materials != length of weaker descendants arg\n  ",
                "snippet": "geometry_prim_view.apply_physics_materials(physics_materials=physics_materials,  # typing.Union[omni.isaac.core.materials.physics_material.PhysicsMaterial, typing.List[omni.isaac.core.materials.physics_material.PhysicsMaterial]]\n                                           weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                           indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "disable_collision",
                "description": "Disables collision on prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.disable_collision(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "enable_collision",
                "description": "Enables collision on prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.enable_collision(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_physics_materials",
                "description": "Gets the applied physics material to prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[PhysicsMaterial]: the current applied physics materials for prims in the view.\n  ",
                "snippet": "applied_physics_materials = geometry_prim_view.get_applied_physics_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_collision_approximations",
                "description": "Gets collision approximation types for prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[str]: approximations used for collision, could be \"none\", \"convexHull\" or \"convexDecomposition\". size == M or size of the view.\n\n  ",
                "snippet": "collision_approximations = geometry_prim_view.get_collision_approximations(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self.count, self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (M, self._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = geometry_prim_view.get_contact_force_matrix(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                   clone=True,  # bool\n                                                                   dt=1.0)  # float\n"
                },
                {
                "title": "get_contact_offsets",
                "description": "Gets contact offsets for prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Contact offsets of the collision shapes. Shape is (M,).\n  ",
                "snippet": "contact_offsets = geometry_prim_view.get_contact_offsets(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_min_torsional_patch_radii",
                "description": "Gets minimum torsional patch radii for prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: minimum radius of the contact patch used to apply torsional friction. shape is (M,).\n  ",
                "snippet": "min_torsional_patch_radii = geometry_prim_view.get_min_torsional_patch_radii(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (self.count, 3)\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (M,3).\n\n  ",
                "snippet": "net_contact_forces = geometry_prim_view.get_net_contact_forces(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                               clone=True,  # bool\n                                                               dt=1.0)  # float\n"
                },
                {
                "title": "get_rest_offsets",
                "description": "Gets rest offsets for prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Rest offsets of the collision shapes. Shape is (M,).\n  ",
                "snippet": "rest_offsets = geometry_prim_view.get_rest_offsets(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_torsional_patch_radii",
                "description": "Gets torsional patch radii for prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: radius of the contact patch used to apply torsional friction. shape is (M,).\n  ",
                "snippet": "torsional_patch_radii = geometry_prim_view.get_torsional_patch_radii(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "geometry_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_collision_enabled",
                "description": "Queries if collision is enabled on prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: True if collision is enabled. Shape is (M,).\n  ",
                "snippet": "geometry_prim_view.is_collision_enabled(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_collision_approximations",
                "description": "Sets collision approximation types for prims in the view.\n\n  Args:\n  approximation_types (List[str]): approximations used for collision, \n  could be \"none\", \"convexHull\" or \"convexDecomposition\". \n  List size == M or the size of the view.\n\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_collision_approximations(approximation_types=approximation_types,  # typing.List[str]\n                                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_contact_offsets",
                "description": " Sets contact offsets for prims in the view.\n\n  Args:\n  offsets (Union[np.ndarray, torch.Tensor]): Contact offsets of the collision shapes. Allowed range [maximum(0, rest_offset), 0]. \n   Default value is -inf, means default is picked by simulation based on the shape extent.\n   Shape (M,).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_contact_offsets(offsets=offsets,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_min_torsional_patch_radii",
                "description": "Sets minimum torsional patch radii for prims in the view.\n\n  Args:\n  radii (Union[np.ndarray, torch.Tensor]): minimum radius of the contact patch used to apply torsional friction. \n   Allowed range [0, max_float]. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_min_torsional_patch_radii(radii=radii,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_rest_offsets",
                "description": "Sets rest offsets for prims in the view.\n\n  Args:\n  offsets (Union[np.ndarray, torch.Tensor]): Rest offset of a collision shape. Allowed range [-max_float, contact_offset. \n  Default value is -inf, means default is picked by simulatiion. \n  For rigid bodies its zero. Shape (M,).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_rest_offsets(offsets=offsets,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_torsional_patch_radii",
                "description": "Sets torsional patch radii for prims in the view.\n\n  Args:\n  radii (Union[np.ndarray, torch.Tensor]): radius of the contact patch used to apply torsional friction. Allowed range [0, max_float]. \n   shape is (M,).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_torsional_patch_radii(radii=radii,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                             indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_visual_materials",
                "description": "Used to apply visual material to the prims and optionally its prim descendants.\n\n  Args:\n  visual_materials (Union[VisualMaterial, List[VisualMaterial]]): visual materials to be applied to the prims. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass. If a list is provided then\n  its size has to be equal the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional):  True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of visual materials != length of prims indexed\n  Exception: length of visual materials != length of weaker descendants bools arg\n  ",
                "snippet": "geometry_prim_view.apply_visual_materials(visual_materials=visual_materials,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, typing.List[omni.isaac.core.materials.visual_material.VisualMaterial]]\n                                          weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                          indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_visual_materials",
                "description": "\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[VisualMaterial]: a list of the current applied visual materials to the prims if its type is currently supported.\n  ",
                "snippet": "applied_visual_materials = geometry_prim_view.get_applied_visual_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimViewState: returns the default state of the prims (positions and orientations) that is used after each reset.\n  ",
                "snippet": "default_state = geometry_prim_view.get_default_state()\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local's frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is translations in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = geometry_prim_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_local_scales",
                "description": "Gets prim scales in the view with respect to the local frame (the parent's frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n  ",
                "snippet": "local_scales = geometry_prim_view.get_local_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_visibilities",
                "description": "Returns the current visibilities of the prims in stage.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Shape (M,) with type bool, where each item holds True \n   if the prim is visible in stage. False otherwise.\n  ",
                "snippet": "visibilities = geometry_prim_view.get_visibilities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_poses",
                "description": " Returns the poses (positions and orientations) of the prims in the view with respect to the world frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = geometry_prim_view.get_world_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_scales",
                "description": "Gets prim scales in the view with respect to the world's frame.\n\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n  ",
                "snippet": "world_scales = geometry_prim_view.get_world_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "geometry_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "geometry_prim_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[bool]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n  ",
                "snippet": "geometry_prim_view.is_visual_material_applied(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state (positions and orientations).\n  ",
                "snippet": "geometry_prim_view.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prims (positions and orientations), that will be used after each reset.\n\n  Args:\n  positions (Optional[np.ndarray], optional):  positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[np.ndarray], optional): quaternion orientations in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                     orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                                     indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                   orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                   indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_scales",
                "description": "Sets prim scales in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scales (Optional[Union[np.ndarray, torch.Tensor]]): scales to be applied to the prim's dimensions in the view. \n  shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_local_scales(scales=scales,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_visibilities",
                "description": "Sets the visibilities of the prims in stage.\n\n  Args:\n  visibilities (Union[np.ndarray, torch.Tensor]): flag to set the visibilities of the usd prims in stage. \n  Shape (M,). Where M <= size of the encapsulated prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_visibilities(visibilities=visibilities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                    indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets prim poses in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prims. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "geometry_prim_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                   orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                   indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                },
                {
                "title": "ParticleSystem",
                "snippets": [
                {
                "title": "ParticleSystem",
                "description": "A wrapper around PhysX particle system.\n\nPhysX uses GPU-accelerated position-based-dynamics (PBD) particle simulation [1]. The particle system\ncan be used to simulate fluids, cloth and inflatables [2].\n\nThe wrapper is useful for creating and setting solver parameters common to the particle objects\nassociated with the system. The particle system's solver parameters cannot be changed once the scene\nis playing.\n\nNote:\n CPU simulation of particles is not supported. PhysX must be simulated with GPU enabled.\n\nReference:\n [1] https://mmacklin.com/pbf_sig_preprint.pdf\n [2] https://docs.omniverse.nvidia.com/prod_extensions/prod_extensions/ext_physics.html#particle-simulation",
                "snippet": "particle_system = ParticleSystem(prim_path=prim_path,  # str\n                                 name=\"particle_system\",  # typing.Union[str, NoneType]\n                                 particle_system_enabled=None,  # typing.Union[bool, NoneType]\n                                 simulation_owner=None,  # typing.Union[str, NoneType]\n                                 contact_offset=None,  # typing.Union[float, NoneType]\n                                 rest_offset=None,  # typing.Union[float, NoneType]\n                                 particle_contact_offset=None,  # typing.Union[float, NoneType]\n                                 solid_rest_offset=None,  # typing.Union[float, NoneType]\n                                 fluid_rest_offset=None,  # typing.Union[float, NoneType]\n                                 enable_ccd=None,  # typing.Union[bool, NoneType]\n                                 solver_position_iteration_count=None,  # typing.Union[float, NoneType]\n                                 max_depenetration_velocity=None,  # typing.Union[float, NoneType]\n                                 wind=None,  # typing.Sequence[float]\n                                 max_neighborhood=None,  # typing.Union[int, NoneType]\n                                 max_velocity=None,  # typing.Union[float, NoneType]\n                                 global_self_collision_enabled=None,  # typing.Union[bool, NoneType]\n                                 non_particle_collision_enabled=None)  # typing.Union[bool, NoneType]\n"
                },
                {
                "title": "apply_particle_anisotropy",
                "description": "Applies anisotropy to the particle system.\n\n  This is used to compute anisotropic scaling of particles in a post-processing step.\n  It only affects the rendering output including iso-surface generation.\n  ",
                "snippet": "particle_system.apply_particle_anisotropy()\n"
                },
                {
                "title": "apply_particle_isotropy",
                "description": "Applies iso-surface extraction to the particle system.\n\n  This is used to define settings to extract an iso-surface from the particles\n  in a post-processing step. It only affects the rendering output including iso-surface generation.\n  ",
                "snippet": "particle_system.apply_particle_isotropy()\n"
                },
                {
                "title": "apply_particle_material",
                "description": "",
                "snippet": "particle_system.apply_particle_material(particle_materials=particle_materials)  # omni.isaac.core.materials.particle_material.ParticleMaterial\n"
                },
                {
                "title": "apply_particle_smoothing",
                "description": "Applies smoothing to the simulated particle system.\n\n  This is used to control smoothing of particles in a post-processing step.\n  It only affects the rendering output including iso-surface generation.\n  ",
                "snippet": "particle_system.apply_particle_smoothing()\n"
                },
                {
                "title": "get_applied_particle_material",
                "description": "",
                "snippet": "applied_particle_material = particle_system.get_applied_particle_material()\n"
                },
                {
                "title": "get_contact_offset",
                "description": "  Returns:\n  float: The contact offset  used for collisions with non-particle objects.\n  ",
                "snippet": "contact_offset = particle_system.get_contact_offset()\n"
                },
                {
                "title": "get_enable_ccd",
                "description": "  Returns:\n  bool: Whether continuous collision detection for particles is enabled or disabled.\n  ",
                "snippet": "enable_ccd = particle_system.get_enable_ccd()\n"
                },
                {
                "title": "get_fluid_rest_offset",
                "description": "  Returns:\n  float: The rest offset used for fluid-fluid particle interactions.\n  ",
                "snippet": "fluid_rest_offset = particle_system.get_fluid_rest_offset()\n"
                },
                {
                "title": "get_global_self_collision_enabled",
                "description": "  Returns:\n  bool: Whether self collisions to follow particle-object-specific settings\n  is enabled or disabled.\n  ",
                "snippet": "global_self_collision_enabled = particle_system.get_global_self_collision_enabled()\n"
                },
                {
                "title": "get_max_depenetration_velocity",
                "description": "  Returns:\n  float: The maximum velocity permitted between intersecting particles.\n  ",
                "snippet": "max_depenetration_velocity = particle_system.get_max_depenetration_velocity()\n"
                },
                {
                "title": "get_max_neighborhood",
                "description": "  Returns:\n  int: The particle neighborhood size.\n  ",
                "snippet": "max_neighborhood = particle_system.get_max_neighborhood()\n"
                },
                {
                "title": "get_max_velocity",
                "description": "  Returns:\n  float: The maximum particle velocity.\n  ",
                "snippet": "max_velocity = particle_system.get_max_velocity()\n"
                },
                {
                "title": "get_particle_contact_offset",
                "description": "  Returns:\n  float: The contact offset used for interactions between particles.\n  ",
                "snippet": "particle_contact_offset = particle_system.get_particle_contact_offset()\n"
                },
                {
                "title": "get_particle_system_enabled",
                "description": "  Returns:\n  bool: Whether particle system is enabled or not.\n  ",
                "snippet": "particle_system_enabled = particle_system.get_particle_system_enabled()\n"
                },
                {
                "title": "get_rest_offset",
                "description": "  Returns:\n  float: The rest offset used for collisions with non-particle objects.\n  ",
                "snippet": "rest_offset = particle_system.get_rest_offset()\n"
                },
                {
                "title": "get_simulation_owner",
                "description": "  Returns:\n  Usd.Prim: The physics scene prim attached to particle system.\n  ",
                "snippet": "simulation_owner = particle_system.get_simulation_owner()\n"
                },
                {
                "title": "get_solid_rest_offset",
                "description": "  Returns:\n  float: The rest offset used for solid-solid or solid-fluid particle interactions.\n  ",
                "snippet": "solid_rest_offset = particle_system.get_solid_rest_offset()\n"
                },
                {
                "title": "get_solver_position_iteration_count",
                "description": "  Returns:\n  int: The number of solver iterations for positions.\n  ",
                "snippet": "solver_position_iteration_count = particle_system.get_solver_position_iteration_count()\n"
                },
                {
                "title": "get_wind",
                "description": "  Returns:\n  Sequence[float]: The wind applied to the current particle system.\n  ",
                "snippet": "wind = particle_system.get_wind()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "particle_system.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "particle_system.is_valid()\n"
                },
                {
                "title": "post_reset",
                "description": "",
                "snippet": "particle_system.post_reset()\n"
                },
                {
                "title": "set_contact_offset",
                "description": "Set the contact offset used for collisions with non-particle objects such as rigid or deformable bodies.\n\n  Args:\n  value (float): The contact offset.\n  ",
                "snippet": "particle_system.set_contact_offset(value=value)  # float\n"
                },
                {
                "title": "set_enable_ccd",
                "description": "Enable continuous collision detection for particles.\n\n  Args:\n  value (bool): Whether to enable or disable.\n  ",
                "snippet": "particle_system.set_enable_ccd(value=value)  # bool\n"
                },
                {
                "title": "set_fluid_rest_offset",
                "description": "Set the rest offset used for fluid-fluid particle interactions.\n\n  Note: Must be smaller than particle contact offset.\n\n  Args:\n  value (float): The rest offset.\n  ",
                "snippet": "particle_system.set_fluid_rest_offset(value=value)  # float\n"
                },
                {
                "title": "set_global_self_collision_enabled",
                "description": "Enable self collisions to follow particle-object-specific settings.\n\n  If True, self collisions follow particle-object-specific settings. If False,\n  all particle self collisions are disabled, regardless of any other settings.\n\n  Note: Improves performance if self collisions are not needed.\n\n  Args:\n  value (bool): Whether to enable or disable.\n  ",
                "snippet": "particle_system.set_global_self_collision_enabled(value=value)  # bool\n"
                },
                {
                "title": "set_max_depenetration_velocity",
                "description": "Set the maximum velocity permitted to be introduced by the solver to\n  depenetrate intersecting particles.\n\n  Args:\n  value (float): The maximum depenetration velocity.\n  ",
                "snippet": "particle_system.set_max_depenetration_velocity(value=value)  # float\n"
                },
                {
                "title": "set_max_neighborhood",
                "description": "Set the particle neighborhood size.\n\n  Args:\n  value (int): The neighborhood size.\n  ",
                "snippet": "particle_system.set_max_neighborhood(value=value)  # int\n"
                },
                {
                "title": "set_max_velocity",
                "description": "Set the maximum particle velocity.\n\n  Args:\n  value (float): The maximum velocity.\n  ",
                "snippet": "particle_system.set_max_velocity(value=value)  # float\n"
                },
                {
                "title": "set_particle_contact_offset",
                "description": "Set the contact offset used for interactions between particles.\n\n  Note: Must be larger than solid and fluid rest offsets.\n\n  Args:\n  value (float): The contact offset.\n  ",
                "snippet": "particle_system.set_particle_contact_offset(value=value)  # float\n"
                },
                {
                "title": "set_particle_system_enabled",
                "description": "Set enabling of the particle system.\n\n  Args:\n  value (bool): Whether to enable or disable.\n  ",
                "snippet": "particle_system.set_particle_system_enabled(value=value)  # bool\n"
                },
                {
                "title": "set_rest_offset",
                "description": "Set the rest offset used for collisions with non-particle objects such as rigid or deformable bodies.\n\n  Args:\n  value (float): The rest offset.\n  ",
                "snippet": "particle_system.set_rest_offset(value=value)  # float\n"
                },
                {
                "title": "set_simulation_owner",
                "description": "Set the PhysicsScene that simulates this particle system.\n\n  Args:\n  value (str): The prim path to the physics scene.\n  ",
                "snippet": "particle_system.set_simulation_owner(value=value)  # str\n"
                },
                {
                "title": "set_solid_rest_offset",
                "description": "Set the rest offset used for solid-solid or solid-fluid particle interactions.\n\n  Note: Must be smaller than particle contact offset.\n\n  Args:\n  value (float): The rest offset.\n  ",
                "snippet": "particle_system.set_solid_rest_offset(value=value)  # float\n"
                },
                {
                "title": "set_solver_position_iteration_count",
                "description": "Set the number of solver iterations for position.\n\n  Args:\n  value (int): Number of solver iterations.\n  ",
                "snippet": "particle_system.set_solver_position_iteration_count(value=value)  # int\n"
                },
                {
                "title": "set_wind",
                "description": "Set the wind velocity applied to the current particle system.\n\n  Args:\n  value (Sequence[float]): The wind applied to the current particle system.\n  ",
                "snippet": "particle_system.set_wind(value=value)  # typing.Sequence[float]\n"
                }
                ]
                },
                {
                "title": "ParticleSystemView",
                "snippets": [
                {
                "title": "ParticleSystemView",
                "description": "Provides high level functions to deal with particle systems (1 or more particle systems) as well as its attributes/ properties.\nThis object wraps all matching particle systems found at the regex provided at the prim_paths_expr.\nNote: not all the attributes of the PhysxSchema.PhysxParticleSystem is currently controlled with this view class\nTensor API support will be added in the future to extend the functionality of this class to applications beyond cloth.",
                "snippet": "particle_system_view = ParticleSystemView(prim_paths_expr=prim_paths_expr,  # str\n                                          name=\"particle_system_view\",  # str\n                                          particle_systems_enabled=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          simulation_owners=None,  # typing.Union[typing.Sequence[str], NoneType]\n                                          contact_offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          rest_offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          particle_contact_offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          solid_rest_offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          fluid_rest_offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          enable_ccds=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          solver_position_iteration_counts=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          max_depenetration_velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          winds=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          max_neighborhoods=None,  # typing.Union[int, NoneType]\n                                          max_velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                          global_self_collisions_enabled=None)  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_particle_materials",
                "description": "Used to apply particle material to prims in the view.\n\n  Args:\n  particle_materials (Union[ParticleMaterial, List[ParticleMaterial]]): particle materials to be applied to prims in the view. \n  Note: if a physics material is not defined, \n  the defaults will be used from PhysX.\n  If a list is provided then its size has to be equal \n  the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  Raises:\n  Exception: length of physics materials != length of prims indexed\n  ",
                "snippet": "particle_system_view.apply_particle_materials(particle_materials=particle_materials,  # typing.Union[omni.isaac.core.materials.particle_material.ParticleMaterial, typing.List[omni.isaac.core.materials.particle_material.ParticleMaterial]]\n                                              indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_particle_materials",
                "description": "Gets the applied particle material to prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[ParticleMaterial]: the current applied particle materials for prims in the view.\n  ",
                "snippet": "applied_particle_materials = particle_system_view.get_applied_particle_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_contact_offsets",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The contact offset  used for collisions with non-particle objects for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "contact_offsets = particle_system_view.get_contact_offsets(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_enable_ccds",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]:  Whether continuous collision detection for particles is enabled or disabled for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "enable_ccds = particle_system_view.get_enable_ccds(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_fluid_rest_offsets",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The rest offset used for fluid-fluid particle interactions. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  ",
                "snippet": "fluid_rest_offsets = particle_system_view.get_fluid_rest_offsets(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_global_self_collisions_enabled",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]:  Whether self collisions to follow particle-object-specific settings \n  is enabled or disabled. for each particle system. shape is (M, ).  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "global_self_collisions_enabled = particle_system_view.get_global_self_collisions_enabled(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_max_depenetration_velocities",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The maximum velocity permitted to be introduced by the solver to\n  depenetrate intersecting particles for particle systems for each particle system. shape is (M, ).\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "max_depenetration_velocities = particle_system_view.get_max_depenetration_velocities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_max_neighborhoods",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]:  The particle neighborhood size for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "max_neighborhoods = particle_system_view.get_max_neighborhoods(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_max_velocities",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The maximum particle velocities for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "max_velocities = particle_system_view.get_max_velocities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_particle_contact_offsets",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The contact offset used for interactions between particles in the view concatenated. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  ",
                "snippet": "particle_contact_offsets = particle_system_view.get_particle_contact_offsets(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                             clone=True)  # bool\n"
                },
                {
                "title": "get_particle_systems_enabled",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]:  Whether particle system is enabled or not for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "particle_systems_enabled = particle_system_view.get_particle_systems_enabled(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_rest_offsets",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The rest offset used for collisions with non-particle objects for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "rest_offsets = particle_system_view.get_rest_offsets(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_simulation_owners",
                "description": "  Returns:\n  Sequence[str]: The physics scene prim path attached to particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "simulation_owners = particle_system_view.get_simulation_owners(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_solid_rest_offsets",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The rest offset used for solid-solid or solid-fluid particle interactions. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  ",
                "snippet": "solid_rest_offsets = particle_system_view.get_solid_rest_offsets(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_solver_position_iteration_counts",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The number of solver iterations for positions for each particle system. shape is (M, ).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  ",
                "snippet": "solver_position_iteration_counts = particle_system_view.get_solver_position_iteration_counts(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_winds",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: The winds applied to the current particle system. shape is (M, 3).  \n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  ",
                "snippet": "winds = particle_system_view.get_winds(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                       clone=True)  # bool\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates a Particle System View.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "particle_system_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n  ",
                "snippet": "particle_system_view.is_physics_handle_valid()\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "particle_system_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the particles to their initial states.\n  ",
                "snippet": "particle_system_view.post_reset()\n"
                },
                {
                "title": "set_contact_offsets",
                "description": "Set the contact offset used for collisions with non-particle objects such as rigid or deformable bodies for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_contact_offsets(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                         indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_enable_ccds",
                "description": "Enable continuous collision detection for particles for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_enable_ccds(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                     indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_fluid_rest_offsets",
                "description": "Set the rest offset used for fluid-fluid particle interactions.\n\n  Note: Must be smaller than particle contact offset.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]): fluid rest offset to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_fluid_rest_offsets(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                            indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_global_self_collisions_enabled",
                "description": "Enable self collisions to follow particle-object-specific settings for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_global_self_collisions_enabled(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                        indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_max_depenetration_velocities",
                "description": "  Set the maximum velocity permitted to be introduced by the solver to depenetrate intersecting particles for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_max_depenetration_velocities(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                      indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_max_neighborhoods",
                "description": "Set the particle neighborhood size for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_max_neighborhoods(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                           indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_max_velocities",
                "description": "Set the maximum particle velocity for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_max_velocities(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                        indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_particle_contact_offsets",
                "description": "Set the contact offset used for interactions between particles.\n\n  Note: Must be larger than solid and fluid rest offsets.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]): The contact offset.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  ",
                "snippet": "particle_system_view.set_particle_contact_offsets(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                  indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_particle_systems_enabled",
                "description": "Set enabling of the particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_particle_systems_enabled(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                  indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_rest_offsets",
                "description": "Set the rest offset used for collisions with non-particle objects such as rigid or deformable bodies for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_rest_offsets(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                      indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_simulation_owners",
                "description": "Set the PhysicsScene that simulates particle systems.\n  Args:\n  values (Sequence[str]): PhysicsScene list to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_simulation_owners(values=values,  # typing.Sequence[str]\n                                           indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_solid_rest_offsets",
                "description": "Set the rest offset used for solid-solid or solid-fluid particle interactions.\n\n  Note: Must be smaller than particle contact offset.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]): solid rest offset to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  ",
                "snippet": "particle_system_view.set_solid_rest_offsets(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                            indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_solver_position_iteration_counts",
                "description": "Set the number of solver iterations for position for particle systems.\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]):  maximum particle velocity tensor to set particle systems to. shape is (M, ).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).  \n  ",
                "snippet": "particle_system_view.set_solver_position_iteration_counts(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                          indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_winds",
                "description": "Set the winds velocities applied to the current particle system.\n\n  Args:\n  values (Optional[Union[np.ndarray, torch.Tensor]]): The wind applied to the current particle system. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view). \n  ",
                "snippet": "particle_system_view.set_winds(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                               indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                }
                ]
                },
                {
                "title": "RigidContactView",
                "snippets": [
                {
                "title": "RigidContactView",
                "description": "Provides high level functions to deal with rigid prims that track their contacts through filters\n as well as its attributes/ properties.\n This object wraps all matching Rigid Prims found at the regex provided at the prim_paths_expr.\n\n Note: if the prim does not already have a rigid body api applied to it before init, it will NOT apply it.\n\n Args:\n prim_paths_expr (str): prim paths regex to encapsulate all prims that match it.\n example: \"/World/Env[1-5]/Cube\" will match /World/Env1/Cube, \n /World/Env2/Cube..etc.\n (a non regex prim path can also be used to encapsulate one rigid prim).\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene. \n Defaults to \"rigid_contact_view\".\n prepare_contact_sensors (bool, Optional): if rigid prims in the view are not cloned from a prim in a prepared state, \n (although slow for large number of prims) this ensures that \n appropriate physics settings are applied on all the prim in the view. \n disable_stablization (bool, optional): disables the contact stablization parameter in the physics context \n apply_rigid_body_api (bool, optional): apply rigid body API to prims in prim_paths_expr and filter_paths_expr when prepare_contact_sensors=True \n ",
                "snippet": "rigid_contact_view = RigidContactView(prim_paths_expr=prim_paths_expr,  # str\n                                      filter_paths_expr=filter_paths_expr,  # typing.List[str]\n                                      name=\"rigid_contact_view\",  # str\n                                      prepare_contact_sensors=True,  # bool\n                                      disable_stablization=True,  # bool\n                                      apply_rigid_body_api=True)  # bool\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "Gets the contact forces between the prims in the view and the filter prims. i.e., a matrix of dimension \n  (self.num_shapes, self.num_filters, 3) where filter_count is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  dt (float): time step multiplier to convert the underlying impulses to forces. The function returns contact impulses if the default dt is used\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (M, self.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = rigid_contact_view.get_contact_force_matrix(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                                   clone=True,  # bool\n                                                                   dt=1.0)  # float\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "Gets the overall net contact forces on the prims in the view with respect to the world's frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  dt (float): time step multiplier to convert the underlying impulses to forces. The function returns contact impulses if the default dt is used\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (M,3).\n  ",
                "snippet": "net_contact_forces = rigid_contact_view.get_net_contact_forces(indices=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                               clone=True,  # bool\n                                                               dt=1.0)  # float\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates a rigid contact view in physX.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "rigid_contact_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n  ",
                "snippet": "rigid_contact_view.is_physics_handle_valid()\n"
                }
                ]
                },
                {
                "title": "RigidPrim",
                "snippets": [
                {
                "title": "RigidPrim",
                "description": " Provides high level functions to deal with a rigid body prim and its attributes/ properties.\n If there is an prim present at the path, it will use it. Otherwise, a new XForm prim at\n the specified prim path will be created.\n Notes: if the prim does not already have a rigid body api applied to it before init, it will apply it.\n\n Args:\n prim_path (str): prim path of the Prim to encapsulate or create.\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene. \n Defaults to \"rigid_prim\".\n position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n Defaults to None, which means left unchanged.\n translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n (with respect to its parent prim). shape is (3, ).\n Defaults to None, which means left unchanged.\n orientation (Optional[Sequence[float]], optional): quaternion orientation in the world/ local frame of the prim\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (4, ).\n Defaults to None, which means left unchanged.\n scale (Optional[Sequence[float]], optional): local scale to be applied to the prim's dimensions. shape is (3, ).\n Defaults to None, which means left unchanged.\n visible (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n mass (Optional[float], optional): mass in kg. Defaults to None.\n linear_velocity (Optional[np.ndarray], optional): linear velocity in the world frame. Defaults to None.\n angular_velocity (Optional[np.ndarray], optional): angular velocity in the world frame. Defaults to None.\n\n ",
                "snippet": "rigid_prim = RigidPrim(prim_path=prim_path,  # str\n                       name=\"rigid_prim\",  # str\n                       position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       visible=None,  # typing.Union[bool, NoneType]\n                       mass=None,  # typing.Union[float, NoneType]\n                       density=None,  # typing.Union[float, NoneType]\n                       linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                       angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n  ",
                "snippet": "rigid_prim.disable_rigid_body_physics()\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": " enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n  ",
                "snippet": "rigid_prim.enable_rigid_body_physics()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "  Returns:\n  np.ndarray: current angular velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "angular_velocity = rigid_prim.get_angular_velocity()\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid body including position, orientation, linear_velocity and angular_velocity.\n  ",
                "snippet": "current_dynamic_state = rigid_prim.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  DynamicState: returns the default state of the prim (position, orientation, linear_velocity and \n  angular_velocity) that is used after each reset.\n  ",
                "snippet": "default_state = rigid_prim.get_default_state()\n"
                },
                {
                "title": "get_density",
                "description": "  Returns:\n  float: density of the rigid body.\n  ",
                "snippet": "density = rigid_prim.get_density()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "  Returns:\n  np.ndarray: current linear velocity of the the rigid prim. Shape (3,).\n  ",
                "snippet": "linear_velocity = rigid_prim.get_linear_velocity()\n"
                },
                {
                "title": "get_mass",
                "description": "  Returns:\n  float: mass of the rigid body in kg.\n  ",
                "snippet": "mass = rigid_prim.get_mass()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "  Returns:\n  float: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "sleep_threshold = rigid_prim.get_sleep_threshold()\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "Sets the angular velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "rigid_prim.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_default_state",
                "description": " Sets the default state of the prim, that will be used after each reset. \n  \n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  linear_velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  angular_velocity (np.ndarray): angular velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "rigid_prim.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             linear_velocity=None,  # typing.Union[numpy.ndarray, NoneType]\n                             angular_velocity=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_density",
                "description": "  Args:\n  mass (float): density of the rigid body.\n  ",
                "snippet": "rigid_prim.set_density(density=density)  # float\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n  Args:\n  velocity (np.ndarray): linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "rigid_prim.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_mass",
                "description": "  Args:\n  mass (float): mass of the rigid body in kg.\n  ",
                "snippet": "rigid_prim.set_mass(mass=mass)  # float\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "  Args:\n  threshold (float): Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2.\n  ",
                "snippet": "rigid_prim.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "rigid_prim.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                 weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = rigid_prim.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = rigid_prim.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = rigid_prim.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = rigid_prim.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = rigid_prim.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = rigid_prim.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = rigid_prim.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "rigid_prim.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "rigid_prim.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "rigid_prim.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "rigid_prim.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "rigid_prim.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "rigid_prim.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "rigid_prim.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "rigid_prim.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "rigid_prim.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "RigidPrimView",
                "snippets": [
                {
                "title": "RigidPrimView",
                "description": "Provides high level functions to deal with prims that has rigid body api applied to it (1 or more rigid body prims) \n as well as its attributes/ properties.\n This object wraps all matching Rigid Prims found at the regex provided at the prim_paths_expr.\n Note: \n - each prim will have \"xformOp:orient\", \"xformOp:translate\" and \"xformOp:scale\" only post init,\n unless it is a non-root articulation link.\n - if the prim does not already have a rigid body api applied to it before init, it will apply it.\n\n Args:\n prim_paths_expr (str): prim paths regex to encapsulate all prims that match it.\n example: \"/World/Env[1-5]/Cube\" will match /World/Env1/Cube, \n /World/Env2/Cube..etc.\n (a non regex prim path can also be used to encapsulate one rigid prim).\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene. \n Defaults to \"rigid_prim_view\".\n positions (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default positions in the world frame of the prims. \n shape is (N, 3).\n Defaults to None, which means left unchanged.\n translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default translations in the local frame of the prims\n (with respect to its parent prims). shape is (N, 3).\n Defaults to None, which means left unchanged.\n orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default quaternion orientations in the world/ local frame of the prims\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (N, 4).\n Defaults to None, which means left unchanged.\n scales (Optional[Union[np.ndarray, torch.Tensor]], optional): local scales to be applied to \n the prim's dimensions in the view. shape is (N, 3).\n Defaults to None, which means left unchanged.\n visibilities (Optional[Union[np.ndarray, torch.Tensor]], optional): set to false for an invisible prim in \n the stage while rendering. shape is (N,). \n Defaults to None.\n reset_xform_properties (bool, optional): True if the prims don't have the right set of xform properties \n (i.e: translate, orient and scale) ONLY and in that order.\n Set this parameter to False if the object were cloned using using \n the cloner api in omni.isaac.cloner. Defaults to True.\n masses (Optional[Union[np.ndarray, torch.Tensor]], optional): mass in kg specified for each prim in the view. \n shape is (N,). Defaults to None.\n densities (Optional[Union[np.ndarray, torch.Tensor]], optional): density in kg/m^3 specified for each prim in the view. \n shape is (N,). Defaults to None.\n linear_velocities (Optional[Union[np.ndarray, torch.Tensor]], optional): default linear velocity of each prim in the view\n (to be applied in the first frame and on resets). \n Shape is (N, 3). Defaults to None.\n angular_velocities (Optional[Union[np.ndarray, torch.Tensor]], optional): default angular velocity of each prim in the view\n (to be applied in the first frame and on resets). \n Shape is (N, 3). Defaults to None.\n track_contact_forces (bool, Optional) : if enabled, the view will track the net contact forces on each rigid prim in the view\n prepare_contact_sensors (bool, Optional): if rigid prims in the view are not cloned from a prim in a prepared state, \n (although slow for large number of prims) this ensures that \n appropriate physics settings are applied on all the prim in the view.\n disable_stablization (bool, optional): disables the contact stablization parameter in the physics context \n contact_filter_prim_paths_expr (Optional[List[str]], Optional): a list of filter expressions which allows for tracking contact forces \n between prims and this subset through get_contact_force_matrix(). \n ",
                "snippet": "rigid_prim_view = RigidPrimView(prim_paths_expr=prim_paths_expr,  # str\n                                name=\"rigid_prim_view\",  # str\n                                positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                visibilities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                reset_xform_properties=True,  # bool\n                                masses=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                densities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                linear_velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                angular_velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                track_contact_forces=False,  # bool\n                                prepare_contact_sensors=True,  # bool\n                                disable_stablization=True,  # bool\n                                contact_filter_prim_paths_expr=[])  # typing.Union[typing.List[str], NoneType]\n"
                },
                {
                "title": "apply_forces",
                "description": "Applies forces to prims in the view.\n\n  Args:\n  forces (Optional[Union[np.ndarray, torch.Tensor]]): forces to be applied to the prims.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  is_global (bool, optional): True if forces are in the global frame. Otherwise False. Defaults to True.\n\n  ",
                "snippet": "rigid_prim_view.apply_forces(forces=forces,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                             indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                             is_global=True)  # bool\n"
                },
                {
                "title": "apply_forces_and_torques_at_pos",
                "description": "Applies forces and torques to prims in the view. The forces and/or torques can be in local or global coordinates.\n  The forces can applied at a location given by positions variable.\n\n  Args:\n  forces (Optional[Union[np.ndarray, torch.Tensor]]): forces to be applied to the prims. If not specified, no force will be applied.\n   Defaults to None (i.e: no forces will be applied).\n  torques (Optional[Union[np.ndarray, torch.Tensor]]): torques to be applied to the prims. If not specified, no torque will be applied.\n   Defaults to None (i.e: no torques will be applied).\n  positions (Optional[Union[np.ndarray, torch.Tensor]]): position of the forces with respect to the body frame.\n  If not specified, the forces are applied at the origin of the body frame.\n  Defaults to None (i.e: applied forces will be at the origin of the body frame).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to manipulate. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view).\n  is_global (bool, optional): True if forces, torques, and positions are in the global frame.\n  False if forces, torques, and positions are in the local frame.  Defaults to True.\n  ",
                "snippet": "rigid_prim_view.apply_forces_and_torques_at_pos(forces=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                torques=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                                indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                is_global=True)  # bool\n"
                },
                {
                "title": "disable_gravities",
                "description": " disable gravity on rigid bodies (enabled by default):\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.disable_gravities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "disable_rigid_body_physics",
                "description": " disable rigid body physics (enabled by default):\n  Object will not be moved by external forces such as gravity and collisions\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.disable_rigid_body_physics(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "enable_gravities",
                "description": " enable gravity on rigid bodies (enabled by default):\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.enable_gravities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "enable_rigid_body_physics",
                "description": "  enable rigid body physics (enabled by default):\n  Object will be moved by external forces such as gravity and collisions\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.enable_rigid_body_physics(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_angular_velocities",
                "description": "Gets the angular velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: angular velocities of the prims in the view. shape is (M, 3).\n  ",
                "snippet": "angular_velocities = rigid_prim_view.get_angular_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                            clone=True)  # bool\n"
                },
                {
                "title": "get_coms",
                "description": "Gets rigid body center of mass of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body center of mass positions and orientations of prims in the view. \n  position shape is (M, 3), orientation shape is (M, 4).\n  ",
                "snippet": "coms = rigid_prim_view.get_coms(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                clone=True)  # bool\n"
                },
                {
                "title": "get_contact_force_matrix",
                "description": "  If the object is initialized with filter_paths_expr list, this method returns the contact forces between the prims \n  in the view and the filter prims. i.e., a matrix of dimension (self.count, self._contact_view.num_filters, 3) \n  where num_filters is the determined according to the filter_paths_expr parameter.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (M, self._contact_view.num_filters, 3).\n  ",
                "snippet": "contact_force_matrix = rigid_prim_view.get_contact_force_matrix(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                clone=True,  # bool\n                                                                dt=1.0)  # float\n"
                },
                {
                "title": "get_current_dynamic_state",
                "description": " \n  Returns:\n  DynamicState: the dynamic state of the rigid bodies including positions, orientations, linear_velocities and angular_velocities.\n  ",
                "snippet": "current_dynamic_state = rigid_prim_view.get_current_dynamic_state()\n"
                },
                {
                "title": "get_default_state",
                "description": "Gets the default state of prims in the view, that will be used after each reset. \n\n  Returns:\n  DynamicsViewState: returns the default state of the prims (positions, orientations, linear_velocities and \n  angular_velocities) that is used after each reset.\n  ",
                "snippet": "default_state = rigid_prim_view.get_default_state()\n"
                },
                {
                "title": "get_densities",
                "description": "Gets densities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  \n  Returns:\n  Union[np.ndarray, torch.Tensor]: densities of prims in the view in kg/m^3. shape (M,).\n  ",
                "snippet": "densities = rigid_prim_view.get_densities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_inertias",
                "description": "Gets rigid body inertias of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inertias of prims in the view. \n  shape is (M, 9).\n  ",
                "snippet": "inertias = rigid_prim_view.get_inertias(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                        clone=True)  # bool\n"
                },
                {
                "title": "get_inv_inertias",
                "description": "Gets rigid body inverse inertias of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inverse inertias of prims in the view. \n  shape is (M, 9).\n  ",
                "snippet": "inv_inertias = rigid_prim_view.get_inv_inertias(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                clone=True)  # bool\n"
                },
                {
                "title": "get_inv_masses",
                "description": "Gets rigid body inverse masses of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inverse masses of prims in the view. \n  shape is (M,).\n  ",
                "snippet": "inv_masses = rigid_prim_view.get_inv_masses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                            clone=True)  # bool\n"
                },
                {
                "title": "get_linear_velocities",
                "description": "Gets the linear velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: linear velocities of the prims in the view. shape is (M, 3).\n  ",
                "snippet": "linear_velocities = rigid_prim_view.get_linear_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                          clone=True)  # bool\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view)\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is positions in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = rigid_prim_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_masses",
                "description": "Gets rigid body masses of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: masses of in kg of prims in the view. shape is (M,).\n  ",
                "snippet": "masses = rigid_prim_view.get_masses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                    clone=True)  # bool\n"
                },
                {
                "title": "get_net_contact_forces",
                "description": "  If contact forces of the prims in the view are tracked, this method returns the net contact forces on prims. \n  i.e., a matrix of dimension (self.count, 3)\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n  dt (float): time step multiplier to convert the underlying impulses to forces. If the default value is used then the forces are in fact contact impulses\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Net contact forces of the prims with shape (M,3).\n\n  ",
                "snippet": "net_contact_forces = rigid_prim_view.get_net_contact_forces(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                            clone=True,  # bool\n                                                            dt=1.0)  # float\n"
                },
                {
                "title": "get_sleep_thresholds",
                "description": "Gets sleep thresholds of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  \n  Returns:\n  Union[np.ndarray, torch.Tensor]: Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2. shape (M,).\n  ",
                "snippet": "sleep_thresholds = rigid_prim_view.get_sleep_thresholds(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_velocities",
                "description": "Gets the linear and angular velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: linear and angular velocities of the prims in the view concatenated. shape is (M, 6).\n  ",
                "snippet": "velocities = rigid_prim_view.get_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                            clone=True)  # bool\n"
                },
                {
                "title": "get_world_poses",
                "description": "Gets the poses of the prims in the view with respect to the world's frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = rigid_prim_view.get_world_poses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                              clone=True)  # bool\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates a rigid body view in physX.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "rigid_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: True if the physics handle of the view is valid (i.e physics is initialized for the view). Otherwise False.\n  ",
                "snippet": "rigid_prim_view.is_physics_handle_valid()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state.\n  ",
                "snippet": "rigid_prim_view.post_reset()\n"
                },
                {
                "title": "set_angular_velocities",
                "description": "Sets the angular velocities of the prims in the view. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n  Note: This method is not supported for the gpu pipeline. set_velocities method should be used instead.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): angular velocities to set the rigid prims to. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_angular_velocities(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                       indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_coms",
                "description": "Sets body center of mass positions and orientations for articulation bodies in the view.\n\n  Args:\n  positions (Union[np.ndarray, torch.Tensor]): body center of mass positions for articulations in the view. shape (M, K, 3).\n  orientations (Union[np.ndarray, torch.Tensor]): body center of mass orientations for articulations in the view. shape (M, K, 4).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_coms(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                         orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                         indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of prims in the view, that will be used after each reset. \n\n  Args:\n  positions (Optional[np.ndarray], optional): default positions in the world frame of the prim. shape is (M, 3).\n  orientations (Optional[np.ndarray], optional): default quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  linear_velocities (Optional[np.ndarray], optional): default linear velocities of each prim in the view\n  (to be applied in the first frame and on resets).\n  Shape is (M, 3). Defaults to None.\n  angular_velocities (Optional[np.ndarray], optional): default angular velocities of each prim in the view\n   (to be applied in the first frame and on resets).\n   Shape is (M, 3). Defaults to None.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  linear_velocities=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  angular_velocities=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_densities",
                "description": "Sets densities of prims in the view.\n\n  Args:\n  densities (Optional[Union[np.ndarray, torch.Tensor]]): density in kg/m^3 specified for each prim in the view. \n  shape is (M,). Defaults to None.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_densities(densities=densities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                              indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_inertias",
                "description": "Sets body inertias for prims in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): body inertias for prims in the view. shape (M, K, 9).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_inertias(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                             indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_linear_velocities",
                "description": "Sets the linear velocities of the prims in the view. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n  Note: This method is not supported for the gpu pipeline. set_velocities method should be used instead.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): linear velocities to set the rigid prims to. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_linear_velocities(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_masses",
                "description": "Sets body masses for prims in the view.\n\n  Args:\n  masses (Union[np.ndarray, torch.Tensor]): body masses for prims in kg. shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_masses(masses=masses,  # typing.Union[numpy.ndarray, torch.Tensor]\n                           indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_sleep_thresholds",
                "description": "Sets sleep thresholds of prims in the view.\n  \n\n  Args:\n\n  thresholds (Optional[Union[np.ndarray, torch.Tensor]]):  Mass-normalized kinetic energy threshold below which \n  an actor may go to sleep. Range: [0, inf)\n  Defaults: 0.00005 * tolerancesSpeed* tolerancesSpeed\n  Units: distance^2 / second^2. shape (M,).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_sleep_thresholds(thresholds=thresholds,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                     indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_velocities",
                "description": "Sets the linear and angular velocities of the prims in the view at once. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): linear and angular velocities respectively to set the rigid prims to. shape is (M, 6).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_velocities(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                               indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets poses of prims in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_visual_materials",
                "description": "Used to apply visual material to the prims and optionally its prim descendants.\n\n  Args:\n  visual_materials (Union[VisualMaterial, List[VisualMaterial]]): visual materials to be applied to the prims. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass. If a list is provided then\n  its size has to be equal the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional):  True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of visual materials != length of prims indexed\n  Exception: length of visual materials != length of weaker descendants bools arg\n  ",
                "snippet": "rigid_prim_view.apply_visual_materials(visual_materials=visual_materials,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, typing.List[omni.isaac.core.materials.visual_material.VisualMaterial]]\n                                       weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                       indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_visual_materials",
                "description": "\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[VisualMaterial]: a list of the current applied visual materials to the prims if its type is currently supported.\n  ",
                "snippet": "applied_visual_materials = rigid_prim_view.get_applied_visual_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimViewState: returns the default state of the prims (positions and orientations) that is used after each reset.\n  ",
                "snippet": "default_state = rigid_prim_view.get_default_state()\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local's frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is translations in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = rigid_prim_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_local_scales",
                "description": "Gets prim scales in the view with respect to the local frame (the parent's frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n  ",
                "snippet": "local_scales = rigid_prim_view.get_local_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_visibilities",
                "description": "Returns the current visibilities of the prims in stage.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Shape (M,) with type bool, where each item holds True \n   if the prim is visible in stage. False otherwise.\n  ",
                "snippet": "visibilities = rigid_prim_view.get_visibilities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_poses",
                "description": " Returns the poses (positions and orientations) of the prims in the view with respect to the world frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = rigid_prim_view.get_world_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_scales",
                "description": "Gets prim scales in the view with respect to the world's frame.\n\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n  ",
                "snippet": "world_scales = rigid_prim_view.get_world_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "rigid_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "rigid_prim_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[bool]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n  ",
                "snippet": "rigid_prim_view.is_visual_material_applied(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state (positions and orientations).\n  ",
                "snippet": "rigid_prim_view.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prims (positions and orientations), that will be used after each reset.\n\n  Args:\n  positions (Optional[np.ndarray], optional):  positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[np.ndarray], optional): quaternion orientations in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_scales",
                "description": "Sets prim scales in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scales (Optional[Union[np.ndarray, torch.Tensor]]): scales to be applied to the prim's dimensions in the view. \n  shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_local_scales(scales=scales,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_visibilities",
                "description": "Sets the visibilities of the prims in stage.\n\n  Args:\n  visibilities (Union[np.ndarray, torch.Tensor]): flag to set the visibilities of the usd prims in stage. \n  Shape (M,). Where M <= size of the encapsulated prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_visibilities(visibilities=visibilities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets prim poses in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prims. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "rigid_prim_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                },
                {
                "title": "XFormPrim",
                "snippets": [
                {
                "title": "XFormPrim",
                "description": "Provides high level functions to deal with an Xform prim and its attributes/ properties.\n If there is an Xform prim present at the path, it will use it. Otherwise, a new XForm prim at\n the specified prim path will be created.\n\n Note: the prim will have \"xformOp:orient\", \"xformOp:translate\" and \"xformOp:scale\" only post init, \n unless it is a non-root articulation link.\n\n Args:\n prim_path (str): prim path of the Prim to encapsulate or create.\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene.\n Defaults to \"xform_prim\".\n position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n Defaults to None, which means left unchanged.\n translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n (with respect to its parent prim). shape is (3, ).\n Defaults to None, which means left unchanged.\n orientation (Optional[Sequence[float]], optional): quaternion orientation in the world/ local frame of the prim\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (4, ).\n Defaults to None, which means left unchanged.\n scale (Optional[Sequence[float]], optional): local scale to be applied to the prim's dimensions. shape is (3, ).\n Defaults to None, which means left unchanged.\n visible (bool, optional): set to false for an invisible prim in the stage while rendering. Defaults to True.\n\n Raises:\n Exception: if translation and position defined at the same time",
                "snippet": "xform_prim = XFormPrim(prim_path=prim_path,  # str\n                       name=\"xform_prim\",  # str\n                       position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                       visible=None)  # typing.Union[bool, NoneType]\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "xform_prim.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                                 weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = xform_prim.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = xform_prim.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = xform_prim.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = xform_prim.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = xform_prim.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = xform_prim.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = xform_prim.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "xform_prim.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "xform_prim.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "xform_prim.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "xform_prim.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "xform_prim.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                             orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "xform_prim.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "xform_prim.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "xform_prim.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "xform_prim.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                          orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "XFormPrimView",
                "snippets": [
                {
                "title": "XFormPrimView",
                "description": "Provides high level functions to deal with an Xform prim view (1 or more XForm prims and its descendants) \n as well as its attributes/ properties.\n This object wraps all matching XForms found at the regex provided at the prim_paths_expr.\n\n Note: each prim will have \"xformOp:orient\", \"xformOp:translate\" and \"xformOp:scale\" only post init,\n unless it is a non-root articulation link.\n\n Args:\n prim_paths_expr (str): prim paths regex to encapsulate all prims that match it.\n example: \"/World/Env[1-5]/Franka\" will match /World/Env1/Franka, \n /World/Env2/Franka..etc.\n (a non regex prim path can also be used to encapsulate one XForm).\n name (str, optional): shortname to be used as a key by Scene class. \n Note: needs to be unique if the object is added to the Scene. \n Defaults to \"xform_prim_view\".\n positions (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default positions in the world frame of the prim. \n shape is (N, 3).\n Defaults to None, which means left unchanged.\n translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default translations in the local frame of the prims\n (with respect to its parent prims). shape is (N, 3).\n Defaults to None, which means left unchanged.\n orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n default quaternion orientations in the world/ local frame of the prim\n (depends if translation or position is specified).\n quaternion is scalar-first (w, x, y, z). shape is (N, 4).\n Defaults to None, which means left unchanged.\n scales (Optional[Union[np.ndarray, torch.Tensor]], optional): local scales to be applied to \n the prim's dimensions. shape is (N, 3).\n Defaults to None, which means left unchanged.\n visibilities (Optional[Union[np.ndarray, torch.Tensor]], optional): set to false for an invisible prim in \n the stage while rendering. shape is (N,). \n Defaults to None.\n reset_xform_properties (bool, optional): True if the prims don't have the right set of xform properties \n (i.e: translate, orient and scale) ONLY and in that order.\n Set this parameter to False if the object were cloned using using \n the cloner api in omni.isaac.cloner. Defaults to True.\n\n Raises:\n Exception: if translations and positions defined at the same time.\n Exception: No prim was matched using the prim_paths_expr provided.",
                "snippet": "xform_prim_view = XFormPrimView(prim_paths_expr=prim_paths_expr,  # str\n                                name=\"xform_prim_view\",  # str\n                                positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                visibilities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                reset_xform_properties=True)  # bool\n"
                },
                {
                "title": "apply_visual_materials",
                "description": "Used to apply visual material to the prims and optionally its prim descendants.\n\n  Args:\n  visual_materials (Union[VisualMaterial, List[VisualMaterial]]): visual materials to be applied to the prims. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass. If a list is provided then\n  its size has to be equal the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional):  True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of visual materials != length of prims indexed\n  Exception: length of visual materials != length of weaker descendants bools arg\n  ",
                "snippet": "xform_prim_view.apply_visual_materials(visual_materials=visual_materials,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, typing.List[omni.isaac.core.materials.visual_material.VisualMaterial]]\n                                       weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                       indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_visual_materials",
                "description": "\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[VisualMaterial]: a list of the current applied visual materials to the prims if its type is currently supported.\n  ",
                "snippet": "applied_visual_materials = xform_prim_view.get_applied_visual_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimViewState: returns the default state of the prims (positions and orientations) that is used after each reset.\n  ",
                "snippet": "default_state = xform_prim_view.get_default_state()\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local's frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is translations in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = xform_prim_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_local_scales",
                "description": "Gets prim scales in the view with respect to the local frame (the parent's frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n  ",
                "snippet": "local_scales = xform_prim_view.get_local_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_visibilities",
                "description": "Returns the current visibilities of the prims in stage.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Shape (M,) with type bool, where each item holds True \n   if the prim is visible in stage. False otherwise.\n  ",
                "snippet": "visibilities = xform_prim_view.get_visibilities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_poses",
                "description": " Returns the poses (positions and orientations) of the prims in the view with respect to the world frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = xform_prim_view.get_world_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_scales",
                "description": "Gets prim scales in the view with respect to the world's frame.\n\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n  ",
                "snippet": "world_scales = xform_prim_view.get_world_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "xform_prim_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "xform_prim_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[bool]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n  ",
                "snippet": "xform_prim_view.is_visual_material_applied(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state (positions and orientations).\n  ",
                "snippet": "xform_prim_view.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prims (positions and orientations), that will be used after each reset.\n\n  Args:\n  positions (Optional[np.ndarray], optional):  positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[np.ndarray], optional): quaternion orientations in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "xform_prim_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "xform_prim_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_scales",
                "description": "Sets prim scales in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scales (Optional[Union[np.ndarray, torch.Tensor]]): scales to be applied to the prim's dimensions in the view. \n  shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "xform_prim_view.set_local_scales(scales=scales,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_visibilities",
                "description": "Sets the visibilities of the prims in stage.\n\n  Args:\n  visibilities (Union[np.ndarray, torch.Tensor]): flag to set the visibilities of the usd prims in stage. \n  Shape (M,). Where M <= size of the encapsulated prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "xform_prim_view.set_visibilities(visibilities=visibilities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets prim poses in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prims. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "xform_prim_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                }
                ]
                },
                {
                "title": "Robots",
                "snippets": [
                {
                "title": "Robot",
                "snippets": [
                {
                "title": "Robot",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"robot\".\n position (Optional[Sequence[float]], optional): [description]. Defaults to None.\n translation (Optional[Sequence[float]], optional): [description]. Defaults to None.\n orientation (Optional[Sequence[float]], optional): [description]. Defaults to None.\n scale (Optional[Sequence[float]], optional): [description]. Defaults to None.\n visible (bool, optional): [description]. Defaults to True.\n articulation_controller (Optional[ArticulationController], optional): [description]. Defaults to None.\n ",
                "snippet": "robot = Robot(prim_path=prim_path,  # str\n              name=\"robot\",  # str\n              position=None,  # typing.Union[typing.Sequence[float], NoneType]\n              translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n              orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n              scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n              visible=True,  # bool\n              articulation_controller=None)  # typing.Union[omni.isaac.core.controllers.articulation_controller.ArticulationController, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "[summary]\n  ",
                "snippet": "robot.post_reset()\n"
                },
                {
                "title": "apply_action",
                "description": "[summary]\n\n  Args:\n  control_actions (ArticulationAction): actions to be applied for next physics step.\n  indices (Optional[Union[list, np.ndarray]], optional): degree of freedom indices to apply actions to. \n   Defaults to all degrees of freedom.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "robot.apply_action(control_actions=control_actions)  # omni.isaac.core.utils.types.ArticulationAction\n"
                },
                {
                "title": "disable_gravity",
                "description": "Keep gravity from affecting the robot\n  ",
                "snippet": "robot.disable_gravity()\n"
                },
                {
                "title": "enable_gravity",
                "description": "Gravity will affect the robot\n  ",
                "snippet": "robot.enable_gravity()\n"
                },
                {
                "title": "get_angular_velocity",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "angular_velocity = robot.get_angular_velocity()\n"
                },
                {
                "title": "get_applied_action",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  ArticulationAction: [description]\n  ",
                "snippet": "applied_action = robot.get_applied_action()\n"
                },
                {
                "title": "get_applied_joint_efforts",
                "description": "Gets the efforts applied to the joints\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Raises:\n  Exception: _description_\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "applied_joint_efforts = robot.get_applied_joint_efforts(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_articulation_body_count",
                "description": "[summary]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "articulation_body_count = robot.get_articulation_body_count()\n"
                },
                {
                "title": "get_articulation_controller",
                "description": "  Returns:\n  ArticulationController: PD Controller of all degrees of freedom of an articulation, can apply position targets, velocity targets and efforts.\n  ",
                "snippet": "articulation_controller = robot.get_articulation_controller()\n"
                },
                {
                "title": "get_dof_index",
                "description": "[summary]\n\n  Args:\n  dof_name (str): [description]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "dof_index = robot.get_dof_index(dof_name=dof_name)  # str\n"
                },
                {
                "title": "get_enabled_self_collisions",
                "description": "[summary]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "enabled_self_collisions = robot.get_enabled_self_collisions()\n"
                },
                {
                "title": "get_joint_efforts",
                "description": " Deprecated function. Please use get_applied_joint_efforts  instead.\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Raises:\n  Exception: _description_\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "joint_efforts = robot.get_joint_efforts(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_joint_positions",
                "description": "_summary_\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "joint_positions = robot.get_joint_positions(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_joint_velocities",
                "description": "_summary_\n\n  Args:\n  joint_indices (Optional[Union[List, np.ndarray]], optional): _description_. Defaults to None.\n\n  Returns:\n  np.ndarray: _description_\n  ",
                "snippet": "joint_velocities = robot.get_joint_velocities(joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_joints_default_state",
                "description": " Accessor for the default joints state.\n\n  Returns:\n  JointsState: The defaults that the robot is reset to when post_reset() is called (often\n  automatically called during world.reset()).\n  ",
                "snippet": "joints_default_state = robot.get_joints_default_state()\n"
                },
                {
                "title": "get_joints_state",
                "description": "[summary]\n\n  Returns:\n  JointsState: [description]\n  ",
                "snippet": "joints_state = robot.get_joints_state()\n"
                },
                {
                "title": "get_linear_velocity",
                "description": "[summary]\n\n  Returns:\n  np.ndarray: [description]\n  ",
                "snippet": "linear_velocity = robot.get_linear_velocity()\n"
                },
                {
                "title": "get_sleep_threshold",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "sleep_threshold = robot.get_sleep_threshold()\n"
                },
                {
                "title": "get_solver_position_iteration_count",
                "description": "[summary]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "solver_position_iteration_count = robot.get_solver_position_iteration_count()\n"
                },
                {
                "title": "get_solver_velocity_iteration_count",
                "description": "[summary]\n\n  Returns:\n  int: [description]\n  ",
                "snippet": "solver_velocity_iteration_count = robot.get_solver_velocity_iteration_count()\n"
                },
                {
                "title": "get_stabilization_threshold",
                "description": "[summary]\n\n  Returns:\n  float: [description]\n  ",
                "snippet": "stabilization_threshold = robot.get_stabilization_threshold()\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates an articulation view using physX tensor api.\n  This needs to be called after each hard reset (i.e stop + play on the timeline) before interacting with any\n  of the functions of this class.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "robot.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "set_angular_velocity",
                "description": "[summary]\n\n  Args:\n  velocity (np.ndarray): [description]\n  ",
                "snippet": "robot.set_angular_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_enabled_self_collisions",
                "description": "[summary]\n\n  Args:\n  flag (bool): [description]\n  ",
                "snippet": "robot.set_enabled_self_collisions(flag=flag)  # bool\n"
                },
                {
                "title": "set_joint_efforts",
                "description": "[summary]\n\n  Args:\n  efforts (np.ndarray): [description]\n  joint_indices (Optional[Union[list, np.ndarray]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "robot.set_joint_efforts(efforts=efforts,  # numpy.ndarray\n                        joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_joint_positions",
                "description": "[summary]\n\n  Args:\n  positions (np.ndarray): [description]\n  indices (Optional[Union[list, np.ndarray]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "robot.set_joint_positions(positions=positions,  # numpy.ndarray\n                          joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_joint_velocities",
                "description": "[summary]\n\n  Args:\n  velocities (np.ndarray): [description]\n  indices (Optional[Union[list, np.ndarray]], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "robot.set_joint_velocities(velocities=velocities,  # numpy.ndarray\n                           joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_joints_default_state",
                "description": "[summary]\n\n  Args:\n  positions (Optional[np.ndarray], optional): [description]. Defaults to None.\n  velocities (Optional[np.ndarray], optional): [description]. Defaults to None.\n  efforts (Optional[np.ndarray], optional): [description]. Defaults to None.\n  ",
                "snippet": "robot.set_joints_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                               velocities=None,  # typing.Union[numpy.ndarray, NoneType]\n                               efforts=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_linear_velocity",
                "description": "Sets the linear velocity of the prim in stage.\n\n  Args:\n  velocity (np.ndarray):linear velocity to set the rigid prim to. Shape (3,).\n  ",
                "snippet": "robot.set_linear_velocity(velocity=velocity)  # numpy.ndarray\n"
                },
                {
                "title": "set_sleep_threshold",
                "description": "[summary]\n\n  Args:\n  threshold (float): [description]\n  ",
                "snippet": "robot.set_sleep_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "set_solver_position_iteration_count",
                "description": "[summary]\n\n  Args:\n  count (int): [description]\n  ",
                "snippet": "robot.set_solver_position_iteration_count(count=count)  # int\n"
                },
                {
                "title": "set_solver_velocity_iteration_count",
                "description": "[summary]\n\n  Args:\n  count (int): [description]\n  ",
                "snippet": "robot.set_solver_velocity_iteration_count(count=count)  # int\n"
                },
                {
                "title": "set_stabilization_threshold",
                "description": "[summary]\n\n  Args:\n  threshold (float): [description]\n  ",
                "snippet": "robot.set_stabilization_threshold(threshold=threshold)  # float\n"
                },
                {
                "title": "apply_visual_material",
                "description": "Used to apply visual material to the held prim and optionally its descendants.\n\n  Args:\n  visual_material (VisualMaterial): visual material to be applied to the held prim. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass.\n  weaker_than_descendants (bool, optional): True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False.\n  ",
                "snippet": "robot.apply_visual_material(visual_material=visual_material,  # omni.isaac.core.materials.visual_material.VisualMaterial\n                            weaker_than_descendants=False)  # bool\n"
                },
                {
                "title": "get_applied_visual_material",
                "description": "Returns the current applied visual material in case it was applied using apply_visual_material OR\n   it's one of the following materials that was already applied before: PreviewSurface, OmniPBR and OmniGlass.\n\n  Returns:\n  VisualMaterial: the current applied visual material if its type is currently supported.\n  ",
                "snippet": "applied_visual_material = robot.get_applied_visual_material()\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimState: returns the default state of the prim (position and orientation) that is used after each reset.\n  ",
                "snippet": "default_state = robot.get_default_state()\n"
                },
                {
                "title": "get_local_pose",
                "description": "Gets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the local frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the local frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "local_pose = robot.get_local_pose()\n"
                },
                {
                "title": "get_local_scale",
                "description": "Gets prim's scale with respect to the local frame (the parent's frame).\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the local frame. shape is (3, ).\n  ",
                "snippet": "local_scale = robot.get_local_scale()\n"
                },
                {
                "title": "get_visibility",
                "description": "  Returns:\n  bool: true if the prim is visible in stage. false otherwise.\n  ",
                "snippet": "visibility = robot.get_visibility()\n"
                },
                {
                "title": "get_world_pose",
                "description": "Gets prim's pose with respect to the world's frame.\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame of the prim. shape is (3, ). \n   second index is quaternion orientation in the world frame of the prim.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  ",
                "snippet": "world_pose = robot.get_world_pose()\n"
                },
                {
                "title": "get_world_scale",
                "description": "Gets prim's scale with respect to the world's frame.\n\n  Returns:\n  np.ndarray: scale applied to the prim's dimensions in the world frame. shape is (3, ).\n  ",
                "snippet": "world_scale = robot.get_world_scale()\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "robot.initialize(physics_sim_view=None)\n"
                },
                {
                "title": "is_valid",
                "description": "  Returns:\n  bool: True is the current prim path corresponds to a valid prim in stage. False otherwise.\n  ",
                "snippet": "robot.is_valid()\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Returns:\n  bool: True if there is a visual material applied. False otherwise.\n  ",
                "snippet": "robot.is_visual_material_applied()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prim to its default state (position and orientation).\n  ",
                "snippet": "robot.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prim (position and orientation), that will be used after each reset.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "robot.set_default_state(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                        orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_pose",
                "description": "Sets prim's pose with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translation (Optional[Sequence[float]], optional): translation in the local frame of the prim\n  (with respect to its parent prim). shape is (3, ).\n  Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the local frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "robot.set_local_pose(translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                     orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_local_scale",
                "description": "Sets prim's scale with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scale (Optional[Sequence[float]]): scale to be applied to the prim's dimensions. shape is (3, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "robot.set_local_scale(scale=scale)  # typing.Union[typing.Sequence[float], NoneType]\n"
                },
                {
                "title": "set_visibility",
                "description": "Sets the visibility of the prim in stage.\n\n  Args:\n  visible (bool): flag to set the visibility of the usd prim in stage.\n  ",
                "snippet": "robot.set_visibility(visible=visible)  # bool\n"
                },
                {
                "title": "set_world_pose",
                "description": "Sets prim's pose with respect to the world's frame.\n\n  Args:\n  position (Optional[Sequence[float]], optional): position in the world frame of the prim. shape is (3, ).\n   Defaults to None, which means left unchanged.\n  orientation (Optional[Sequence[float]], optional): quaternion orientation in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (4, ).\n  Defaults to None, which means left unchanged.\n  ",
                "snippet": "robot.set_world_pose(position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                     orientation=None)  # typing.Union[typing.Sequence[float], NoneType]\n"
                }
                ]
                },
                {
                "title": "RobotView",
                "snippets": [
                {
                "title": "RobotView",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n name (str, optional): [description]. Defaults to \"robot\".\n position (Optional[np.ndarray], optional): [description]. Defaults to None.\n translation (Optional[np.ndarray], optional): [description]. Defaults to None.\n orientation (Optional[np.ndarray], optional): [description]. Defaults to None.\n scale (Optional[np.ndarray], optional): [description]. Defaults to None.\n visible (bool, optional): [description]. Defaults to True.\n articulation_controller (Optional[ArticulationController], optional): [description]. Defaults to None.\n ",
                "snippet": "robot_view = RobotView(prim_paths_expr=prim_paths_expr,  # str\n                       name=\"rigid_prim_view\",  # str\n                       positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                       translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                       orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                       scales=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                       visibilities=None)  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "[summary]\n  ",
                "snippet": "robot_view.post_reset()\n"
                },
                {
                "title": "apply_action",
                "description": " Applies ArticulationActions which encapsulates joint position targets, velocity targets, efforts and joint indices in one object.\n  Can be used instead of the seperate set_joint_position_targets..etc.\n\n  Args:\n  control_actions (ArticulationActions): actions to be applied for next physics step.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.apply_action(control_actions=control_actions,  # omni.isaac.core.utils.types.ArticulationActions\n                        indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_angular_velocities",
                "description": "Gets the angular velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: angular velocities of the prims in the view. shape is (M, 3).\n  ",
                "snippet": "angular_velocities = robot_view.get_angular_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                       clone=True)  # bool\n"
                },
                {
                "title": "get_applied_actions",
                "description": "Gets current applied actions in an ArticulationActions object.\n\n  Args:\n  clone (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n  Returns:\n  ArticulationActions: current applied actions (i.e: current position targets and velocity targets)\n  ",
                "snippet": "applied_actions = robot_view.get_applied_actions(clone=True)  # bool\n"
                },
                {
                "title": "get_applied_joint_efforts",
                "description": "Gets the joint efforts of articulations in the view. The method will return the efforts set by the set_joint_efforts.\n  \n  Args:\n  efforts (Optional[Union[np.ndarray, torch.Tensor]]): efforts of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: joint efforts of articulations in the view assigned via set_joint_efforts. shape is (M, K).\n  ",
                "snippet": "applied_joint_efforts = robot_view.get_applied_joint_efforts(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                             joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                             clone=True)  # bool\n"
                },
                {
                "title": "get_armatures",
                "description": "Gets armatures for articulation in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (Optional[bool]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: maximum efforts for articulations in the view. shape (M, K).\n  ",
                "snippet": "armatures = robot_view.get_armatures(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                     joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                     clone=True)  # bool\n"
                },
                {
                "title": "get_articulation_body_count",
                "description": "  Returns:\n  int: number of links in the articulation.\n  ",
                "snippet": "articulation_body_count = robot_view.get_articulation_body_count()\n"
                },
                {
                "title": "get_body_coms",
                "description": "Gets rigid body center of mass of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body center of mass positions and orientations of articulations in the view. \n  position shape is (M, K, 3), orientation shape is (M, k, 4).\n  ",
                "snippet": "body_coms = robot_view.get_body_coms(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                     body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                     clone=True)  # bool\n"
                },
                {
                "title": "get_body_index",
                "description": "Gets the body index in the articulation given its name.\n\n  Args:\n  body_name (str): name of the body/link to query.\n\n  Returns:\n  int: index of the body/link in the articulation buffers.\n  ",
                "snippet": "body_index = robot_view.get_body_index(body_name=body_name)  # str\n"
                },
                {
                "title": "get_body_inertias",
                "description": "Gets rigid body inertias of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inertias of articulations in the view. \n  shape is (M, K, 9).\n  ",
                "snippet": "body_inertias = robot_view.get_body_inertias(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                             body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                             clone=True)  # bool\n"
                },
                {
                "title": "get_body_inv_inertias",
                "description": "Gets rigid body inverse inertias of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inverse inertias of articulations in the view. \n  shape is (M, K, 9).\n  ",
                "snippet": "body_inv_inertias = robot_view.get_body_inv_inertias(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                     body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                     clone=True)  # bool\n"
                },
                {
                "title": "get_body_inv_masses",
                "description": "Gets rigid body inverse masses of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body inverse masses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "body_inv_masses = robot_view.get_body_inv_masses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                 body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_body_masses",
                "description": "Gets rigid body masses of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to query. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: rigid body masses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "body_masses = robot_view.get_body_masses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                         body_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                         clone=True)  # bool\n"
                },
                {
                "title": "get_coriolis_and_centrifugal_forces",
                "description": "Gets the coriolis and centrifugal forces of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Coriolis and centrifugal forces of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "coriolis_and_centrifugal_forces = robot_view.get_coriolis_and_centrifugal_forces(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                                 joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_dof_index",
                "description": "Gets the dof index in the joint buffers given its name.\n\n  Args:\n  dof_name (str): name of the joint that corresponds to the degree of freedom to query.\n\n  Returns:\n  int: index of the degree of freedom in the joint buffers.\n  ",
                "snippet": "dof_index = robot_view.get_dof_index(dof_name=dof_name)  # str\n"
                },
                {
                "title": "get_dof_limits",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: degrees of freedom position limits. \n  shape is (N, num_dof, 2) where index 0 corresponds to the lower limit and index 1 corresponds to the upper limit. \n  ",
                "snippet": "dof_limits = robot_view.get_dof_limits()\n"
                },
                {
                "title": "get_dof_types",
                "description": "Gets the dof types given the dof names.\n\n  Args:\n  dof_names (List[str], optional): names of the joints that corresponds to the degrees of freedom to query. Defaults to None.\n\n  Returns:\n  List[str]: types of the joints that corresponds to the degrees of freedom. Types can be invalid, translation or rotation.\n  ",
                "snippet": "dof_types = robot_view.get_dof_types(dof_names=None)  # typing.List[str]\n"
                },
                {
                "title": "get_effort_modes",
                "description": "  Gets effort modes for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n\n  Returns:\n  List: Returns a List of size (M, K) indicating the effort modes. accelaration or force.\n  ",
                "snippet": "effort_modes = robot_view.get_effort_modes(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                           joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_enabled_self_collisions",
                "description": "  Gets the enable self collisions flag\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: true if self collisions enabled. otherwise false. shape (M,)\n  ",
                "snippet": "enabled_self_collisions = robot_view.get_enabled_self_collisions(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_fixed_tendon_dampings",
                "description": "Gets the dampings of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon dampings of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_dampings = robot_view.get_fixed_tendon_dampings(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                             clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_limit_stiffnesses",
                "description": "Gets the limit stiffness of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_limit_stiffnesses = robot_view.get_fixed_tendon_limit_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                               clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_limits",
                "description": "Gets the limits of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K, 2).\n  ",
                "snippet": "fixed_tendon_limits = robot_view.get_fixed_tendon_limits(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                         clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_offsets",
                "description": "Gets the offsets of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_offsets = robot_view.get_fixed_tendon_offsets(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                           clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_rest_lengths",
                "description": "Gets the rest length of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_rest_lengths = robot_view.get_fixed_tendon_rest_lengths(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                     clone=True)  # bool\n"
                },
                {
                "title": "get_fixed_tendon_stiffnesses",
                "description": "Gets the stiffness of fixed tendons for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: fixed tendon stiffnesses of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "fixed_tendon_stiffnesses = robot_view.get_fixed_tendon_stiffnesses(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                   clone=True)  # bool\n"
                },
                {
                "title": "get_friction_coefficients",
                "description": "Gets friction coefficients for articulation in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (Optional[bool]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: maximum efforts for articulations in the view. shape (M, K).\n  ",
                "snippet": "friction_coefficients = robot_view.get_friction_coefficients(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                             joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                             clone=True)  # bool\n"
                },
                {
                "title": "get_gains",
                "description": "  Gets stiffness and damping of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return clones of the internal buffers. Otherwise False. Defaults to True.\n\n  Returns:\n  Tuple[Union[np.ndarray, torch.Tensor], Union[np.ndarray, torch.Tensor]]: stiffness and damping of\n   articulations in the view respectively. shapes are (M, K).\n  ",
                "snippet": "gains = robot_view.get_gains(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                             joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                             clone=True)  # bool\n"
                },
                {
                "title": "get_generalized_gravity_forces",
                "description": "Gets the generalized gravity forces of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: generalized gravity forces of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "generalized_gravity_forces = robot_view.get_generalized_gravity_forces(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                       joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                                       clone=True)  # bool\n"
                },
                {
                "title": "get_jacobian_shape",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: shape of jacobian for a single articulation. \n  ",
                "snippet": "jacobian_shape = robot_view.get_jacobian_shape()\n"
                },
                {
                "title": "get_jacobians",
                "description": "Gets the jacobians of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: jacobians of articulations in the view. \n  shape is (M, jacobian_shape).\n  ",
                "snippet": "jacobians = robot_view.get_jacobians(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                     clone=True)  # bool\n"
                },
                {
                "title": "get_joint_positions",
                "description": "Gets the joint positions of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: joint positions of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "joint_positions = robot_view.get_joint_positions(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                 joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                 clone=True)  # bool\n"
                },
                {
                "title": "get_joint_velocities",
                "description": "Gets the joint velocities of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: joint velocities of articulations in the view. \n  shape is (M, K).\n  ",
                "snippet": "joint_velocities = robot_view.get_joint_velocities(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                   joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                                   clone=True)  # bool\n"
                },
                {
                "title": "get_joints_default_state",
                "description": "  Returns:\n  JointsState: current joints default state. (i.e: the joint positions and velocities after a reset).\n  ",
                "snippet": "joints_default_state = robot_view.get_joints_default_state()\n"
                },
                {
                "title": "get_joints_state",
                "description": "  Returns:\n  JointsState: current joint positions and velocities.\n  ",
                "snippet": "joints_state = robot_view.get_joints_state()\n"
                },
                {
                "title": "get_linear_velocities",
                "description": "Gets the linear velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: linear velocities of the prims in the view. shape is (M, 3).\n  ",
                "snippet": "linear_velocities = robot_view.get_linear_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                                     clone=True)\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local frame (the prim's parent frame).\n  \n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is positions in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = robot_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_mass_matrices",
                "description": "Gets the mass matrices of articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: mass matrices of articulations in the view. \n  shape is (M, mass_matrix_shape).\n  ",
                "snippet": "mass_matrices = robot_view.get_mass_matrices(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                             clone=True)  # bool\n"
                },
                {
                "title": "get_mass_matrix_shape",
                "description": "  Returns:\n  Union[np.ndarray, torch.Tensor]: shape of mass matrix for a single articulation. \n  ",
                "snippet": "mass_matrix_shape = robot_view.get_mass_matrix_shape()\n"
                },
                {
                "title": "get_max_efforts",
                "description": "Gets maximum efforts for articulation in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to query. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  clone (Optional[bool]): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: maximum efforts for articulations in the view. shape (M, K).\n  ",
                "snippet": "max_efforts = robot_view.get_max_efforts(indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                         joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                         clone=True)  # bool\n"
                },
                {
                "title": "get_sleep_thresholds",
                "description": "Gets sleep thresholds for articulations in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: current sleep thresholds. shape (M,).\n  ",
                "snippet": "sleep_thresholds = robot_view.get_sleep_thresholds(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_solver_position_iteration_counts",
                "description": "Gets the physics solver itertion counts for joint positions.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: number of iterations for the solver. Shape (M,).\n  ",
                "snippet": "solver_position_iteration_counts = robot_view.get_solver_position_iteration_counts(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_solver_velocity_iteration_counts",
                "description": "  Gets the physics solver itertion counts for joint velocities.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: number of iterations for the solver. Shape (M,).\n  ",
                "snippet": "solver_velocity_iteration_counts = robot_view.get_solver_velocity_iteration_counts(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_stabilization_thresholds",
                "description": "Gets the stabilizaion thresholds.\n\n  Args:\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: current stabilization thresholds. Shape (M,).\n  ",
                "snippet": "stabilization_thresholds = robot_view.get_stabilization_thresholds(indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_velocities",
                "description": "Gets the linear and angular velocities of prims in the view.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n  to query. Shape (M,).\n  Where M <= size of the encapsulated prims in the view.\n  Defaults to None (i.e: all prims in the view)\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: linear and angular velocities of the prims in the view concatenated. shape is (M, 6).\n  ",
                "snippet": "velocities = robot_view.get_velocities(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                       clone=True)  # bool\n"
                },
                {
                "title": "get_world_poses",
                "description": "Gets the poses of the prims in the view with respect to the world's frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  clone (bool, optional): True to return a clone of the internal buffer. Otherwise False. Defaults to True.\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = robot_view.get_world_poses(indices=None,  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n                                         clone=True)  # bool\n"
                },
                {
                "title": "initialize",
                "description": "Create a physics simulation view if not passed and creates an articulation view using physX tensor api.\n\n  Args:\n  physics_sim_view (omni.physics.tensors.SimulationView, optional): current physics simulation view. Defaults to None.\n  ",
                "snippet": "robot_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_physics_handle_valid",
                "description": "  Returns:\n  bool: False if .initialize() needs to be called again for the physics handle to be valid. Otherwise True.\n  Note: if physics handle is not valid many of the methods that requires physX will return None.\n  ",
                "snippet": "robot_view.is_physics_handle_valid()\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state.\n  ",
                "snippet": "robot_view.post_reset()\n"
                },
                {
                "title": "set_angular_velocities",
                "description": "Sets the angular velocities of the prims in the view. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n  Note: This method is not supported for the gpu pipeline. set_velocities method should be used instead.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): angular velocities to set the rigid prims to. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_angular_velocities(velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_armatures",
                "description": "Sets armatures for articulation joints in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): armatures for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_armatures(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                         indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                         joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_body_coms",
                "description": "Sets body center of mass positions and orientations for articulation bodies in the view.\n\n  Args:\n  positions (Union[np.ndarray, torch.Tensor]): body center of mass positions for articulations in the view. shape (M, K, 3).\n  orientations (Union[np.ndarray, torch.Tensor]): body center of mass orientations for articulations in the view. shape (M, K, 4).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to manipulate. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  ",
                "snippet": "robot_view.set_body_coms(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                         orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                         indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                         body_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_body_inertias",
                "description": "Sets body inertias for articulation bodies in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): body inertias for articulations in the view. shape (M, K, 9).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to manipulate. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  ",
                "snippet": "robot_view.set_body_inertias(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                             indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                             body_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_body_masses",
                "description": "Sets body masses for articulation bodies in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): body masses for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  body_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): body indicies to specify which bodies \n   to manipulate. Shape (K,).\n   Where K <= num of bodies.\n   Defaults to None (i.e: all bodies).\n  ",
                "snippet": "robot_view.set_body_masses(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                           indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                           body_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_effort_modes",
                "description": "  Sets effort modes for articulations in the view.\n\n  Args:\n  mode (str): effort mode to be applied to prims in the view. force or acceleration.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n\n  Raises:\n  Exception: _description_\n  ",
                "snippet": "robot_view.set_effort_modes(mode=mode,  # str\n                            indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                            joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_enabled_self_collisions",
                "description": " Sets the enable self collisions flag\n\n  Args:\n  flags (Union[np.ndarray, torch.Tensor]): true to enable self collision. otherwise false. shape (M,)\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_enabled_self_collisions(flags=flags,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_fixed_tendon_properties",
                "description": "Sets fixed tendon properties for articulations in the view.\n\n  Args:\n  stiffnesses (Union[np.ndarray, torch.Tensor]): fixed tendon stiffnesses for articulations in the view. shape (M, K).\n  dampings (Union[np.ndarray, torch.Tensor]): fixed tendon dampings for articulations in the view. shape (M, K).\n  limit_stiffnesses (Union[np.ndarray, torch.Tensor]): fixed tendon limit stiffnesses for articulations in the view. shape (M, K).\n  limits (Union[np.ndarray, torch.Tensor]): fixed tendon limits for articulations in the view. shape (M, K, 2).\n  rest_lengths (Union[np.ndarray, torch.Tensor]): fixed tendon rest lengths for articulations in the view. shape (M, K).\n  offsets (Union[np.ndarray, torch.Tensor]): fixed tendon offsets for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_fixed_tendon_properties(stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       dampings=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       limit_stiffnesses=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       limits=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       rest_lengths=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       offsets=None,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                       indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_friction_coefficients",
                "description": "Sets friction coefficients for articulation joints in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): friction coefficients for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_friction_coefficients(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                     indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                     joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_gains",
                "description": "  Sets stiffness and damping of articulations in the view.\n\n  Args:\n  kps (Optional[Union[np.ndarray, torch.Tensor]], optional): stiffness of the drives. shape is (M, K). Defaults to None.\n  kds (Optional[Union[np.ndarray, torch.Tensor]], optional): damping of the drives. shape is (M, K).. Defaults to None.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  save_to_usd (bool, optional): True to save the gains in the usd. otherwise False.\n  ",
                "snippet": "robot_view.set_gains(kps=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                     kds=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                     indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                     joint_indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                     save_to_usd=False)  # bool\n"
                },
                {
                "title": "set_joint_efforts",
                "description": "Sets the joint efforts of articulations in the view.\n\n  Args:\n  efforts (Optional[Union[np.ndarray, torch.Tensor]]): efforts of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_joint_efforts(efforts=efforts,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                             indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                             joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_position_targets",
                "description": "  Sets the joint position targets for the implicit pd controllers.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]]): joint position targets for the implicit pd controller. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_joint_position_targets(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                      joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_positions",
                "description": "Sets the joint positions of articulations in the view.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]]): joint positions of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_joint_positions(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                               indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                               joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_velocities",
                "description": "Sets the joint velocities of articulations in the view.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): joint velocities of articulations in the view to be set to in the next frame. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_joint_velocities(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joint_velocity_targets",
                "description": "  Sets the joint velocity targets for the implicit pd controllers.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): joint velocity targets for the implicit pd controller. \n  shape is (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_joint_velocity_targets(velocities=velocities,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                      indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                                      joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_joints_default_state",
                "description": "Sets the joints default state (joint positions, velocities and efforts) to be applied after each reset.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): default joint positions.\n   shape is (N, num of dofs). Defaults to None.\n  velocities (Optional[Union[np.ndarray, torch.Tensor]], optional): default joint velocities.\n   shape is (N, num of dofs). Defaults to None.\n  efforts (Optional[Union[np.ndarray, torch.Tensor]], optional): default joint efforts.\n   shape is (N, num of dofs). Defaults to None.\n  ",
                "snippet": "robot_view.set_joints_default_state(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                    efforts=None)  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_linear_velocities",
                "description": "Sets the linear velocities of the prims in the view. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n  Note: This method is not supported for the gpu pipeline. set_velocities method should be used instead.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): linear velocities to set the rigid prims to. shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_linear_velocities(velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                                 indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_max_efforts",
                "description": "Sets maximum efforts for articulation in the view.\n\n  Args:\n  values (Union[np.ndarray, torch.Tensor]): maximum efforts for articulations in the view. shape (M, K).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.set_max_efforts(values=values,  # typing.Union[numpy.ndarray, torch.Tensor]\n                           indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                           joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_sleep_thresholds",
                "description": " Sets sleep thresholds for articulations in the view.\n\n  Args:\n  thresholds (Union[np.ndarray, torch.Tensor]): sleep thresholds to be applied. shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_sleep_thresholds(thresholds=thresholds,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_solver_position_iteration_counts",
                "description": "  Sets the physics solver itertion counts for joint positions.\n\n  Args:\n  counts (Union[np.ndarray, torch.Tensor]): number of iterations for the solver. Shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_solver_position_iteration_counts(counts=counts,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_solver_velocity_iteration_counts",
                "description": "  Sets the physics solver itertion counts for joint velocities.\n\n  Args:\n  counts (Union[np.ndarray, torch.Tensor]): number of iterations for the solver. Shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_solver_velocity_iteration_counts(counts=counts,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_stabilization_thresholds",
                "description": "Sets the stabilizaion thresholds.\n\n  Args:\n  thresholds (Union[np.ndarray, torch.Tensor]): stabilization thresholds to be applied. Shape (M,).\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_stabilization_thresholds(thresholds=thresholds,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                        indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_velocities",
                "description": "Sets the linear and angular velocities of the prims in the view at once. The method does this through the physx API only.\n  i.e: It has to be called after initialization.\n\n  Args:\n  velocities (Optional[Union[np.ndarray, torch.Tensor]]): linear and angular velocities respectively to set the rigid prims to. shape is (M, 6).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_velocities(velocities=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                          indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets poses of prims in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "switch_control_mode",
                "description": " Switches control mode between velocity, position or effort.\n\n  Args:\n  mode (str): control mode to switch the articulations specified to. mode can be velocity, position or effort.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  joint_indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): joint indicies to specify which joints \n   to manipulate. Shape (K,).\n   Where K <= num of dofs.\n   Defaults to None (i.e: all dofs).\n  ",
                "snippet": "robot_view.switch_control_mode(mode=mode,  # str\n                               indices=None,  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n                               joint_indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "switch_dof_control_mode",
                "description": "Switches dof control mode between velocity, position or effort.\n\n  Args:\n  mode (str): control mode to switch the dof in articulations specified to. mode an be velocity, position or effort.\n  dof_index (int): dof index to swith the control mode of.\n  indices (Optional[Union[np.ndarray, List, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.switch_dof_control_mode(mode=mode,  # str\n                                   dof_index=dof_index,  # int\n                                   indices=None)  # typing.Union[numpy.ndarray, typing.List, torch.Tensor, NoneType]\n"
                },
                {
                "title": "apply_visual_materials",
                "description": "Used to apply visual material to the prims and optionally its prim descendants.\n\n  Args:\n  visual_materials (Union[VisualMaterial, List[VisualMaterial]]): visual materials to be applied to the prims. Currently supports\n  PreviewSurface, OmniPBR and OmniGlass. If a list is provided then\n  its size has to be equal the view's size or indices size. \n  If one material is provided it will be applied to all prims in the view.\n  weaker_than_descendants (Optional[Union[bool, List[bool]]], optional):  True if the material shouldn't override the descendants  \n  materials, otherwise False. Defaults to False. \n  If a list of visual materials is provided then a list\n  has to be provided with the same size for this arg as well.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Raises:\n  Exception: length of visual materials != length of prims indexed\n  Exception: length of visual materials != length of weaker descendants bools arg\n  ",
                "snippet": "robot_view.apply_visual_materials(visual_materials=visual_materials,  # typing.Union[omni.isaac.core.materials.visual_material.VisualMaterial, typing.List[omni.isaac.core.materials.visual_material.VisualMaterial]]\n                                  weaker_than_descendants=None,  # typing.Union[bool, typing.List[bool], NoneType]\n                                  indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_applied_visual_materials",
                "description": "\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[VisualMaterial]: a list of the current applied visual materials to the prims if its type is currently supported.\n  ",
                "snippet": "applied_visual_materials = robot_view.get_applied_visual_materials(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_default_state",
                "description": "  Returns:\n  XFormPrimViewState: returns the default state of the prims (positions and orientations) that is used after each reset.\n  ",
                "snippet": "default_state = robot_view.get_default_state()\n"
                },
                {
                "title": "get_local_poses",
                "description": "Gets prim poses in the view with respect to the local's frame (the prim's parent frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: \n  first index is translations in the local frame of the prims. shape is (M, 3). \n  second index is quaternion orientations in the local frame of the prims.\n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "local_poses = robot_view.get_local_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_local_scales",
                "description": "Gets prim scales in the view with respect to the local frame (the parent's frame).\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the local frame. shape is (M, 3).\n  ",
                "snippet": "local_scales = robot_view.get_local_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_visibilities",
                "description": "Returns the current visibilities of the prims in stage.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: Shape (M,) with type bool, where each item holds True \n   if the prim is visible in stage. False otherwise.\n  ",
                "snippet": "visibilities = robot_view.get_visibilities(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_poses",
                "description": " Returns the poses (positions and orientations) of the prims in the view with respect to the world frame.\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[Tuple[np.ndarray, np.ndarray], Tuple[torch.Tensor, torch.Tensor]]: first index is positions in the world frame of the prims. shape is (M, 3). \n   second index is quaternion orientations in the world frame of the prims.\n   quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  ",
                "snippet": "world_poses = robot_view.get_world_poses(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "get_world_scales",
                "description": "Gets prim scales in the view with respect to the world's frame.\n\n\n  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  Union[np.ndarray, torch.Tensor]: scales applied to the prim's dimensions in the world frame. shape is (M, 3).\n  ",
                "snippet": "world_scales = robot_view.get_world_scales(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "initialize",
                "description": "",
                "snippet": "robot_view.initialize(physics_sim_view=None)  # omni.physics.tensors.bindings._physicsTensors.SimulationView\n"
                },
                {
                "title": "is_valid",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  bool: True if all prim paths specified in the view correspond to a valid prim in stage. False otherwise.\n  ",
                "snippet": "robot_view.is_valid(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "is_visual_material_applied",
                "description": "  Args:\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n\n  Returns:\n  List[bool]: True if there is a visual material applied is applied to the corresponding prim in the view. False otherwise.\n  ",
                "snippet": "robot_view.is_visual_material_applied(indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "post_reset",
                "description": "Resets the prims to its default state (positions and orientations).\n  ",
                "snippet": "robot_view.post_reset()\n"
                },
                {
                "title": "set_default_state",
                "description": "Sets the default state of the prims (positions and orientations), that will be used after each reset.\n\n  Args:\n  positions (Optional[np.ndarray], optional):  positions in the world frame of the prim. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[np.ndarray], optional): quaternion orientations in the world frame of the prim. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_default_state(positions=None,  # typing.Union[numpy.ndarray, NoneType]\n                             orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                             indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_poses",
                "description": "Sets prim poses in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  translations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  translations in the local frame of the prims\n  (with respect to its parent prim). shape is (M, 3).\n  Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): \n  quaternion orientations in the local frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_local_poses(translations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_local_scales",
                "description": "Sets prim scales in the view with respect to the local frame (the prim's parent frame).\n\n  Args:\n  scales (Optional[Union[np.ndarray, torch.Tensor]]): scales to be applied to the prim's dimensions in the view. \n  shape is (M, 3).\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_local_scales(scales=scales,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                            indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_visibilities",
                "description": "Sets the visibilities of the prims in stage.\n\n  Args:\n  visibilities (Union[np.ndarray, torch.Tensor]): flag to set the visibilities of the usd prims in stage. \n  Shape (M,). Where M <= size of the encapsulated prims in the view.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to manipulate. Shape (M,).\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_visibilities(visibilities=visibilities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                            indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                },
                {
                "title": "set_world_poses",
                "description": "Sets prim poses in the view with respect to the world's frame.\n\n  Args:\n  positions (Optional[Union[np.ndarray, torch.Tensor]], optional): positions in the world frame of the prims. shape is (M, 3).\n   Defaults to None, which means left unchanged.\n  orientations (Optional[Union[np.ndarray, torch.Tensor]], optional): quaternion orientations in the world frame of the prims. \n  quaternion is scalar-first (w, x, y, z). shape is (M, 4).\n  Defaults to None, which means left unchanged.\n  indices (Optional[Union[np.ndarray, list, torch.Tensor]], optional): indicies to specify which prims \n   to query. Shape (M,).\n   Where M <= size of the encapsulated prims in the view.\n   Defaults to None (i.e: all prims in the view).\n  ",
                "snippet": "robot_view.set_world_poses(positions=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           orientations=None,  # typing.Union[numpy.ndarray, torch.Tensor, NoneType]\n                           indices=None)  # typing.Union[numpy.ndarray, list, torch.Tensor, NoneType]\n"
                }
                ]
                }
                ]
                },
                {
                "title": "Scenes",
                "snippets": [
                {
                "title": "Scene",
                "snippets": [
                {
                "title": "Scene",
                "description": "This class provides functions to add objects of interest in the stage to retrieve their information and set their \n reset default state in an easy way. For example: \n - performing certain commands post_reset\n - getting bounding boxes of the objects \n - Deleting the objects/ removing them from stage..etc.\n\n Checkout the required tutorials at \n https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html",
                "snippet": "scene = Scene()\n"
                },
                {
                "title": "add",
                "description": "[summary]\n\n  Args:\n  obj (XFormPrim): [description]\n\n  Raises:\n  Exception: [description]\n  Exception: [description]\n\n  Returns:\n  XFormPrim: [description]\n  ",
                "snippet": "scene.add(obj=obj)  # omni.isaac.core.prims.xform_prim.XFormPrim\n"
                },
                {
                "title": "add_default_ground_plane",
                "description": "[summary]\n\n  Args:\n  z_position (float, optional): [description]. Defaults to 0.\n  name (str, optional): [description]. Defaults to \"default_ground_plane\".\n  prim_path (str, optional): [description]. Defaults to \"/World/defaultGroundPlane\".\n  static_friction (float, optional): [description]. Defaults to 0.5.\n  dynamic_friction (float, optional): [description]. Defaults to 0.5.\n  restitution (float, optional): [description]. Defaults to 0.8.\n\n  Returns:\n  [type]: [description]\n  ",
                "snippet": "scene.add_default_ground_plane(z_position=0,  # float\n                               name=\"default_ground_plane\",\n                               prim_path=\"/World/defaultGroundPlane\",  # str\n                               static_friction=0.5,  # float\n                               dynamic_friction=0.5,  # float\n                               restitution=0.8)  # float\n"
                },
                {
                "title": "add_ground_plane",
                "description": "[summary]\n\n  Args:\n  size (Optional[float], optional): [description]. Defaults to None.\n  z_position (float, optional): [description]. Defaults to 0.\n  name (str, optional): [description]. Defaults to \"ground_plane\".\n  prim_path (str, optional): [description]. Defaults to \"/World/groundPlane\".\n  static_friction (float, optional): [description]. Defaults to 0.5.\n  dynamic_friction (float, optional): [description]. Defaults to 0.5.\n  restitution (float, optional): [description]. Defaults to 0.8.\n  color (Optional[np.ndarray], optional): [description]. Defaults to None.\n\n  Returns:\n  [type]: [description]\n  ",
                "snippet": "scene.add_ground_plane(size=None,  # typing.Union[float, NoneType]\n                       z_position=0,  # float\n                       name=\"ground_plane\",\n                       prim_path=\"/World/groundPlane\",  # str\n                       static_friction=0.5,  # float\n                       dynamic_friction=0.5,  # float\n                       restitution=0.8,  # float\n                       color=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "clear",
                "description": "Clears the stage from all added objects to the Scene.\n\n  Args:\n  registry_only (bool, optional): True to remove the object from the scene registery only and not the USD. Defaults to False.\n  ",
                "snippet": "scene.clear(registry_only=False)  # bool\n"
                },
                {
                "title": "compute_object_AABB",
                "description": "[summary]\n\n  Args:\n  name (str): [description]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  Tuple[np.ndarray, np.ndarray]: [description]\n  ",
                "snippet": "scene.compute_object_AABB(name=name)  # str\n"
                },
                {
                "title": "disable_bounding_boxes_computations",
                "description": "[summary]\n  ",
                "snippet": "scene.disable_bounding_boxes_computations()\n"
                },
                {
                "title": "enable_bounding_boxes_computations",
                "description": "[summary]\n  ",
                "snippet": "scene.enable_bounding_boxes_computations()\n"
                },
                {
                "title": "get_object",
                "description": "[summary]\n\n  Args:\n  name (Optional[str], optional): [description]. Defaults to None.\n  prim_path (Optional[str], optional): [description]. Defaults to None.\n\n  Returns:\n  XFormPrim: [description]\n  ",
                "snippet": "object = scene.get_object(name=name)  # str\n"
                },
                {
                "title": "object_exists",
                "description": "[summary]\n\n  Args:\n  name (str): [description]\n\n  Returns:\n  XFormPrim: [description]\n  ",
                "snippet": "scene.object_exists(name=name)  # str\n"
                },
                {
                "title": "post_reset",
                "description": "calls post_reset on all added objects to the Scene Registery.\n  ",
                "snippet": "scene.post_reset()\n"
                },
                {
                "title": "remove_object",
                "description": "[summary]\n\n  Args:\n  name (str): Name of the prim to be removed. Defaults to None.\n  registry_only (bool, optional): True to remove the object from the scene registery only and not the USD. Defaults to False.\n  ",
                "snippet": "scene.remove_object(name=name,  # str\n                    registry_only=False)  # bool\n"
                }
                ]
                },
                {
                "title": "SceneRegistry",
                "snippets": [
                {
                "title": "SceneRegistry",
                "description": "",
                "snippet": "scene_registry = SceneRegistry()\n"
                },
                {
                "title": "add_articulated_system",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  articulated_system (Articulation): [description]\n  ",
                "snippet": "scene_registry.add_articulated_system(name=name,\n                                      articulated_system=articulated_system)  # omni.isaac.core.articulations.articulation.Articulation\n"
                },
                {
                "title": "add_articulated_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  articulated_view (ArticulationView): [description]\n  ",
                "snippet": "scene_registry.add_articulated_view(name=name,\n                                    articulated_view=articulated_view)  # omni.isaac.core.articulations.articulation_view.ArticulationView\n"
                },
                {
                "title": "add_cloth",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  cloth (ClothPrim): [description]\n  ",
                "snippet": "scene_registry.add_cloth(name=name,\n                         cloth=cloth)  # omni.isaac.core.prims.soft.cloth_prim.ClothPrim\n"
                },
                {
                "title": "add_cloth_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (ClothPrimView): [description]\n  ",
                "snippet": "scene_registry.add_cloth_view(name=name,\n                              cloth_prim_view=cloth_prim_view)  # omni.isaac.core.prims.soft.cloth_prim_view.ClothPrimView\n"
                },
                {
                "title": "add_geometry_object",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (GeometryPrim): [description]\n  ",
                "snippet": "scene_registry.add_geometry_object(name=name,\n                                   geometry_object=geometry_object)  # omni.isaac.core.prims.geometry_prim.GeometryPrim\n"
                },
                {
                "title": "add_geometry_prim_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (GeometryPrim): [description]\n  ",
                "snippet": "scene_registry.add_geometry_prim_view(name=name,\n                                      geometry_prim_view=geometry_prim_view)  # omni.isaac.core.prims.geometry_prim_view.GeometryPrimView\n"
                },
                {
                "title": "add_particle_material",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (ParticleMaterial): [description]\n  ",
                "snippet": "scene_registry.add_particle_material(name=name,\n                                     particle_material=particle_material)  # omni.isaac.core.materials.particle_material.ParticleMaterial\n"
                },
                {
                "title": "add_particle_material_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (ParticleMaterialView): [description]\n  ",
                "snippet": "scene_registry.add_particle_material_view(name=name,\n                                          particle_material_view=particle_material_view)  # omni.isaac.core.materials.particle_material_view.ParticleMaterialView\n"
                },
                {
                "title": "add_particle_system",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (ParticleSystemView): [description]\n  ",
                "snippet": "scene_registry.add_particle_system(name=name,\n                                   particle_system=particle_system)  # omni.isaac.core.prims.soft.particle_system.ParticleSystem\n"
                },
                {
                "title": "add_particle_system_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (ParticleSystemView): [description]\n  ",
                "snippet": "scene_registry.add_particle_system_view(name=name,\n                                        particle_system_view=particle_system_view)  # omni.isaac.core.prims.soft.particle_system_view.ParticleSystemView\n"
                },
                {
                "title": "add_rigid_contact_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  rigid_contact_views (RigidContactView): [description]\n  ",
                "snippet": "scene_registry.add_rigid_contact_view(name=name,\n                                      rigid_contact_view=rigid_contact_view)  # omni.isaac.core.prims.rigid_contact_view.RigidContactView\n"
                },
                {
                "title": "add_rigid_object",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  rigid_object (RigidPrim): [description]\n  ",
                "snippet": "scene_registry.add_rigid_object(name=name,\n                                rigid_object=rigid_object)  # omni.isaac.core.prims.rigid_prim.RigidPrim\n"
                },
                {
                "title": "add_rigid_prim_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  rigid_object (RigidPrim): [description]\n  ",
                "snippet": "scene_registry.add_rigid_prim_view(name=name,\n                                   rigid_prim_view=rigid_prim_view)  # omni.isaac.core.prims.rigid_prim_view.RigidPrimView\n"
                },
                {
                "title": "add_robot",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  robot (Robot): [description]\n  ",
                "snippet": "scene_registry.add_robot(name=name,\n                         robot=robot)  # omni.isaac.core.robots.robot.Robot\n"
                },
                {
                "title": "add_robot_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (GeometryPrim): [description]\n  ",
                "snippet": "scene_registry.add_robot_view(name=name,\n                              robot_view=robot_view)  # omni.isaac.core.robots.robot_view.RobotView\n"
                },
                {
                "title": "add_sensor",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  sensor (BaseSensor): [description]\n  ",
                "snippet": "scene_registry.add_sensor(name=name,\n                          sensor=sensor)  # omni.isaac.core.prims.base_sensor.BaseSensor\n"
                },
                {
                "title": "add_xform",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  robot (Robot): [description]\n  ",
                "snippet": "scene_registry.add_xform(name=name,\n                         xform=xform)  # omni.isaac.core.prims.xform_prim.XFormPrim\n"
                },
                {
                "title": "add_xform_view",
                "description": "[summary]\n\n  Args:\n  name ([type]): [description]\n  geometry_object (GeometryPrim): [description]\n  ",
                "snippet": "scene_registry.add_xform_view(name=name,\n                              xform_prim_view=xform_prim_view)  # omni.isaac.core.prims.xform_prim_view.XFormPrimView\n"
                },
                {
                "title": "get_object",
                "description": "[summary]\n\n  Args:\n  name (Optional[str], optional): [description]. Defaults to None.\n  prim_path (Optional[str], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  XFormPrim: [description]\n  ",
                "snippet": "object = scene_registry.get_object(name=name)  # str\n"
                },
                {
                "title": "name_exists",
                "description": "[summary]\n\n  Args:\n  name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "scene_registry.name_exists(name=name)  # str\n"
                },
                {
                "title": "remove_object",
                "description": "[summary]\n\n  Args:\n  name (Optional[str], optional): [description]. Defaults to None.\n  prim_path (Optional[str], optional): [description]. Defaults to None.\n\n  Raises:\n  Exception: [description]\n  Exception: [description]\n  NotImplementedError: [description]\n  Exception: [description]\n  ",
                "snippet": "scene_registry.remove_object(name=name)  # str\n"
                }
                ]
                }
                ]
                },
                {
                "title": "SimulationContext",
                "snippets": [
                {
                "title": "SimulationContext",
                "description": " This class provide functions that take care of many time-related events such as\n perform a physics or a render step for instance. Adding/ removing callback functions that \n gets triggered with certain events such as a physics step, timeline event \n (pause or play..etc), stage open/ close..etc.\n\n It also includes an instance of PhysicsContext which takes care of many physics related\n settings such as setting physics dt, solver type..etc.\n\n Args:\n physics_dt (Optional[float], optional): dt between physics steps. Defaults to None.\n rendering_dt (Optional[float], optional): dt between rendering steps. Note: rendering means \n rendering a frame of the current application and not \n only rendering a frame to the viewports/ cameras. So UI\n elements of Isaac Sim will be refereshed with this dt \n as well if running non-headless. \n Defaults to None.\n stage_units_in_meters (Optional[float], optional): The metric units of assets. This will affect gravity value..etc.\n Defaults to None.\n physics_prim_path (Optional[str], optional): specifies the prim path to create a PhysicsScene at, \n only in the case where no PhysicsScene already defined. \n Defaults to \"/physicsScene\".\n set_defaults (bool, optional): set to True to use the defaults settings\n [physics_dt = 1.0/ 60.0,\n stage units in meters = 0.01 (i.e in cms),\n rendering_dt = 1.0 / 60.0,\n gravity = -9.81 m / s\n ccd_enabled,\n stabilization_enabled,\n gpu dynamics turned off,\n broadcast type is MBP,\n solver type is TGS]. Defaults to True.\n backend (str, optional): specifies the backend to be used (numpy or torch). Defaults to numpy.\n device (Optional[str], optional): specifies the device to be used if running on the gpu with torch backend.\n\n ",
                "snippet": "simulation_context = SimulationContext(physics_dt=None,  # typing.Union[float, NoneType]\n                                       rendering_dt=None,  # typing.Union[float, NoneType]\n                                       stage_units_in_meters=None,  # typing.Union[float, NoneType]\n                                       physics_prim_path=\"/physicsScene\",  # str\n                                       sim_params=None,  # dict\n                                       set_defaults=True,  # bool\n                                       backend=\"numpy\",  # str\n                                       device=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "add_physics_callback",
                "description": "Adds a callback which will be called before each physics step.\n   callback_fn should take an argument of step_size: float\n\n  Args:\n  callback_name (str): should be unique.\n  callback_fn (Callable[[float], None]): [description]\n  ",
                "snippet": "simulation_context.add_physics_callback(callback_name=callback_name,  # str\n                                        callback_fn=callback_fn)  # typing.Callable[[float], NoneType]\n"
                },
                {
                "title": "add_render_callback",
                "description": "Adds a callback which will be called after each rendering event such as .render().\n   callback_fn should take an argument of event\n\n  Args:\n  callback_name (str): [description]\n  callback_fn (Callable): [description]\n  ",
                "snippet": "simulation_context.add_render_callback(callback_name=callback_name,  # str\n                                       callback_fn=callback_fn)  # typing.Callable\n"
                },
                {
                "title": "add_stage_callback",
                "description": "Adds a callback which will be called after each stage event such as open/close.\n   callback_fn should take an argument of event\n\n  Args:\n  callback_name (str): [description]\n  callback_fn (Callable[[omni.usd.StageEvent], None]): [description]\n  ",
                "snippet": "simulation_context.add_stage_callback(callback_name=callback_name,  # str\n                                      callback_fn=callback_fn)  # typing.Callable\n"
                },
                {
                "title": "add_timeline_callback",
                "description": "Adds a callback which will be called after each timeline event such as play/pause.\n   callback_fn should take an argument of event\n\n  Args:\n  callback_name (str): [description]\n  callback_fn (Callable[[omni.timeline.TimelineEvent], None]): [description]\n  ",
                "snippet": "simulation_context.add_timeline_callback(callback_name=callback_name,  # str\n                                         callback_fn=callback_fn)  # typing.Callable\n"
                },
                {
                "title": "clear",
                "description": "Clears the current stage leaving the PhysicsScene only if under /World.",
                "snippet": "simulation_context.clear()\n"
                },
                {
                "title": "clear_all_callbacks",
                "description": "Clears all callbacks which were added using add_*_callback fn.\n  ",
                "snippet": "simulation_context.clear_all_callbacks()\n"
                },
                {
                "title": "clear_physics_callbacks",
                "description": "[summary]\n  ",
                "snippet": "simulation_context.clear_physics_callbacks()\n"
                },
                {
                "title": "clear_render_callbacks",
                "description": "[summary]\n  ",
                "snippet": "simulation_context.clear_render_callbacks()\n"
                },
                {
                "title": "clear_stage_callbacks",
                "description": "[summary]\n  ",
                "snippet": "simulation_context.clear_stage_callbacks()\n"
                },
                {
                "title": "clear_timeline_callbacks",
                "description": "[summary]\n  ",
                "snippet": "simulation_context.clear_timeline_callbacks()\n"
                },
                {
                "title": "get_physics_context",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  PhysicsContext: [description]\n  ",
                "snippet": "physics_context = simulation_context.get_physics_context()\n"
                },
                {
                "title": "get_physics_dt",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: current physics dt of the PhysicsContext\n  ",
                "snippet": "physics_dt = simulation_context.get_physics_dt()\n"
                },
                {
                "title": "get_rendering_dt",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: current rendering dt\n  ",
                "snippet": "rendering_dt = simulation_context.get_rendering_dt()\n"
                },
                {
                "title": "initialize_physics",
                "description": "",
                "snippet": "simulation_context.initialize_physics()\n"
                },
                {
                "title": "initialize_simulation_context_async",
                "description": "",
                "snippet": "simulation_context.initialize_simulation_context_async()\n"
                },
                {
                "title": "is_playing",
                "description": "Returns: True if the simulator is playing.",
                "snippet": "simulation_context.is_playing()\n"
                },
                {
                "title": "is_simulating",
                "description": "Returns: True if physics simulation is happening.\n\n  Note:\n  Can return True if start_simulation is called even if play was pressed/ called.\n\n  Deprecated:\n  With deprecation of Dynamic Control Toolbox, this function is not needed.\n  ",
                "snippet": "simulation_context.is_simulating()\n"
                },
                {
                "title": "is_stopped",
                "description": "Returns: True if the simulator is stopped.",
                "snippet": "simulation_context.is_stopped()\n"
                },
                {
                "title": "pause",
                "description": "Pauses the physics simulation",
                "snippet": "simulation_context.pause()\n"
                },
                {
                "title": "pause_async",
                "description": "Pauses the physics simulation",
                "snippet": "simulation_context.pause_async()\n"
                },
                {
                "title": "physics_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "simulation_context.physics_callback_exists(callback_name=callback_name)  # str\n"
                },
                {
                "title": "play",
                "description": "Start playing simulation.\n\n  Note:\n   it does one step internally to propagate all physics handles properly.\n  ",
                "snippet": "simulation_context.play()\n"
                },
                {
                "title": "play_async",
                "description": "Starts playing simulation.",
                "snippet": "simulation_context.play_async()\n"
                },
                {
                "title": "remove_physics_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "simulation_context.remove_physics_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "remove_render_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "simulation_context.remove_render_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "remove_stage_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "simulation_context.remove_stage_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "remove_timeline_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "simulation_context.remove_timeline_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "render",
                "description": "Refreshes the Isaac Sim app rendering components including UI elements and view ports..etc.\n  ",
                "snippet": "simulation_context.render()\n"
                },
                {
                "title": "render_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "simulation_context.render_callback_exists(callback_name=callback_name)  # str\n"
                },
                {
                "title": "reset",
                "description": "Resets the physics simulation view.\n\n  Args:\n  soft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects. \n  ",
                "snippet": "simulation_context.reset(soft=False)  # bool\n"
                },
                {
                "title": "reset_async",
                "description": "Resets the physics simulation view (asynchornous version).\n\n  Args:\n  soft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects. \n  ",
                "snippet": "simulation_context.reset_async(soft=False)  # bool\n"
                },
                {
                "title": "set_simulation_dt",
                "description": "Specify the physics step and rendering step size to use when stepping and rendering. It is recommended that the two values are divisible. \n\n  Args:\n  physics_dt (float): The physics time-step. None means it won't change the current setting. (default: None).\n  rendering_dt (float):  The rendering time-step. None means it won't change the current setting. (default: None)\n  ",
                "snippet": "simulation_context.set_simulation_dt(physics_dt=None,  # typing.Union[float, NoneType]\n                                     rendering_dt=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "stage_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "simulation_context.stage_callback_exists(callback_name=callback_name)  # str\n"
                },
                {
                "title": "step",
                "description": "Steps the physics simulation while rendering or without.\n\n  Args:\n  render (bool, optional): Set to False to only do a physics simulation without rendering. Note:\n   app UI will be frozen (since its not rendering) in this case.\n   Defaults to True.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "simulation_context.step(render=True)  # bool\n"
                },
                {
                "title": "stop",
                "description": "Stops the physics simulation",
                "snippet": "simulation_context.stop()\n"
                },
                {
                "title": "stop_async",
                "description": "Stops the physics simulation",
                "snippet": "simulation_context.stop_async()\n"
                },
                {
                "title": "timeline_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "simulation_context.timeline_callback_exists(callback_name=callback_name)  # str\n"
                }
                ]
                },
                {
                "title": "World",
                "snippets": [
                {
                "title": "World",
                "description": " This class inherits from SimulationContext which provides the following.\n\n SimulationContext provide functions that take care of many time-related events such as\n perform a physics or a render step for instance. Adding/ removing callback functions that \n gets triggered with certain events such as a physics step, timeline event \n (pause or play..etc), stage open/ close..etc.\n\n It also includes an instance of PhysicsContext which takes care of many physics related\n settings such as setting physics dt, solver type..etc.\n \n In addition to what is provided from SimulationContext, this class allows the user to add a \n task to the world and it contains a scene object.\n \n To control the default reset state of different objects easily, the object could be added to\n a Scene. Besides this, the object is bound to a short keyword that fascilitates objects retrievals,\n like in a dict.\n\n Checkout the required tutorials at \n https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html\n\n Args:\n physics_dt (Optional[float], optional): dt between physics steps. Defaults to None.\n rendering_dt (Optional[float], optional): dt between rendering steps. Note: rendering means \n rendering a frame of the current application and not \n only rendering a frame to the viewports/ cameras. So UI\n elements of Isaac Sim will be refereshed with this dt \n as well if running non-headless. \n Defaults to None.\n stage_units_in_meters (Optional[float], optional): The metric units of assets. This will affect gravity value..etc.\n Defaults to None.\n physics_prim_path (Optional[str], optional): specifies the prim path to create a PhysicsScene at, \n only in the case where no PhysicsScene already defined. \n Defaults to \"/physicsScene\".\n set_defaults (bool, optional): set to True to use the defaults settings\n [physics_dt = 1.0/ 60.0,\n stage units in meters = 0.01 (i.e in cms),\n rendering_dt = 1.0 / 60.0,\n gravity = -9.81 m / s\n ccd_enabled,\n stabilization_enabled,\n gpu dynamics turned off,\n broadcast type is MBP,\n solver type is TGS]. Defaults to True.\n backend (str, optional): specifies the backend to be used (numpy or torch). Defaults to numpy.\n device (Optional[str], optional): specifies the device to be used if running on the gpu with torch backend.\n ",
                "snippet": "world = World(physics_dt=None,  # typing.Union[float, NoneType]\n              rendering_dt=None,  # typing.Union[float, NoneType]\n              stage_units_in_meters=None,  # typing.Union[float, NoneType]\n              physics_prim_path=\"/physicsScene\",  # str\n              sim_params=None,  # dict\n              set_defaults=True,  # bool\n              backend=\"numpy\",  # str\n              device=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "add_task",
                "description": "Tasks should have a unique name.\n\n\n  Args:\n  task (BaseTask): [description]\n  ",
                "snippet": "world.add_task(task=task)  # omni.isaac.core.tasks.base_task.BaseTask\n"
                },
                {
                "title": "calculate_metrics",
                "description": "Gets metrics from all the tasks that were added\n\n  Args:\n  task_name (Optional[str], optional): [description]. Defaults to None.\n\n  Returns:\n  [type]: [description]\n  ",
                "snippet": "world.calculate_metrics(task_name=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "clear",
                "description": "Clears the stage leaving the PhysicsScene only if under /World.\n  ",
                "snippet": "world.clear()\n"
                },
                {
                "title": "get_current_tasks",
                "description": "[summary]\n\n  Returns:\n  List[BaseTask]: [description]\n  ",
                "snippet": "current_tasks = world.get_current_tasks()\n"
                },
                {
                "title": "get_data_logger",
                "description": "Returns the data logger of the world.\n\n  Returns:\n  DataLogger: [description]\n  ",
                "snippet": "data_logger = world.get_data_logger()\n"
                },
                {
                "title": "get_observations",
                "description": "Gets observations from all the tasks that were added\n\n  Args:\n  task_name (Optional[str], optional): [description]. Defaults to None.\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = world.get_observations(task_name=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "get_task",
                "description": "",
                "snippet": "task = world.get_task(name=name)  # str\n"
                },
                {
                "title": "initialize_physics",
                "description": "_summary_\n  ",
                "snippet": "world.initialize_physics()\n"
                },
                {
                "title": "is_done",
                "description": "[summary]\n\n  Args:\n  task_name (Optional[str], optional): [description]. Defaults to None.\n\n  Returns:\n  [type]: [description]\n  ",
                "snippet": "world.is_done(task_name=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "is_tasks_scene_built",
                "description": "",
                "snippet": "world.is_tasks_scene_built()\n"
                },
                {
                "title": "reset",
                "description": " Resets the stage to its initial state and each object included in the Scene to its default state\n  as specified by .set_default_state and the __init__ funcs. \n\n  Note:\n  - All tasks should be added before the first reset is called unless a .clear() was called. \n  - All articulations should be added before the first reset is called unless a .clear() was called. \n  - This method takes care of initializing articulation handles with the first reset called.\n  - This will do one step internally regardless\n  - calls post_reset on each object in the Scene\n  - calls post_reset on each Task\n\n  things like setting pd gains for instance should happend at a Task reset or a Robot reset since\n  the defaults are restored after .stop() is called.\n\n  Args:\n  soft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects. \n  ",
                "snippet": "world.reset(soft=False)  # bool\n"
                },
                {
                "title": "reset_async",
                "description": "Resets the stage to its initial state and each object included in the Scene to its default state\n  as specified by .set_default_state and the __init__ funcs. \n\n  Note:\n  - All tasks should be added before the first reset is called unless a .clear() was called. \n  - All articulations should be added before the first reset is called unless a .clear() was called. \n  - This method takes care of initializing articulation handles with the first reset called.\n  - This will do one step internally regardless\n  - calls post_reset on each object in the Scene\n  - calls post_reset on each Task\n\n  things like setting pd gains for instance should happend at a Task reset or a Robot reset since\n  the defaults are restored after .stop() is called.\n\n  Args:\n  soft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects. \n  ",
                "snippet": "world.reset_async(soft=False)  # bool\n"
                },
                {
                "title": "step",
                "description": "Steps the physics simulation while rendering or without.\n\n   - Note: task pre_step is called here.\n\n  Args:\n  render (bool, optional): Set to False to only do a physics simulation without rendering. Note:\n   app UI will be frozen (since its not rendering) in this case. \n   Defaults to True.\n\n  ",
                "snippet": "world.step(render=True,  # bool\n           step_sim=True)  # bool\n"
                },
                {
                "title": "step_async",
                "description": "Calls all functions that should be called pre stepping the physics\n\n   - Note: task pre_step is called here.\n\n  Args:\n  step_size (float): [description]\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "world.step_async(step_size=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "add_physics_callback",
                "description": "Adds a callback which will be called before each physics step.\n   callback_fn should take an argument of step_size: float\n\n  Args:\n  callback_name (str): should be unique.\n  callback_fn (Callable[[float], None]): [description]\n  ",
                "snippet": "world.add_physics_callback(callback_name=callback_name,  # str\n                           callback_fn=callback_fn)  # typing.Callable[[float], NoneType]\n"
                },
                {
                "title": "add_render_callback",
                "description": "Adds a callback which will be called after each rendering event such as .render().\n   callback_fn should take an argument of event\n\n  Args:\n  callback_name (str): [description]\n  callback_fn (Callable): [description]\n  ",
                "snippet": "world.add_render_callback(callback_name=callback_name,  # str\n                          callback_fn=callback_fn)  # typing.Callable\n"
                },
                {
                "title": "add_stage_callback",
                "description": "Adds a callback which will be called after each stage event such as open/close.\n   callback_fn should take an argument of event\n\n  Args:\n  callback_name (str): [description]\n  callback_fn (Callable[[omni.usd.StageEvent], None]): [description]\n  ",
                "snippet": "world.add_stage_callback(callback_name=callback_name,  # str\n                         callback_fn=callback_fn)  # typing.Callable\n"
                },
                {
                "title": "add_timeline_callback",
                "description": "Adds a callback which will be called after each timeline event such as play/pause.\n   callback_fn should take an argument of event\n\n  Args:\n  callback_name (str): [description]\n  callback_fn (Callable[[omni.timeline.TimelineEvent], None]): [description]\n  ",
                "snippet": "world.add_timeline_callback(callback_name=callback_name,  # str\n                            callback_fn=callback_fn)  # typing.Callable\n"
                },
                {
                "title": "clear",
                "description": "Clears the current stage leaving the PhysicsScene only if under /World.",
                "snippet": "world.clear()\n"
                },
                {
                "title": "clear_all_callbacks",
                "description": "Clears all callbacks which were added using add_*_callback fn.\n  ",
                "snippet": "world.clear_all_callbacks()\n"
                },
                {
                "title": "clear_physics_callbacks",
                "description": "[summary]\n  ",
                "snippet": "world.clear_physics_callbacks()\n"
                },
                {
                "title": "clear_render_callbacks",
                "description": "[summary]\n  ",
                "snippet": "world.clear_render_callbacks()\n"
                },
                {
                "title": "clear_stage_callbacks",
                "description": "[summary]\n  ",
                "snippet": "world.clear_stage_callbacks()\n"
                },
                {
                "title": "clear_timeline_callbacks",
                "description": "[summary]\n  ",
                "snippet": "world.clear_timeline_callbacks()\n"
                },
                {
                "title": "get_physics_context",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  PhysicsContext: [description]\n  ",
                "snippet": "physics_context = world.get_physics_context()\n"
                },
                {
                "title": "get_physics_dt",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: current physics dt of the PhysicsContext\n  ",
                "snippet": "physics_dt = world.get_physics_dt()\n"
                },
                {
                "title": "get_rendering_dt",
                "description": "[summary]\n\n  Raises:\n  Exception: [description]\n\n  Returns:\n  float: current rendering dt\n  ",
                "snippet": "rendering_dt = world.get_rendering_dt()\n"
                },
                {
                "title": "initialize_physics",
                "description": "",
                "snippet": "world.initialize_physics()\n"
                },
                {
                "title": "initialize_simulation_context_async",
                "description": "",
                "snippet": "world.initialize_simulation_context_async()\n"
                },
                {
                "title": "is_playing",
                "description": "Returns: True if the simulator is playing.",
                "snippet": "world.is_playing()\n"
                },
                {
                "title": "is_simulating",
                "description": "Returns: True if physics simulation is happening.\n\n  Note:\n  Can return True if start_simulation is called even if play was pressed/ called.\n\n  Deprecated:\n  With deprecation of Dynamic Control Toolbox, this function is not needed.\n  ",
                "snippet": "world.is_simulating()\n"
                },
                {
                "title": "is_stopped",
                "description": "Returns: True if the simulator is stopped.",
                "snippet": "world.is_stopped()\n"
                },
                {
                "title": "pause",
                "description": "Pauses the physics simulation",
                "snippet": "world.pause()\n"
                },
                {
                "title": "pause_async",
                "description": "Pauses the physics simulation",
                "snippet": "world.pause_async()\n"
                },
                {
                "title": "physics_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "world.physics_callback_exists(callback_name=callback_name)  # str\n"
                },
                {
                "title": "play",
                "description": "Start playing simulation.\n\n  Note:\n   it does one step internally to propagate all physics handles properly.\n  ",
                "snippet": "world.play()\n"
                },
                {
                "title": "play_async",
                "description": "Starts playing simulation.",
                "snippet": "world.play_async()\n"
                },
                {
                "title": "remove_physics_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "world.remove_physics_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "remove_render_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "world.remove_render_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "remove_stage_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "world.remove_stage_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "remove_timeline_callback",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n  ",
                "snippet": "world.remove_timeline_callback(callback_name=callback_name)  # str\n"
                },
                {
                "title": "render",
                "description": "Refreshes the Isaac Sim app rendering components including UI elements and view ports..etc.\n  ",
                "snippet": "world.render()\n"
                },
                {
                "title": "render_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "world.render_callback_exists(callback_name=callback_name)  # str\n"
                },
                {
                "title": "reset",
                "description": "Resets the physics simulation view.\n\n  Args:\n  soft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects. \n  ",
                "snippet": "world.reset(soft=False)  # bool\n"
                },
                {
                "title": "reset_async",
                "description": "Resets the physics simulation view (asynchornous version).\n\n  Args:\n  soft (bool, optional): if set to True simulation won't be stopped and start again. It only calls the reset on the scene objects. \n  ",
                "snippet": "world.reset_async(soft=False)  # bool\n"
                },
                {
                "title": "set_simulation_dt",
                "description": "Specify the physics step and rendering step size to use when stepping and rendering. It is recommended that the two values are divisible. \n\n  Args:\n  physics_dt (float): The physics time-step. None means it won't change the current setting. (default: None).\n  rendering_dt (float):  The rendering time-step. None means it won't change the current setting. (default: None)\n  ",
                "snippet": "world.set_simulation_dt(physics_dt=None,  # typing.Union[float, NoneType]\n                        rendering_dt=None)  # typing.Union[float, NoneType]\n"
                },
                {
                "title": "stage_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "world.stage_callback_exists(callback_name=callback_name)  # str\n"
                },
                {
                "title": "step",
                "description": "Steps the physics simulation while rendering or without.\n\n  Args:\n  render (bool, optional): Set to False to only do a physics simulation without rendering. Note:\n   app UI will be frozen (since its not rendering) in this case.\n   Defaults to True.\n\n  Raises:\n  Exception: [description]\n  ",
                "snippet": "world.step(render=True)  # bool\n"
                },
                {
                "title": "stop",
                "description": "Stops the physics simulation",
                "snippet": "world.stop()\n"
                },
                {
                "title": "stop_async",
                "description": "Stops the physics simulation",
                "snippet": "world.stop_async()\n"
                },
                {
                "title": "timeline_callback_exists",
                "description": "[summary]\n\n  Args:\n  callback_name (str): [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "world.timeline_callback_exists(callback_name=callback_name)  # str\n"
                }
                ]
                },
                {
                "title": "Tasks",
                "snippets": [
                {
                "title": "BaseTask",
                "snippets": [
                {
                "title": "BaseTask",
                "description": "This class provides a way to set up a task in a scene and modularize adding objects to stage,\n getting observations needed for the behavioral layer, caclulating metrics needed about the task,\n calling certain things pre-stepping, creating multiple tasks at the same time and much more.\n\n Checkout the required tutorials at \n https://docs.omniverse.nvidia.com/app_isaacsim/app_isaacsim/overview.html\n\n Args:\n name (str): needs to be unique if added to the World.\n offset (Optional[np.ndarray], optional): offset applied to all assets of the task.\n ",
                "snippet": "base_task = BaseTask(name=name,  # str\n                     offset=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "base_task.calculate_metrics()\n"
                },
                {
                "title": "cleanup",
                "description": "Called before calling a reset() on the world to removed temporarly objects that were added during\n   simulation for instance.\n  ",
                "snippet": "base_task.cleanup()\n"
                },
                {
                "title": "get_description",
                "description": "[summary]\n\n  Returns:\n  str: [description]\n  ",
                "snippet": "description = base_task.get_description()\n"
                },
                {
                "title": "get_observations",
                "description": "Returns current observations from the objects needed for the behavioral layer.\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = base_task.get_observations()\n"
                },
                {
                "title": "get_params",
                "description": "Gets the parameters of the task.\n   This is defined differently for each task in order to access the task's objects and values.\n   Note that this is different from get_observations. \n   Things like the robot name, block name..etc can be defined here for faster retrieval. \n   should have the form of params_representation[\"param_name\"] = {\"value\": param_value, \"modifiable\": bool}\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: defined parameters of the task.\n  ",
                "snippet": "params = base_task.get_params()\n"
                },
                {
                "title": "get_task_objects",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "task_objects = base_task.get_task_objects()\n"
                },
                {
                "title": "is_done",
                "description": "Returns True of the task is done.\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "base_task.is_done()\n"
                },
                {
                "title": "post_reset",
                "description": "Calls while doing a .reset() on the world.\n  ",
                "snippet": "base_task.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "called before stepping the physics simulation.\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "base_task.pre_step(time_step_index=time_step_index,  # int\n                   simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "set_params",
                "description": "Changes the modifiable paramateres of the task\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "base_task.set_params()\n"
                },
                {
                "title": "set_up_scene",
                "description": "Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\n   to the task_objects happens here.\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "base_task.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                }
                ]
                },
                {
                "title": "FollowTarget",
                "snippets": [
                {
                "title": "FollowTarget",
                "description": "[summary]\n\n Args:\n name (str): [description]\n target_prim_path (Optional[str], optional): [description]. Defaults to None.\n target_name (Optional[str], optional): [description]. Defaults to None.\n target_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n target_orientation (Optional[np.ndarray], optional): [description]. Defaults to None.\n offset (Optional[np.ndarray], optional): [description]. Defaults to None.\n ",
                "snippet": "follow_target = FollowTarget(name=name,  # str\n                             target_prim_path=None,  # typing.Union[str, NoneType]\n                             target_name=None,  # typing.Union[str, NoneType]\n                             target_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                             target_orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                             offset=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "add_obstacle",
                "description": "[summary]\n\n  Args:\n  position (np.ndarray, optional): [description]. Defaults to np.array([0.1, 0.1, 1.0]).\n  ",
                "snippet": "follow_target.add_obstacle(position=None)  # numpy.ndarray\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n  ",
                "snippet": "follow_target.calculate_metrics()\n"
                },
                {
                "title": "cleanup",
                "description": "[summary]\n  ",
                "snippet": "follow_target.cleanup()\n"
                },
                {
                "title": "get_observations",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = follow_target.get_observations()\n"
                },
                {
                "title": "get_obstacle_to_delete",
                "description": "[summary]\n\n  Returns:\n  [type]: [description]\n  ",
                "snippet": "obstacle_to_delete = follow_target.get_obstacle_to_delete()\n"
                },
                {
                "title": "get_params",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "params = follow_target.get_params()\n"
                },
                {
                "title": "is_done",
                "description": "[summary]\n  ",
                "snippet": "follow_target.is_done()\n"
                },
                {
                "title": "obstacles_exist",
                "description": "[summary]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "follow_target.obstacles_exist()\n"
                },
                {
                "title": "post_reset",
                "description": "[summary]\n  ",
                "snippet": "follow_target.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "[summary]\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "follow_target.pre_step(time_step_index=time_step_index,  # int\n                       simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "remove_obstacle",
                "description": "[summary]\n\n  Args:\n  name (Optional[str], optional): [description]. Defaults to None.\n  ",
                "snippet": "follow_target.remove_obstacle(name=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "set_params",
                "description": "[summary]\n\n  Args:\n  target_prim_path (Optional[str], optional): [description]. Defaults to None.\n  target_name (Optional[str], optional): [description]. Defaults to None.\n  target_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n  target_orientation (Optional[np.ndarray], optional): [description]. Defaults to None.\n  ",
                "snippet": "follow_target.set_params(target_prim_path=None,  # typing.Union[str, NoneType]\n                         target_name=None,  # typing.Union[str, NoneType]\n                         target_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                         target_orientation=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_robot",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "follow_target.set_robot()\n"
                },
                {
                "title": "set_up_scene",
                "description": "[summary]\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "follow_target.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                },
                {
                "title": "target_reached",
                "description": "[summary]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "follow_target.target_reached()\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "follow_target.calculate_metrics()\n"
                },
                {
                "title": "cleanup",
                "description": "Called before calling a reset() on the world to removed temporarly objects that were added during\n   simulation for instance.\n  ",
                "snippet": "follow_target.cleanup()\n"
                },
                {
                "title": "get_description",
                "description": "[summary]\n\n  Returns:\n  str: [description]\n  ",
                "snippet": "description = follow_target.get_description()\n"
                },
                {
                "title": "get_observations",
                "description": "Returns current observations from the objects needed for the behavioral layer.\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = follow_target.get_observations()\n"
                },
                {
                "title": "get_params",
                "description": "Gets the parameters of the task.\n   This is defined differently for each task in order to access the task's objects and values.\n   Note that this is different from get_observations. \n   Things like the robot name, block name..etc can be defined here for faster retrieval. \n   should have the form of params_representation[\"param_name\"] = {\"value\": param_value, \"modifiable\": bool}\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: defined parameters of the task.\n  ",
                "snippet": "params = follow_target.get_params()\n"
                },
                {
                "title": "get_task_objects",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "task_objects = follow_target.get_task_objects()\n"
                },
                {
                "title": "is_done",
                "description": "Returns True of the task is done.\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "follow_target.is_done()\n"
                },
                {
                "title": "post_reset",
                "description": "Calls while doing a .reset() on the world.\n  ",
                "snippet": "follow_target.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "called before stepping the physics simulation.\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "follow_target.pre_step(time_step_index=time_step_index,  # int\n                       simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "set_params",
                "description": "Changes the modifiable paramateres of the task\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "follow_target.set_params()\n"
                },
                {
                "title": "set_up_scene",
                "description": "Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\n   to the task_objects happens here.\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "follow_target.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                }
                ]
                },
                {
                "title": "PickPlace",
                "snippets": [
                {
                "title": "PickPlace",
                "description": "[summary]\n\nArgs:\n name (str): [description]\n cube_initial_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n cube_initial_orientation (Optional[np.ndarray], optional): [description]. Defaults to None.\n target_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n cube_size (Optional[np.ndarray], optional): [description]. Defaults to None.\n offset (Optional[np.ndarray], optional): [description]. Defaults to None.",
                "snippet": "pick_place = PickPlace(name=name,  # str\n                       cube_initial_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                       cube_initial_orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                       target_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                       cube_size=None,  # typing.Union[numpy.ndarray, NoneType]\n                       offset=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n  ",
                "snippet": "pick_place.calculate_metrics()\n"
                },
                {
                "title": "get_observations",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = pick_place.get_observations()\n"
                },
                {
                "title": "get_params",
                "description": "",
                "snippet": "params = pick_place.get_params()\n"
                },
                {
                "title": "is_done",
                "description": "[summary]\n  ",
                "snippet": "pick_place.is_done()\n"
                },
                {
                "title": "post_reset",
                "description": "",
                "snippet": "pick_place.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "[summary]\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "pick_place.pre_step(time_step_index=time_step_index,  # int\n                    simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "set_params",
                "description": "",
                "snippet": "pick_place.set_params(cube_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                      cube_orientation=None,  # typing.Union[numpy.ndarray, NoneType]\n                      target_position=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "set_robot",
                "description": "",
                "snippet": "pick_place.set_robot()\n"
                },
                {
                "title": "set_up_scene",
                "description": "[summary]\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "pick_place.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "pick_place.calculate_metrics()\n"
                },
                {
                "title": "cleanup",
                "description": "Called before calling a reset() on the world to removed temporarly objects that were added during\n   simulation for instance.\n  ",
                "snippet": "pick_place.cleanup()\n"
                },
                {
                "title": "get_description",
                "description": "[summary]\n\n  Returns:\n  str: [description]\n  ",
                "snippet": "description = pick_place.get_description()\n"
                },
                {
                "title": "get_observations",
                "description": "Returns current observations from the objects needed for the behavioral layer.\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = pick_place.get_observations()\n"
                },
                {
                "title": "get_params",
                "description": "Gets the parameters of the task.\n   This is defined differently for each task in order to access the task's objects and values.\n   Note that this is different from get_observations. \n   Things like the robot name, block name..etc can be defined here for faster retrieval. \n   should have the form of params_representation[\"param_name\"] = {\"value\": param_value, \"modifiable\": bool}\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: defined parameters of the task.\n  ",
                "snippet": "params = pick_place.get_params()\n"
                },
                {
                "title": "get_task_objects",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "task_objects = pick_place.get_task_objects()\n"
                },
                {
                "title": "is_done",
                "description": "Returns True of the task is done.\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "pick_place.is_done()\n"
                },
                {
                "title": "post_reset",
                "description": "Calls while doing a .reset() on the world.\n  ",
                "snippet": "pick_place.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "called before stepping the physics simulation.\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "pick_place.pre_step(time_step_index=time_step_index,  # int\n                    simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "set_params",
                "description": "Changes the modifiable paramateres of the task\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "pick_place.set_params()\n"
                },
                {
                "title": "set_up_scene",
                "description": "Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\n   to the task_objects happens here.\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "pick_place.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                }
                ]
                },
                {
                "title": "Stacking",
                "snippets": [
                {
                "title": "Stacking",
                "description": "[summary]\n\nArgs:\n name (str): [description]\n cube_initial_positions (np.ndarray): [description]\n cube_initial_orientations (Optional[np.ndarray], optional): [description]. Defaults to None.\n stack_target_position (Optional[np.ndarray], optional): [description]. Defaults to None.\n cube_size (Optional[np.ndarray], optional): [description]. Defaults to None.\n offset (Optional[np.ndarray], optional): [description]. Defaults to None.",
                "snippet": "stacking = Stacking(name=name,  # str\n                    cube_initial_positions=cube_initial_positions,  # numpy.ndarray\n                    cube_initial_orientations=None,  # typing.Union[numpy.ndarray, NoneType]\n                    stack_target_position=None,  # typing.Union[numpy.ndarray, NoneType]\n                    cube_size=None,  # typing.Union[numpy.ndarray, NoneType]\n                    offset=None)  # typing.Union[numpy.ndarray, NoneType]\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "stacking.calculate_metrics()\n"
                },
                {
                "title": "get_cube_names",
                "description": "[summary]\n\n  Returns:\n  List[str]: [description]\n  ",
                "snippet": "cube_names = stacking.get_cube_names()\n"
                },
                {
                "title": "get_observations",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = stacking.get_observations()\n"
                },
                {
                "title": "get_params",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "params = stacking.get_params()\n"
                },
                {
                "title": "is_done",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  bool: [description]\n  ",
                "snippet": "stacking.is_done()\n"
                },
                {
                "title": "post_reset",
                "description": "[summary]\n  ",
                "snippet": "stacking.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "[summary]\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "stacking.pre_step(time_step_index=time_step_index,  # int\n                  simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "set_params",
                "description": "[summary]\n\n  Args:\n  cube_name (Optional[str], optional): [description]. Defaults to None.\n  cube_position (Optional[str], optional): [description]. Defaults to None.\n  cube_orientation (Optional[str], optional): [description]. Defaults to None.\n  stack_target_position (Optional[str], optional): [description]. Defaults to None.\n  ",
                "snippet": "stacking.set_params(cube_name=None,  # typing.Union[str, NoneType]\n                    cube_position=None,  # typing.Union[str, NoneType]\n                    cube_orientation=None,  # typing.Union[str, NoneType]\n                    stack_target_position=None)  # typing.Union[str, NoneType]\n"
                },
                {
                "title": "set_robot",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "stacking.set_robot()\n"
                },
                {
                "title": "set_up_scene",
                "description": "[summary]\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "stacking.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                },
                {
                "title": "calculate_metrics",
                "description": "[summary]\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "stacking.calculate_metrics()\n"
                },
                {
                "title": "cleanup",
                "description": "Called before calling a reset() on the world to removed temporarly objects that were added during\n   simulation for instance.\n  ",
                "snippet": "stacking.cleanup()\n"
                },
                {
                "title": "get_description",
                "description": "[summary]\n\n  Returns:\n  str: [description]\n  ",
                "snippet": "description = stacking.get_description()\n"
                },
                {
                "title": "get_observations",
                "description": "Returns current observations from the objects needed for the behavioral layer.\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "observations = stacking.get_observations()\n"
                },
                {
                "title": "get_params",
                "description": "Gets the parameters of the task.\n   This is defined differently for each task in order to access the task's objects and values.\n   Note that this is different from get_observations. \n   Things like the robot name, block name..etc can be defined here for faster retrieval. \n   should have the form of params_representation[\"param_name\"] = {\"value\": param_value, \"modifiable\": bool}\n\n  Raises:\n  NotImplementedError: [description]\n\n  Returns:\n  dict: defined parameters of the task.\n  ",
                "snippet": "params = stacking.get_params()\n"
                },
                {
                "title": "get_task_objects",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "task_objects = stacking.get_task_objects()\n"
                },
                {
                "title": "is_done",
                "description": "Returns True of the task is done.\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "stacking.is_done()\n"
                },
                {
                "title": "post_reset",
                "description": "Calls while doing a .reset() on the world.\n  ",
                "snippet": "stacking.post_reset()\n"
                },
                {
                "title": "pre_step",
                "description": "called before stepping the physics simulation.\n\n  Args:\n  time_step_index (int): [description]\n  simulation_time (float): [description]\n  ",
                "snippet": "stacking.pre_step(time_step_index=time_step_index,  # int\n                  simulation_time=simulation_time)  # float\n"
                },
                {
                "title": "set_params",
                "description": "Changes the modifiable paramateres of the task\n\n  Raises:\n  NotImplementedError: [description]\n  ",
                "snippet": "stacking.set_params()\n"
                },
                {
                "title": "set_up_scene",
                "description": "Adding assets to the stage as well as adding the encapsulated objects such as XFormPrim..etc\n   to the task_objects happens here.\n\n  Args:\n  scene (Scene): [description]\n  ",
                "snippet": "stacking.set_up_scene(scene=scene)  # omni.isaac.core.scenes.scene.Scene\n"
                }
                ]
                }
                ]
                }
            ]
        },
        {
            "title": "Core utils",
            "snippets": [
                {
                "title": "Bounds",
                "snippets": [
                {
                "title": "compute_aabb",
                "description": "Compute an AABB for a given prim_path, a combined AABB is computed if include_children is True\n\nArgs:\n  bbox_cache (UsdGeom.BboxCache): Existing Bounding box cache to use for computation\n  prim_path (str): prim path to compute AABB for\n  include_children (bool, optional): include children of specified prim in calculation. Defaults to False.\n\nReturns:\n  np.array: Bounding box for this prim, [min x, min y, min z, max x, max y, max z]",
                "snippet": "value = bounds_utils.compute_aabb(bbox_cache=bbox_cache,  # pxr.UsdGeom.BBoxCache\n                                  prim_path=prim_path,  # str\n                                  include_children=False)  # bool\n"
                },
                {
                "title": "compute_combined_aabb",
                "description": "Computes a combined AABB given a list of prim paths\n\nArgs:\n  bbox_cache (UsdGeom.BboxCache): Existing Bounding box cache to use for computation\n  prim_paths (typing.List[str]): List of prim paths to compute combined AABB for\n\nReturns:\n  np.array: Bounding box for input prims, [min x, min y, min z, max x, max y, max z]",
                "snippet": "value = bounds_utils.compute_combined_aabb(bbox_cache=bbox_cache,  # pxr.UsdGeom.BBoxCache\n                                           prim_paths=prim_paths)  # typing.List[str]\n"
                },
                {
                "title": "create_bbox_cache",
                "description": "Helper function to create a Bounding Box Cache object that can be used for computations\n\nArgs:\n  time (Usd.TimeCode, optional): time at which cache should be initialized. Defaults to Usd.TimeCode.Default().\n  use_extents_hint (bool, optional): Use existing extents attribute on prim to compute bounding box. Defaults to True.\n\nReturns:\n  UsdGeom.BboxCache: Initialized bbox cache",
                "snippet": "value = bounds_utils.create_bbox_cache(time=DEFAULT,  # pxr.Usd.TimeCode\n                                       use_extents_hint=True)  # bool\n"
                },
                {
                "title": "recompute_extents",
                "description": "Recomputes and overwrites the extents attribute for a UsdGeom.Boundable prim\n\nArgs:\n  prim (UsdGeom.Boundable): Input prim to recompute extents for\n  time (Usd.TimeCode, optional): timecode to use for computing extents. Defaults to Usd.TimeCode.Default().\n  include_children (bool, optional): include children of specified prim in calculation. Defaults to False.\n\nRaises:\n  ValueError: If prim is not of UsdGeom.Boundable type",
                "snippet": "bounds_utils.recompute_extents(prim=prim,  # pxr.UsdGeom.Boundable\n                               time=DEFAULT,  # pxr.Usd.TimeCode\n                               include_children=False)  # bool\n"
                }
                ]
                },
                {
                "title": "Carb",
                "snippets": [
                {
                "title": "get_carb_setting",
                "description": "Convenience function to get settings.\n\nArgs:\n  carb_settings (carb.settings.ISettings): The interface to carb setttings.\n  setting (str): Name of setting to change.\n\nReturns:\n  Any: Value for the setting.",
                "snippet": "value = carb_utils.get_carb_setting(carb_settings=carb_settings,  # carb.settings._settings.ISettings\n                                    setting=setting)  # str\n"
                },
                {
                "title": "set_carb_setting",
                "description": "Convenience to set the carb settings.\n\nArgs:\n  carb_settings (carb.settings.ISettings): The interface to carb setttings.\n  setting (str): Name of setting to change.\n  value (Any): New value for the setting.\n\nRaises:\n  TypeError: If the type of value does not match setting type.",
                "snippet": "carb_utils.set_carb_setting(carb_settings=carb_settings,  # carb.settings._settings.ISettings\n                            setting=setting,  # str\n                            value=value)  # typing.Any\n"
                }
                ]
                },
                {
                "title": "Collisions",
                "snippets": [
                {
                "title": "ray_cast",
                "description": "Projects a raycast forward along x axis with specified offset\n\nIf a hit is found within the maximum distance, then the object's prim path and distance to it is returned.\nOtherwise, a None and 10000 is returned.\n\nArgs:\n  position (np.array): origin's position for ray cast\n  orientation (np.array): origin's orientation for ray cast\n  offset (np.array): offset for ray cast\n  max_dist (float, optional): maximum distance to test for collisions in stage units. Defaults to 100.0.\n\nReturns:\n  typing.Tuple[typing.Union[None, str], float]: path to geometry that was hit and hit distance, returns None, 10000 if no hit occurred",
                "snippet": "value = collisions_utils.ray_cast(position=position,  # numpy.array\n                                  orientation=orientation,  # numpy.array\n                                  offset=offset,  # numpy.array\n                                  max_dist=100.0)  # float\n"
                }
                ]
                },
                {
                "title": "Constants",
                "snippets": [
                {
                "title": "AXES_INDICES",
                "description": "Mapping from axis name to axis ID",
                "snippet": "AXES_INDICES\n"
                },
                {
                "title": "AXES_TOKEN",
                "description": "Mapping from axis name to axis USD token",
                "snippet": "AXES_TOKEN\n"
                }
                ]
                },
                {
                "title": "Distance Metrics",
                "snippets": [
                {
                "title": "rotational_distance_angle",
                "description": "Computes the weighted distance between two rotations using inner product.\n\nNote:\n  If r1 and r2 are GfMatrix3d() objects, the transformation matrices will be transposed in the distance\n  calculations.\n\nArgs:\n  r1 (typing.Union[np.ndarray, Gf.Matrix3d, Gf.Matrix4d]): rotation matrices or 4x4 transformation matrices\n  r2 (typing.Union[np.ndarray, Gf.Matrix3d, Gf.Matrix4d]): rotation matrices or 4x4 transformation matrices\n\nReturns:\n  np.ndarray: the magnitude of the angle of rotation from r1 to r2",
                "snippet": "value = distance_metrics_utils.rotational_distance_angle(r1=r1,  # typing.Union[numpy.ndarray, pxr.Gf.Matrix3d, pxr.Gf.Matrix4d]\n                                                         r2=r2)  # typing.Union[numpy.ndarray, pxr.Gf.Matrix3d, pxr.Gf.Matrix4d]\n"
                },
                {
                "title": "rotational_distance_identity_matrix_deviation",
                "description": "Computes the distance between two rotations using deviation from indentity matrix.\n\nNote:\n  If r1 and r2 are GfMatrix3d() objects, the transformation matrices will be transposed in the distance\n  calculations.\n\nArgs:\n  r1 (typing.Union[np.ndarray, Gf.Matrix4d, Gf.Matrix3d]): rotation matrices or 4x4 transformation matrices\n  r2 (typing.Union[np.ndarray, Gf.Matrix4d, Gf.Matrix3d]): rotation matrices or 4x4 transformation matrices\n\nReturns:\n  np.ndarray: the Frobenius norm \\|I-r1*r2^T\\|, where I is the identity matrix",
                "snippet": "value = distance_metrics_utils.rotational_distance_identity_matrix_deviation(r1=r1,  # typing.Union[numpy.ndarray, pxr.Gf.Matrix4d, pxr.Gf.Matrix3d]\n                                                                             r2=r2)  # typing.Union[numpy.ndarray, pxr.Gf.Matrix4d, pxr.Gf.Matrix3d]\n"
                },
                {
                "title": "rotational_distance_single_axis",
                "description": "Computes the distance between two rotations w.r.t. input axis.\n\nNote:\n  If r1 and r2 are GfMatrix3d() objects, the transformation matrices will be transposed in the distance\n  calculations.\n\nUsage:\n  If the robot were holding a cup aligned with its z-axis,\n  it would be important to align the z-axis of the robot with\n  the z-axis of the world frame.  This could be accomplished by\n  letting\n\n  | -r1 be the rotation of the robot end effector\n  | -r2 be any rotation matrix for a rotation about the z axis\n  | -axis = [0,0,1]\n\nArgs:\n  r1 (typing.Union[np.ndarray, Gf.Matrix4d, Gf.Matrix3d]): rotation matrices or 4x4 transformation matrices\n  r2 (typing.Union[np.ndarray, Gf.Matrix4d, Gf.Matrix3d]): rotation matrices or 4x4 transformation matrices\n  axis (np.ndarray): a 3d vector that will be rotated by r1 and r2\n\nReturns:\n  np.ndarray: the angle between (r1 @ axis) and (r2 @ axis)",
                "snippet": "value = distance_metrics_utils.rotational_distance_single_axis(r1=r1,  # typing.Union[numpy.ndarray, pxr.Gf.Matrix4d, pxr.Gf.Matrix3d]\n                                                               r2=r2,  # typing.Union[numpy.ndarray, pxr.Gf.Matrix4d, pxr.Gf.Matrix3d]\n                                                               axis=axis)  # numpy.ndarray\n"
                },
                {
                "title": "weighted_translational_distance",
                "description": "Computes the weighted distance between two translation vectors.\n\nThe distance calculation has the form sqrt(x.T W x), where\n\n| - x is the vector difference between t1 and t2.\n| - W is a weight matrix.\n\nGiven the identity weight matrix, this is equivalent to the \\|t1-t2\\|.\n\nUsage:\n  This formulation can be used to weight an arbitrary axis of the translation difference.\n  Letting x = t1-t2 = a1*b1 + a2*b2 + a3*b3 (where b1,b2,b3 are column basis vectors, and a1,a2,a3 are constants),\n  When W = I: x.T W x = sqrt(a1^2 + a2^2 + a3^2).\n  To weight the b1 axis by 2, let W take the form (R.T @ ([4,1,1]@I) @ R) where:\n\n  | - I is the identity matrix.\n  | - R is a rotation matrix of the form [b1,b2,b3].T\n\n  This is effectively equivalent to \\|[2*e1,e2,e3] @ [b1,b2,b3].T @ x\\| = sqrt(4*a1^2 + a2^2 + a3^2).\n\n  | - e1,e2,e3 are the elementary basis vectors.\n\nArgs:\n  t1 (typing.Union[np.ndarray, Gf.Matrix4d]):  3d translation vectors or 4x4 transformation matrices\n  t2 (typing.Union[np.ndarray, Gf.Matrix4d]):  3d translation vectors or 4x4 transformation matrices\n  weight_matrix (np.ndarray, optional): a 3x3 positive semidefinite matrix of weights. Defaults to np.eye(3).\n\nReturns:\n  np.ndarray:  the weighted norm of the difference (t1-t2)",
                "snippet": "value = distance_metrics_utils.weighted_translational_distance(t1=t1,  # typing.Union[numpy.ndarray, pxr.Gf.Matrix4d]\n                                                               t2=t2,  # typing.Union[numpy.ndarray, pxr.Gf.Matrix4d]\n                                                               weight_matrix=[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]])  # numpy.ndarray\n"
                }
                ]
                },
                {
                "title": "Extensions",
                "snippets": [
                {
                "title": "disable_extension",
                "description": "Unload an extension.\n\nArgs:\n  extension_name (str): name of the extension\n\nReturns:\n  bool: True if extension could be unloaded, False otherwise",
                "snippet": "value = extensions_utils.disable_extension(extension_name=extension_name)  # str\n"
                },
                {
                "title": "enable_extension",
                "description": "Load an extension from the extenstion manager.\n\nArgs:\n  extension_name (str): name of the extension\n\nReturns:\n  bool: True if extension could be loaded, False otherwise",
                "snippet": "value = extensions_utils.enable_extension(extension_name=extension_name)  # str\n"
                },
                {
                "title": "get_extension_id",
                "description": "Get extension id for a loaded extension\n\nArgs:\n  extension_name (str): name of the extension\n\nReturns:\n  int: Full extension id",
                "snippet": "value = extensions_utils.get_extension_id(extension_name=extension_name)  # str\n"
                },
                {
                "title": "get_extension_path",
                "description": "Get extension path for a loaded extension\n\nArgs:\n  ext_id (id): full id of extension\n\nReturns:\n  str: Path to loaded extension root directory",
                "snippet": "value = extensions_utils.get_extension_path(ext_id=ext_id)  # int\n"
                },
                {
                "title": "get_extension_path_from_name",
                "description": "Get extension path for a loaded extension\n\nArgs:\n  extension_name (str): name of the extension\n\nReturns:\n  str: Path to loaded extension root directory",
                "snippet": "value = extensions_utils.get_extension_path_from_name(extension_name=extension_name)  # str\n"
                }
                ]
                },
                {
                "title": "Math",
                "snippets": [
                {
                "title": "cross",
                "description": "Computes the cross-product between two 3-dimensional vectors.\n\nArgs:\n  a (np.ndarray, list): A 3-dimensional vector\n  b (np.ndarray, list): A 3-dimensional vector\n\nReturns:\n  np.ndarray: Cross product between input vectors.",
                "snippet": "value = math_utils.cross(a=a,  # typing.Union[numpy.ndarray, list]\n                         b=b)  # typing.Union[numpy.ndarray, list]\n"
                },
                {
                "title": "normalize",
                "description": " Normalizes the vector inline (and also returns it). ",
                "snippet": "math_utils.normalize(v=v)\n"
                },
                {
                "title": "normalized",
                "description": " Returns a normalized copy of the provided vector. ",
                "snippet": "math_utils.normalized(v=v)\n"
                },
                {
                "title": "radians_to_degrees",
                "description": "Converts input angles from radians to degrees.\n\nArgs:\n  rad_angles (np.ndarray): Input array of angles (in radians).\n\nReturns:\n  np.ndarray: Array of angles in degrees.",
                "snippet": "value = math_utils.radians_to_degrees(rad_angles=rad_angles)  # numpy.ndarray\n"
                }
                ]
                },
                {
                "title": "Mesh",
                "snippets": [
                {
                "title": "get_mesh_vertices_relative_to",
                "description": "Get vertices of the mesh prim in the coordinate system of the given prim.\n\nArgs:\n  mesh_prim (UsdGeom.Mesh): mesh prim to get the vertice points.\n  coord_prim (Usd.Prim): prim used as relative coordinate.\n\nReturns:\n  np.ndarray: vertices of the mesh in the coordinate system of the given prim. Shape is (N, 3).",
                "snippet": "value = mesh_utils.get_mesh_vertices_relative_to(mesh_prim=mesh_prim,  # pxr.UsdGeom.Mesh\n                                                 coord_prim=coord_prim)  # pxr.Usd.Prim\n"
                }
                ]
                },
                {
                "title": "Nucleus",
                "snippets": [
                {
                "title": "build_server_list",
                "description": "Return list with all known servers to check\n\nReturns:\n  all_servers (typing.List): List of servers found",
                "snippet": "value = nucleus_utils.build_server_list()\n"
                },
                {
                "title": "check_server",
                "description": "Check a specific server for a path\n\nArgs:\n  server (str): Name of Nucleus server\n  path (str): Path to search\n\nReturns:\n  bool: True if folder is found",
                "snippet": "value = nucleus_utils.check_server(server=server,  # str\n                                   path=path)  # str\n"
                },
                {
                "title": "check_server_async",
                "description": "Check a specific server for a path (asynchronous version).\n\nArgs:\n  server (str): Name of Nucleus server\n  path (str): Path to search\n\nReturns:\n  bool: True if folder is found",
                "snippet": "value = nucleus_utils.check_server_async(server=server,  # str\n                                         path=path)  # str\n"
                },
                {
                "title": "create_folder",
                "description": "Create a folder on server\n\nArgs:\n  server (str): Name of Nucleus server\n  path (str): Path to folder\n\nReturns:\n  bool: True if folder is created successfully",
                "snippet": "value = nucleus_utils.create_folder(server=server,  # str\n                                    path=path)  # str\n"
                },
                {
                "title": "delete_folder",
                "description": "Remove folder and all of its contents\n\nArgs:\n  server (str): Name of Nucleus server\n  path (str): Path to folder\n\nReturns:\n  bool: True if folder is deleted successfully",
                "snippet": "value = nucleus_utils.delete_folder(server=server,  # str\n                                    path=path)  # str\n"
                },
                {
                "title": "download_assets_async",
                "description": "Download assets from S3 bucket\n\nArgs:\n  src (str): URL of S3 bucket as source\n  dst (str): URL of Nucleus server to copy assets to\n  progress_callback: Callback function to keep track of progress of copy\n  concurrency (int): Number of concurrent copy operations. Default value: 3\n  copy_behaviour (omni.client._omniclient.CopyBehavior): Behavior if the destination exists. Default value: OVERWRITE\n  copy_after_delete (bool): True if destination needs to be deleted before a copy. Default value: True\n  timeout (float): Default value: 300 seconds\n\nReturns:\n  Result (omni.client._omniclient.Result): Result of copy",
                "snippet": "value = nucleus_utils.download_assets_async(src=src,  # str\n                                            dst=dst,  # str\n                                            progress_callback=progress_callback,\n                                            concurrency=10,  # int\n                                            copy_behaviour=CopyBehavior.OVERWRITE,  # omni.client.CopyBehavior\n                                            copy_after_delete=True,  # bool\n                                            timeout=300.0)  # float\n"
                },
                {
                "title": "find_nucleus_server",
                "description": "Attempts to determine best Nucleus server to use based on existing mountedDrives setting and the\ndefault server specified in json config at \"/persistent/isaac/asset_root/\". Call is blocking\n\nArgs:\n  suffix (str): Path to folder to search for. Default value: /Isaac\n\nReturns:\n  bool: True if Nucleus server with suffix is found\n  url (str): URL of found Nucleus",
                "snippet": "value = nucleus_utils.find_nucleus_server(suffix=suffix)  # str\n"
                },
                {
                "title": "get_assets_root_path",
                "description": "Tries to find the root path to the Isaac Sim assets on a Nucleus server\n\nReturns:\n  url (str): URL of Nucleus server with root path to assets folder.\n  Returns None if Nucleus server not found.",
                "snippet": "value = nucleus_utils.get_assets_root_path()\n"
                },
                {
                "title": "get_assets_server",
                "description": "Tries to find a server with the Isaac Sim assets\n\nReturns:\n  url (str): URL of Nucleus server with the Isaac Sim assets\n  Returns None if Nucleus server not found.",
                "snippet": "value = nucleus_utils.get_assets_server()\n"
                },
                {
                "title": "get_full_asset_path",
                "description": "Tries to find the full asset path on connected servers\n\nArgs:\n  path (str): Path of asset from root to verify\n\nReturns:\n  url (str): URL or full path to assets.\n  Returns None if assets not found.",
                "snippet": "value = nucleus_utils.get_full_asset_path(path=path)  # str\n"
                },
                {
                "title": "get_isaac_asset_root_path",
                "description": "Tries to find the root path to the Isaac Sim assets\n\nReturns:\n  url (str): URL or root path to Isaac Sim assets folder.\n  Returns None if Isaac Sim assets not found.",
                "snippet": "value = nucleus_utils.get_isaac_asset_root_path()\n"
                },
                {
                "title": "get_nvidia_asset_root_path",
                "description": "Tries to find the root path to the NVIDIA assets\n\nReturns:\n  url (str): URL or root path to NVIDIA assets folder.\n  Returns None if NVIDIA assets not found.",
                "snippet": "value = nucleus_utils.get_nvidia_asset_root_path()\n"
                },
                {
                "title": "get_server_path",
                "description": "Tries to find a Nucleus server with specific path\n\nArgs:\n  suffix (str): Path to folder to search for.\n\nReturns:\n  url (str): URL of Nucleus server with path to folder.\n  Returns None if Nucleus server not found.",
                "snippet": "value = nucleus_utils.get_server_path(suffix=\"\")  # str\n"
                },
                {
                "title": "get_url_root",
                "description": "Get root from URL or path\nArgs:\n  url (str): full http or omniverse path\n\nReturns:\n  str: Root path or URL or Nucleus server",
                "snippet": "value = nucleus_utils.get_url_root(url=url)  # str\n"
                },
                {
                "title": "is_dir_async",
                "description": "Check if path is a folder\n\nArgs:\n  path (str): Path to folder\n\nReturns:\n  bool: True if path is a folder",
                "snippet": "value = nucleus_utils.is_dir_async(path=path)  # str\n"
                },
                {
                "title": "is_file",
                "description": "Check if path is a file\n\nArgs:\n  path (str): Path to file\n\nReturns:\n  bool: True if path is a file",
                "snippet": "value = nucleus_utils.is_file(path=path)  # str\n"
                },
                {
                "title": "is_file_async",
                "description": "Check if path is a file\n\nArgs:\n  path (str): Path to file\n\nReturns:\n  bool: True if path is a file",
                "snippet": "value = nucleus_utils.is_file_async(path=path)  # str\n"
                },
                {
                "title": "list_folder",
                "description": "List files and sub-folders from root path\n\nArgs:\n  path (str): Path to root folder\n\nRaises:\n  Exception: When unable to find files under the path.\n\nReturns:\n  files (typing.List): List of path to each file\n  dirs (typing.List): List of path to each sub-folder",
                "snippet": "value = nucleus_utils.list_folder(path=path)  # str\n"
                },
                {
                "title": "recursive_list_folder",
                "description": "Recursively list all files\n\nArgs:\n  path (str): Path to folder\n\nReturns:\n  paths (typing.List): List of path to each file",
                "snippet": "value = nucleus_utils.recursive_list_folder(path=path)  # str\n"
                },
                {
                "title": "verify_asset_root_path",
                "description": "Attempts to determine Isaac assets version and check if there are updates.\n(asynchronous version)\n\nArgs:\n  path (str): URL or path of asset root to verify\n\nReturns:\n  omni.client.Result: OK if Assets verified\n  ver (str): Version of Isaac Sim assets",
                "snippet": "value = nucleus_utils.verify_asset_root_path(path=path)  # str\n"
                }
                ]
                },
                {
                "title": "Numpy",
                "snippets": [
                {
                "title": "as_type",
                "description": "",
                "snippet": "numpy_utils.as_type(data=data,\n                    dtype=dtype)\n"
                },
                {
                "title": "clone_tensor",
                "description": "",
                "snippet": "numpy_utils.clone_tensor(data=data,\n                         device=None)\n"
                },
                {
                "title": "convert",
                "description": "",
                "snippet": "numpy_utils.convert(data=data,\n                    device=None)\n"
                },
                {
                "title": "cos",
                "description": "",
                "snippet": "numpy_utils.cos(data=data)\n"
                },
                {
                "title": "create_tensor_from_list",
                "description": "",
                "snippet": "numpy_utils.create_tensor_from_list(data=data,\n                                    dtype=dtype,\n                                    device=None)\n"
                },
                {
                "title": "create_zeros_tensor",
                "description": "",
                "snippet": "numpy_utils.create_zeros_tensor(shape=shape,\n                                dtype=dtype,\n                                device=None)\n"
                },
                {
                "title": "deg2rad",
                "description": "_summary_\n\nArgs:\n  degree_value (np.ndarray): _description_\n  device (_type_, optional): _description_. Defaults to None.\n\nReturns:\n  np.ndarray: _description_",
                "snippet": "value = numpy_utils.deg2rad(degree_value=degree_value,  # numpy.ndarray\n                            device=None)\n"
                },
                {
                "title": "euler_angles_to_quats",
                "description": "Vectorized version of converting euler angles to quaternion (scalar first)\n\nArgs:\n  euler_angles np.ndarray: euler angles with shape (N, 3) or (3,) representation XYZ in extrinsic coordinates\n  degrees (bool, optional): True if degrees, False if radians. Defaults to False.\n\nReturns:\n  np.ndarray: quaternions representation of the angles (N, 4) or (4,) - scalar first.",
                "snippet": "value = numpy_utils.euler_angles_to_quats(euler_angles=euler_angles,  # numpy.ndarray\n                                          degrees=False,  # bool\n                                          device=None)\n"
                },
                {
                "title": "expand_dims",
                "description": "",
                "snippet": "numpy_utils.expand_dims(data=data,\n                        axis=axis)\n"
                },
                {
                "title": "get_local_from_world",
                "description": "",
                "snippet": "numpy_utils.get_local_from_world(parent_transforms=parent_transforms,\n                                 positions=positions,\n                                 orientations=orientations,\n                                 device=None)\n"
                },
                {
                "title": "get_pose",
                "description": "",
                "snippet": "numpy_utils.get_pose(positions=positions,\n                     orientations=orientations,\n                     device=None)\n"
                },
                {
                "title": "get_world_from_local",
                "description": "",
                "snippet": "numpy_utils.get_world_from_local(parent_transforms=parent_transforms,\n                                 translations=translations,\n                                 orientations=orientations,\n                                 device=None)\n"
                },
                {
                "title": "gf_quat_to_tensor",
                "description": "Converts a pxr Quaternion type to a numpy array following [w, x, y, z] convention.\n\nArgs:\n  orientation (typing.Union[Gf.Quatd, Gf.Quatf, Gf.Quaternion]): [description]\n\nReturns:\n  np.ndarray: [description]",
                "snippet": "value = numpy_utils.gf_quat_to_tensor(orientation=orientation,  # typing.Union[pxr.Gf.Quatd, pxr.Gf.Quatf, pxr.Gf.Quaternion]\n                                      device=None)\n"
                },
                {
                "title": "inverse",
                "description": "",
                "snippet": "numpy_utils.inverse(data=data)\n"
                },
                {
                "title": "matmul",
                "description": "",
                "snippet": "numpy_utils.matmul(matrix_a=matrix_a,\n                   matrix_b=matrix_b)\n"
                },
                {
                "title": "move_data",
                "description": "",
                "snippet": "numpy_utils.move_data(data=data,\n                      device=None)\n"
                },
                {
                "title": "pad",
                "description": "",
                "snippet": "numpy_utils.pad(data=data,\n                pad_width=pad_width,\n                mode=\"constant\",\n                value=None)\n"
                },
                {
                "title": "quats_to_euler_angles",
                "description": "Vectorized version of converting quaternions (scalar first) to euler angles\n\nArgs:\n  quaternions (np.ndarray): quaternions with shape (N, 4) or (4,) - scalar first\n  degrees (bool, optional): Return euler angles in degrees if True, radians if False. Defaults to False.\n\nReturns:\n  np.ndarray: Euler angles in extrinsic coordinates XYZ order with shape (N, 3) or (3,) corresponding to the quaternion rotations",
                "snippet": "value = numpy_utils.quats_to_euler_angles(quaternions=quaternions,  # numpy.ndarray\n                                          degrees=False,  # bool\n                                          device=None)\n"
                },
                {
                "title": "quats_to_rot_matrices",
                "description": "Vectorized version of converting quaternions to rotation matrices\n\nArgs:\n  quaternions (np.ndarray): quaternions with shape (N, 4) or (4,) and scalar first\n\nReturns:\n  np.ndarray: N Rotation matrices with shape (N, 3, 3) or (3, 3)",
                "snippet": "value = numpy_utils.quats_to_rot_matrices(quaternions=quaternions,  # numpy.ndarray\n                                          device=None)\n"
                },
                {
                "title": "quats_to_rotvecs",
                "description": "Vectorized version of converting quaternions to rotation vectors\n\nArgs:\n  quaternions (np.ndarray): quaternions with shape (N, 4) or (4,) and scalar first\n\nReturns:\n  np.ndarray: N rotation vectors with shape (N,3) or (3,).  The magnitude of the rotation vector describes the magnitude of the rotation.\n  The normalized rotation vector represents the axis of rotation.",
                "snippet": "value = numpy_utils.quats_to_rotvecs(quaternions=quaternions,  # numpy.ndarray\n                                     device=None)\n"
                },
                {
                "title": "rad2deg",
                "description": "_summary_\n\nArgs:\n  radian_value (np.ndarray): _description_\n  device (_type_, optional): _description_. Defaults to None.\n\nReturns:\n  np.ndarray: _description_",
                "snippet": "value = numpy_utils.rad2deg(radian_value=radian_value,  # numpy.ndarray\n                            device=None)\n"
                },
                {
                "title": "resolve_indices",
                "description": "",
                "snippet": "numpy_utils.resolve_indices(indices=indices,\n                            count=count,\n                            device=None)\n"
                },
                {
                "title": "rot_matrices_to_quats",
                "description": "Vectorized version of converting rotation matrices to quaternions\n\nArgs:\n  rotation_matrices (np.ndarray): N Rotation matrices with shape (N, 3, 3) or (3, 3)\n\nReturns:\n  np.ndarray: quaternion representation of the rotation matrices (N, 4) or (4,) - scalar first",
                "snippet": "value = numpy_utils.rot_matrices_to_quats(rotation_matrices=rotation_matrices,  # numpy.ndarray\n                                          device=None)\n"
                },
                {
                "title": "rotvecs_to_quats",
                "description": "Vectorized version of converting rotation vectors to quaternions\n\nArgs:\n  rotation_vectors (np.ndarray): N rotation vectors with shape (N, 3) or (3,).  The magnitude of the rotation vector describes the magnitude of the rotation.\n  The normalized rotation vector represents the axis of rotation.\n  degrees (bool): The magnitude of the rotation vector will be interpretted as degrees if True, and radians if False.  Defaults to False.\n\nReturns:\n  np.ndarray: quaternion representation of the rotation matrices (N, 4) or (4,) - scalar first",
                "snippet": "value = numpy_utils.rotvecs_to_quats(rotation_vectors=rotation_vectors,  # numpy.ndarray\n                                     degrees=False,  # bool\n                                     device=None)\n"
                },
                {
                "title": "sin",
                "description": "",
                "snippet": "numpy_utils.sin(data=data)\n"
                },
                {
                "title": "tensor_cat",
                "description": "",
                "snippet": "numpy_utils.tensor_cat(data=data,\n                       dim=-1)\n"
                },
                {
                "title": "tensor_stack",
                "description": "",
                "snippet": "numpy_utils.tensor_stack(data=data,\n                         dim=0)\n"
                },
                {
                "title": "tf_matrices_from_poses",
                "description": "[summary]\n\nArgs:\n  translations (Union[np.ndarray, torch.Tensor]): translations with shape (N, 3).\n  orientations (Union[np.ndarray, torch.Tensor]): quaternion representation (scalar first) with shape (N, 4).\n\nReturns:\n  Union[np.ndarray, torch.Tensor]: transformation matrices with shape (N, 4, 4)",
                "snippet": "value = numpy_utils.tf_matrices_from_poses(translations=translations,  # numpy.ndarray\n                                           orientations=orientations,  # numpy.ndarray\n                                           device=None)\n"
                },
                {
                "title": "transpose_2d",
                "description": "",
                "snippet": "numpy_utils.transpose_2d(data=data)\n"
                }
                ]
                },
                {
                "title": "Physics",
                "snippets": [
                {
                "title": "get_rigid_body_enabled",
                "description": "Get the physics:rigidBodyEnabled attribute from the USD Prim at the given path\n\nArgs:\n  prim_path (str): The path to the USD Prim\n\nReturns:\n  Any: The value of physics:rigidBodyEnabled attribute if it exists, and None if it does not exist.",
                "snippet": "value = physics_utils.get_rigid_body_enabled(prim_path=prim_path)  # str\n"
                },
                {
                "title": "set_rigid_body_enabled",
                "description": "If it exists, set the physics:rigidBodyEnabled attribute on the USD Prim at the given path\n\nArgs:\n  _value (Any): Value to set physics:rigidBodyEnabled attribute to\n  prim_path (str): The path to the USD Prim",
                "snippet": "physics_utils.set_rigid_body_enabled(_value=_value,\n                                     prim_path=prim_path)\n"
                },
                {
                "title": "simulate_async",
                "description": "Helper function to simulate async for seconds * steps_per_sec frames.\n\nArgs:\n  seconds (float): time in seconds to simulate for\n  steps_per_sec (int, optional): steps per second. Defaults to 60.\n  callback (Callable, optional): optional function to run every step. Defaults to None.",
                "snippet": "physics_utils.simulate_async(seconds=seconds,  # float\n                             steps_per_sec=60,  # int\n                             callback=None)  # typing.Callable\n"
                }
                ]
                },
                {
                "title": "Prims",
                "snippets": [
                {
                "title": "create_prim",
                "description": "Create a prim into current USD stage.\n\nThe method applies specified transforms, the semantic label and set specified attributes.\n\nArgs:\n  prim_path (str): The path of the new prim.\n  prim_type (str): Prim type name\n  position (typing.Sequence[float], optional): prim position (applied last)\n  translation (typing.Sequence[float], optional): prim translation (applied last)\n  orientation (typing.Sequence[float], optional): prim rotation as quaternion\n  scale (np.ndarray (3), optional): scaling factor in x, y, z.\n  usd_path (str, optional): Path to the USD that this prim will reference.\n  semantic_label (str, optional): Semantic label.\n  semantic_type (str, optional): set to \"class\" unless otherwise specified.\n  attributes (dict, optional): Key-value pairs of prim attributes to set.\n\nRaises:\n  Exception: If there is already a prim at the prim_path\n\nReturns:\n  Usd.Prim: The created USD prim.",
                "snippet": "value = prims_utils.create_prim(prim_path=prim_path,  # str\n                                prim_type=\"Xform\",  # str\n                                position=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                translation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                orientation=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                scale=None,  # typing.Union[typing.Sequence[float], NoneType]\n                                usd_path=None,  # typing.Union[str, NoneType]\n                                semantic_label=None,  # typing.Union[str, NoneType]\n                                semantic_type=\"class\",  # str\n                                attributes=None)  # typing.Union[dict, NoneType]\n"
                },
                {
                "title": "define_prim",
                "description": "Create a USD Prim at the given prim_path of type prim_type unless one already exists\n\nArgs:\n  prim_path (str): path of the prim in the stage\n  prim_type (str, optional): The type of the prim to create. Defaults to \"Xform\".\n\nRaises:\n  Exception: If there is already a prim at the prim_path\n\nReturns:\n  Usd.Prim: The created USD prim.",
                "snippet": "value = prims_utils.define_prim(prim_path=prim_path,  # str\n                                prim_type=\"Xform\")  # str\n"
                },
                {
                "title": "delete_prim",
                "description": "Remove the USD Prim and its decendants from the scene if able\n\nArgs:\n  prim_path (str): path of the prim in the stage",
                "snippet": "prims_utils.delete_prim(prim_path=prim_path)  # str\n"
                },
                {
                "title": "find_matching_prim_paths",
                "description": "Find all the matching prim paths in the stage based on Regex expression.\n\nArgs:\n  prim_path_regex (str): The Regex expression for prim path.\n\nReturns:\n  typing.List[str]: List of prim paths that match input expression.",
                "snippet": "value = prims_utils.find_matching_prim_paths(prim_path_regex=prim_path_regex)  # str\n"
                },
                {
                "title": "get_all_matching_child_prims",
                "description": "Performs a breadth-first search starting from the root and returns all the prims matching the predicate.\n\nArgs:\n  prim_path (str): root prim path to start traversal from.\n  predicate (typing.Callable[[str], bool]): predicate that checks the prim path of a prim and returns a boolean.\n  depth (typing.Optional[int]): maximum depth for traversal, should be bigger than zero if specified.\n  Defaults to None (i.e: traversal till the end of the tree).\n\nReturns:\n  typing.List[Usd.Prim]: A list containing the root and children prims matching specified predicate.",
                "snippet": "value = prims_utils.get_all_matching_child_prims(prim_path=prim_path,  # str\n                                                 predicate=<function <lambda> at 0x7ef4b8070050>,  # typing.Callable[[str], bool]\n                                                 depth=None)  # typing.Union[int, NoneType]\n"
                },
                {
                "title": "get_first_matching_child_prim",
                "description": "Recursively get the first USD Prim at the path string that passes the predicate function\n\nArgs:\n  prim_path (str): path of the prim in the stage\n  predicate (typing.Callable[[str], bool]): Function to test the prims against\n\nReturns:\n   Usd.Prim: The first prim or child of the prim, as defined by GetChildren, that passes the predicate",
                "snippet": "value = prims_utils.get_first_matching_child_prim(prim_path=prim_path,  # str\n                                                  predicate=predicate)  # typing.Callable[[str], bool]\n"
                },
                {
                "title": "get_first_matching_parent_prim",
                "description": "Recursively get the first USD Prim at the parent path string that passes the predicate function\n\nArgs:\n  prim_path (str): path of the prim in the stage\n  predicate (typing.Callable[[str], bool]): Function to test the prims against\n\nReturns:\n  str: The first prim on the parent path, as defined by GetParent, that passes the predicate",
                "snippet": "value = prims_utils.get_first_matching_parent_prim(prim_path=prim_path,  # str\n                                                   predicate=predicate)  # typing.Callable[[str], bool]\n"
                },
                {
                "title": "get_prim_at_path",
                "description": "Get the USD Prim at a given path string\n\nArgs:\n  prim_path (str): path of the prim in the stage\n\nReturns:\n  Usd.Prim: USD Prim object at the given path in the current stage",
                "snippet": "value = prims_utils.get_prim_at_path(prim_path=prim_path)  # str\n"
                },
                {
                "title": "get_prim_children",
                "description": "Return the call of the USD Prim's GetChildren member function\n\nArgs:\n  prim (Usd.Prim): The parent USD Prim\n\nReturns:\n  typing.List[Usd.Prim]: A list of the prim's children.",
                "snippet": "value = prims_utils.get_prim_children(prim=prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "get_prim_object_type",
                "description": "Get the dynamic control Ooject type of the USD Prim at the given path.\n\nIf the prim at the path is of Dynamic Control type--i.e. rigid_body, joint, dof, articulation, attractor, d6joint,\nthen the correspodning string returned. If is an Xformable prim, then \"xform\" is returned. Otherwise None\nis returned.\n\nArgs:\n  prim_path (str): path of the prim in the stage\n\nRaises:\n  Exception: If the USD Prim is not a suppored type.\n\nReturns:\n  str: String corresponding to the object type.",
                "snippet": "value = prims_utils.get_prim_object_type(prim_path=prim_path)  # str\n"
                },
                {
                "title": "get_prim_parent",
                "description": "Return the call of the USD Prim's GetChildren member function\n\nArgs:\n  prim (Usd.Prim): The USD Prim to call GetParent on\n\nReturns:\n  Usd.Prim: The prim's parent returned from GetParent",
                "snippet": "value = prims_utils.get_prim_parent(prim=prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "get_prim_path",
                "description": "Get the path of a given USD prim.\n\nArgs:\n  prim (Usd.Prim): The input USD prim.\n\nReturns:\n  str: The path to the input prim.",
                "snippet": "value = prims_utils.get_prim_path(prim=prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "get_prim_property",
                "description": "Get the attribute of the USD Prim at the given path\n\nArgs:\n  prim_path (str): path of the prim in the stage\n  property_name (str): name of the attribute to get\n\nReturns:\n  typing.Any: The attribute if it exists, None otherwise",
                "snippet": "value = prims_utils.get_prim_property(prim_path=prim_path,  # str\n                                      property_name=property_name)  # str\n"
                },
                {
                "title": "get_prim_type_name",
                "description": "Get the TypeName of the USD Prim at the path if it is valid\n\nArgs:\n  prim_path (str): path of the prim in the stage\n\nRaises:\n  Exception: If there is not a valid prim at the given path\n\nReturns:\n  str: The TypeName of the USD Prim at the path string",
                "snippet": "value = prims_utils.get_prim_type_name(prim_path=prim_path)  # str\n"
                },
                {
                "title": "is_prim_ancestral",
                "description": "Check if any of the prims ancestors were brought in as a reference\n\nArgs:\n  prim_path (str): The path to the USD prim.\n\nReturns:\n  True if prim is part of a referenced prim, false otherwise.",
                "snippet": "value = prims_utils.is_prim_ancestral(prim_path=prim_path)  # str\n"
                },
                {
                "title": "is_prim_hidden_in_stage",
                "description": "Checks if the prim is hidden in the USd stage or not.\n\nArgs:\n  prim_path (str): The path to the USD prim.\n\nNote:\n  This is not related to the prim visibility.\n\nReturns:\n  True if prim is hidden from stage window, False if not hidden.",
                "snippet": "value = prims_utils.is_prim_hidden_in_stage(prim_path=prim_path)  # str\n"
                },
                {
                "title": "is_prim_no_delete",
                "description": "Checks whether a prim can be deleted or not from USD stage.\n\nArgs:\n  prim_path (str): The path to the USD prim.\n\nReturns:\n  True if prim cannot be deleted, False if it can",
                "snippet": "value = prims_utils.is_prim_no_delete(prim_path=prim_path)  # str\n"
                },
                {
                "title": "is_prim_non_root_articulation_link",
                "description": "Used to query if the prim_path corresponds to a link in an articulation which is a non root link.\n\nArgs:\n  prim_path (str): prim_path to query\n\nReturns:\n  bool: True if the prim path corresponds to a link in an articulation which is a non root link\n  and can't have a transformation applied to it.",
                "snippet": "value = prims_utils.is_prim_non_root_articulation_link(prim_path=prim_path)  # str\n"
                },
                {
                "title": "is_prim_path_valid",
                "description": "Check if a path has a valid USD Prim at it\n\nArgs:\n  prim_path (str): path of the prim in the stage\n\nReturns:\n  bool: True if the path points to a valid prim",
                "snippet": "value = prims_utils.is_prim_path_valid(prim_path=prim_path)  # str\n"
                },
                {
                "title": "is_prim_root_path",
                "description": "Checks if the input prim path is root or not.\n\nArgs:\n  prim_path (str): The path to the USD prim.\n\nReturns:\n  True if the prim path is \"/\", False otherwise",
                "snippet": "value = prims_utils.is_prim_root_path(prim_path=prim_path)  # str\n"
                },
                {
                "title": "move_prim",
                "description": "Run the Move command to change a prims USD Path in the stage\n\nArgs:\n  path_from (str): Path of the USD Prim you wish to move\n  path_to (str): Final destination of the prim",
                "snippet": "prims_utils.move_prim(path_from=path_from,  # str\n                      path_to=path_to)  # str\n"
                },
                {
                "title": "query_parent_path",
                "description": "Check if one of the ancestors of the prim at the prim_path can pass the predicate\n\nArgs:\n  prim_path (str): path to the USD Prim for which to check the ancestors\n  predicate (typing.Callable[[str], bool]): The condition that must be True about the ancestors\n\nReturns:\n  bool: True if there is an ancestor that can pass the predicate, False otherwise",
                "snippet": "value = prims_utils.query_parent_path(prim_path=prim_path,  # str\n                                      predicate=predicate)  # typing.Callable[[str], bool]\n"
                },
                {
                "title": "set_prim_hide_in_stage_window",
                "description": "set hide_in_stage_window metadata for prim\n\nArgs:\n  prim (Usd.Prim): Prim to set\n  hide (bool): True to hide in stage window, false to show",
                "snippet": "prims_utils.set_prim_hide_in_stage_window(prim=prim,  # pxr.Usd.Prim\n                                          hide=hide)  # bool\n"
                },
                {
                "title": "set_prim_no_delete",
                "description": "set no_delete metadata for prim\n\nArgs:\n  prim (Usd.Prim): Prim to set\n  no_delete (bool):True to make prim undeletable in stage window, false to allow deletion",
                "snippet": "prims_utils.set_prim_no_delete(prim=prim,  # pxr.Usd.Prim\n                               no_delete=no_delete)  # bool\n"
                },
                {
                "title": "set_prim_property",
                "description": "Set the attribute of the USD Prim at the path\n\nArgs:\n  prim_path (str): path of the prim in the stage\n  property_name (str): name of the attribute to set\n  property_value (typing.Any): value to set the attribute to",
                "snippet": "prims_utils.set_prim_property(prim_path=prim_path,  # str\n                              property_name=property_name,  # str\n                              property_value=property_value)  # typing.Any\n"
                },
                {
                "title": "set_prim_visibility",
                "description": "Sets the visibility of the prim in the opened stage.\n\nThe method does this through the USD API.\n\nArgs:\n  prim (Usd.Prim): the USD prim\n  visible (bool): flag to set the visibility of the usd prim in stage.",
                "snippet": "prims_utils.set_prim_visibility(prim=prim,  # pxr.Usd.Prim\n                                visible=visible)  # bool\n"
                },
                {
                "title": "set_targets",
                "description": "Set targets for a prim relationship attribute\n\nArgs:\n  prim (Usd.Prim): Prim to create and set attribute on\n  attribute (str): Relationship attribute to create\n  target_prim_paths (list): list of targets to set",
                "snippet": "prims_utils.set_targets(prim=prim,  # pxr.Usd.Prim\n                        attribute=attribute,  # str\n                        target_prim_paths=target_prim_paths)  # list\n"
                }
                ]
                },
                {
                "title": "Random",
                "snippets": [
                {
                "title": "get_random_translation_from_camera",
                "description": "Get a random translation from the camera, in the camera's frame, that's in view of the camera.\n\nArgs:\n  min_distance (float): minimum distance away from the camera (along the optical axis) of the random\n  translation.\n  max_distance (float): maximum distance away from the camera (along the optical axis) of the random\n  translation.\n  fov_x (float): field of view of the camera in the x-direction in radians.\n  fov_y (float): field of view of the camera in the y-direction in radians.\n  fraction_to_screen_edge (float): maximum allowed fraction to the edge of the screen the translated point may\n  appear when viewed from the camera. A value of 0 corresponds to the\n  translated point being centered in the camera's view (on the optical axis),\n  whereas a value of 1 corresponds to the translated point being on the edge\n  of the screen in the camera's view.\n\nReturns:\n  np.ndarray: random translation from the camera, in the camera's frame, that's in view of the camera. Shape\n  is (3, ).",
                "snippet": "value = random_utils.get_random_translation_from_camera(min_distance=min_distance,  # float\n                                                        max_distance=max_distance,  # float\n                                                        fov_x=fov_x,  # float\n                                                        fov_y=fov_y,  # float\n                                                        fraction_to_screen_edge=fraction_to_screen_edge)  # float\n"
                },
                {
                "title": "get_random_values_in_range",
                "description": "Get an array of random values where each element is between the corresponding min_range and max_range element.\n\nArgs:\n  min_range (np.ndarray): minimum values for each corresponding element of the array of random values. Shape is\n  (num_values, ).\n  max_range (np.ndarray): maximum values for each corresponding element of the array of random values. Shape is\n  (num_values, ).\n\nReturns:\n  np.ndarray: array of random values. Shape is (num_values, ).",
                "snippet": "value = random_utils.get_random_values_in_range(min_range=min_range,  # numpy.ndarray\n                                                max_range=max_range)  # numpy.ndarray\n"
                },
                {
                "title": "get_random_world_pose_in_view",
                "description": "Get a pose defined in the world frame that's in view of the camera.\n\nArgs:\n  camera_prim (Usd.Prim): prim path of the camera.\n  min_distance (float): minimum distance away from the camera (along the optical axis) of the random\n  translation.\n  max_distance (float): maximum distance away from the camera (along the optical axis) of the random\n  translation.\n  fov_x (float): field of view of the camera in the x-direction in radians.\n  fov_y (float): field of view of the camera in the y-direction in radians.\n  fraction_to_screen_edge (float): maximum allowed fraction to the edge of the screen the translated point may\n  appear when viewed from the camera. A value of 0 corresponds to the\n  translated point being centered in the camera's view (on the optical axis),\n  whereas a value of 1 corresponds to the translated point being on the edge\n  of the screen in the camera's view.\n  coord_prim (Usd.Prim): prim whose frame the orientation is defined with respect to.\n  min_rotation_range (np.ndarray): minimum XYZ Euler angles of the random pose, defined with respect to the\n  frame of the prim at coord_prim. Shape is (3, ).\n  max_rotation_range (np.ndarray): maximum XYZ Euler angles of the random pose, defined with respect to the\n  frame of the prim at coord_prim.\n\nReturns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame. Shape is (3, ). Second index is\n  quaternion orientation in the world frame. Quaternion is scalar-first\n  (w, x, y, z). Shape is (4, ).",
                "snippet": "value = random_utils.get_random_world_pose_in_view(camera_prim=camera_prim,  # pxr.Usd.Prim\n                                                   min_distance=min_distance,  # float\n                                                   max_distance=max_distance,  # float\n                                                   fov_x=fov_x,  # float\n                                                   fov_y=fov_y,  # float\n                                                   fraction_to_screen_edge=fraction_to_screen_edge,  # float\n                                                   coord_prim=coord_prim,  # pxr.Usd.Prim\n                                                   min_rotation_range=min_rotation_range,  # numpy.ndarray\n                                                   max_rotation_range=max_rotation_range)  # numpy.ndarray\n"
                }
                ]
                },
                {
                "title": "Render Product",
                "snippets": [
                {
                "title": "add_aov",
                "description": "Adds an AOV/Render Var to an existing render product\n\nArgs:\n  render_product_path (str): path to the render product prim\n  aov_name (str): Name of the render var we want to add to this render product\n\nRaises:\n  RuntimeError: If the render product path is invalid\n  RuntimeError: If the renderVar could not be created\n  RuntimeError: If the renderVar could not be added to the render product\n",
                "snippet": "render_product_utils.add_aov(render_product_path=render_product_path,  # str\n                             aov_name=aov_name)  # str\n"
                },
                {
                "title": "create_hydra_texture",
                "description": "Create a hydra texture and return the texture and the render product path\n\nArgs:\n  resolution (Tuple[int]): Resolution used to create the render product\n  camera_prim_path (str): Camera prim to attach to render product\n\nReturns:\n  hydra_texture, str: returns the hydratexture and render product prim path",
                "snippet": "render_product_utils.create_hydra_texture(resolution=resolution,  # typing.Tuple[int]\n                                          camera_prim_path=camera_prim_path)  # str\n"
                },
                {
                "title": "get_camera_prim_path",
                "description": "Get the current camera for a render product\n\nArgs:\n  render_product_path (str): path to the render product prim\n\nRaises:\n  RuntimeError: If the render product path is invalid\n\nReturns:\n  str : Path to the camera prim attached to this render product",
                "snippet": "render_product_utils.get_camera_prim_path(render_product_path=render_product_path)  # str\n"
                },
                {
                "title": "get_resolution",
                "description": "Get resolution for a render product\n\nArgs:\n  render_product_path (str): path to the render product prim\n\nRaises:\n  RuntimeError: If the render product path is invalid\n\nReturns:\n  Tuple[int]: (width,height)",
                "snippet": "render_product_utils.get_resolution(render_product_path=render_product_path)  # str\n"
                },
                {
                "title": "set_camera_prim_path",
                "description": "Sets the camera prim path for a render product\n\nArgs:\n  render_product_path (str):  path to the render product prim\n  camera_prim_path (str):  path to the camera prim\n\nRaises:\n  RuntimeError: If the render product path is invalid",
                "snippet": "render_product_utils.set_camera_prim_path(render_product_path=render_product_path,  # str\n                                          camera_prim_path=camera_prim_path)  # str\n"
                },
                {
                "title": "set_resolution",
                "description": "Set resolution for a render product\n\nArgs:\n  render_product_path (str): path to the render product prim\n  resolution (Tuple[float]): width,height for render product\n\nRaises:\n  RuntimeError: If the render product path is invalid",
                "snippet": "render_product_utils.set_resolution(render_product_path=render_product_path,  # str\n                                    resolution=resolution)  # typing.Tuple[int]\n"
                }
                ]
                },
                {
                "title": "Rotations",
                "snippets": [
                {
                "title": "euler_angles_to_quat",
                "description": "Convert Euler XYZ angles to quaternion.\n\nArgs:\n  euler_angles (np.ndarray):  Euler XYZ angles.\n  degrees (bool, optional): Whether input angles are in degrees. Defaults to False.\n\nReturns:\n  np.ndarray: quaternion (w, x, y, z).",
                "snippet": "value = rotations_utils.euler_angles_to_quat(euler_angles=euler_angles,  # numpy.ndarray\n                                             degrees=False)  # bool\n"
                },
                {
                "title": "euler_to_rot_matrix",
                "description": "Convert from Euler XYZ angles to rotation matrix.\n\nArgs:\n  euler_angles (np.ndarray): Euler XYZ angles.\n  degrees (bool, optional): Whether input angles are in degrees. Defaults to False.\n\nReturns:\n  Gf.Rotation: Pxr rotation object.",
                "snippet": "value = rotations_utils.euler_to_rot_matrix(euler_angles=euler_angles,  # numpy.ndarray\n                                            degrees=False)  # bool\n"
                },
                {
                "title": "gf_quat_to_np_array",
                "description": "Converts a pxr Quaternion type to a numpy array following [w, x, y, z] convention.\n\nArgs:\n  orientation (typing.Union[Gf.Quatd, Gf.Quatf, Gf.Quaternion]): Input quaternion object.\n\nReturns:\n  np.ndarray: A (4,) quaternion array in (w, x, y, z).",
                "snippet": "value = rotations_utils.gf_quat_to_np_array(orientation=orientation)  # typing.Union[pxr.Gf.Quatd, pxr.Gf.Quatf, pxr.Gf.Quaternion]\n"
                },
                {
                "title": "gf_rotation_to_np_array",
                "description": "Converts a pxr Rotation type to a numpy array following [w, x, y, z] convention.\n\nArgs:\n  orientation (Gf.Rotation): Pxr rotation object.\n\nReturns:\n  np.ndarray: A (4,) quaternion array in (w, x, y, z).",
                "snippet": "value = rotations_utils.gf_rotation_to_np_array(orientation=orientation)  # pxr.Gf.Rotation\n"
                },
                {
                "title": "lookat_to_quatf",
                "description": "[summary]\n\nArgs:\n  camera (Gf.Vec3f): [description]\n  target (Gf.Vec3f): [description]\n  up (Gf.Vec3f): [description]\n\nReturns:\n  Gf.Quatf: Pxr quaternion object.",
                "snippet": "value = rotations_utils.lookat_to_quatf(camera=camera,  # pxr.Gf.Vec3f\n                                        target=target,  # pxr.Gf.Vec3f\n                                        up=up)  # pxr.Gf.Vec3f\n"
                },
                {
                "title": "matrix_to_euler_angles",
                "description": "Convert rotation matrix to Euler XYZ angles.\n\nArgs:\n  mat (np.ndarray): A 3x3 rotation matrix.\n\nReturns:\n  np.ndarray: Euler XYZ angles (in radians).",
                "snippet": "value = rotations_utils.matrix_to_euler_angles(mat=mat)  # numpy.ndarray\n"
                },
                {
                "title": "quat_to_euler_angles",
                "description": "Convert input quaternion to Euler XYZ matrix.\n\nArgs:\n  quat (np.ndarray): Input quaternion (w, x, y, z).\n  degrees (bool, optional): Whether returned angles should be in degrees.\n\nReturns:\n  np.ndarray: Euler XYZ angles (in radians).",
                "snippet": "value = rotations_utils.quat_to_euler_angles(quat=quat,  # numpy.ndarray\n                                             degrees=False)  # bool\n"
                },
                {
                "title": "quat_to_rot_matrix",
                "description": "Convert input quaternion to rotation matrix.\n\nArgs:\n  quat (np.ndarray): Input quaternion (w, x, y, z).\n\nReturns:\n  np.ndarray: A 3x3 rotation matrix.",
                "snippet": "value = rotations_utils.quat_to_rot_matrix(quat=quat)  # numpy.ndarray\n"
                }
                ]
                },
                {
                "title": "Semantics",
                "snippets": [
                {
                "title": "add_update_semantics",
                "description": "Apply a semantic label to a prim or update an existing label\n\nArgs:\n  prim (Usd.Prim): Usd Prim to add or update semantics on\n  semantic_label (str): The label we want to apply\n  type_label (str): The type of semantic information we are specifying (default = \"class\")\n  suffix (str): Additional suffix used to specify multiple semantic attribute names.\n  By default the semantic attribute name is \"Semantics\", and to specify additional\n  attributes a suffix can be provided. Simple string concatenation is used :\"Semantics\" + suffix (default = \"\")",
                "snippet": "semantics_utils.add_update_semantics(prim=prim,  # pxr.Usd.Prim\n                                     semantic_label=semantic_label,  # str\n                                     type_label=\"class\",  # str\n                                     suffix=\"\")\n"
                },
                {
                "title": "get_semantics",
                "description": "Returns semantics that are applied to a prim\n\nArgs:\n  prim (Usd.Prim): Prim to return semantics for\n\nReturns:\n  Dict[str, Tuple[str,str]]: Dictionary containing the name of the applied semantic, and the type and data associated with that semantic. ",
                "snippet": "value = semantics_utils.get_semantics(prim=prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "remove_all_semantics",
                "description": "Removes all semantic tags from a given prim and its children\n\nArgs:\n  prim (Usd.Prim): Prim to remove any applied semantic APIs on\n  recursive (bool, optional): Also traverse children and remove semantics recursively. Defaults to False.",
                "snippet": "semantics_utils.remove_all_semantics(prim=prim,  # pxr.Usd.Prim\n                                     recursive=False)  # bool\n"
                }
                ]
                },
                {
                "title": "Stage",
                "snippets": [
                {
                "title": "add_reference_to_stage",
                "description": "Add USD reference to the opened stage at specified prim path.\n\nArgs:\n  usd_path (str): The path to USD file.\n  prim_path (str): The prim path to attach reference.\n  prim_type (str, optional): The type of prim. Defaults to \"Xform\".\n\nRaises:\n  FileNotFoundError: When input USD file is found at specified path.\n\nReturns:\n  Usd.Prim: The USD prim at specified prim path.",
                "snippet": "value = stage_utils.add_reference_to_stage(usd_path=usd_path,  # str\n                                           prim_path=prim_path,  # str\n                                           prim_type=\"Xform\")  # str\n"
                },
                {
                "title": "clear_stage",
                "description": "Deletes all prims in the stage without populating the undo command buffer\n\nArgs:\n  predicate (typing.Optional[typing.Callable[[str], bool]], optional): user defined function that  takes a prim_path (str) as input and returns True/False if the prim should/shouldn't be deleted. If predicate is None, a default is used that deletes all prims\n\nReturns:\n  [type]: [description]",
                "snippet": "stage_utils.clear_stage(predicate=None)  # typing.Union[typing.Callable[[str], bool], NoneType]\n"
                },
                {
                "title": "close_stage",
                "description": "Closes the current opened USD stage.\n\nArgs:\n  callback_fn (typing.Callable, optional): Callback function to call while closing. Defaults to None.\n\nReturns:\n  bool: True if operation is successful, otherwise false.",
                "snippet": "value = stage_utils.close_stage(callback_fn=None)  # typing.Callable\n"
                },
                {
                "title": "create_new_stage",
                "description": "Create a new stage.\n\nReturns:\n  Usd.Stage: The created USD stage.",
                "snippet": "value = stage_utils.create_new_stage()\n"
                },
                {
                "title": "create_new_stage_async",
                "description": "Create a new stage (asynchronous version).",
                "snippet": "stage_utils.create_new_stage_async()\n"
                },
                {
                "title": "get_current_stage",
                "description": "Get the current open USD stage.\n\nReturns:\n  Usd.Stage: The USD stage.",
                "snippet": "value = stage_utils.get_current_stage()\n"
                },
                {
                "title": "get_next_free_path",
                "description": "Returns the next free usd path for the current stage\n\nArgs:\n  path (str): path we want to check\n  parent (str, optional): Parent prim for the given path. Defaults to None.\n\nReturns:\n  str: a new path that is guaranteed to not exist on the current stage",
                "snippet": "value = stage_utils.get_next_free_path(path=path,  # str\n                                       parent=None)  # str\n"
                },
                {
                "title": "get_stage_units",
                "description": "Get the stage meters per unit currently set\n\nReturns:\n  float: current stage meters per unit",
                "snippet": "value = stage_utils.get_stage_units()\n"
                },
                {
                "title": "get_stage_up_axis",
                "description": "Get the current up-axis of USD stage.\n\nReturns:\n  str: The up-axis of the stage.",
                "snippet": "value = stage_utils.get_stage_up_axis()\n"
                },
                {
                "title": "is_stage_loading",
                "description": "Convenience function to see if any files are being loaded.\n\nReturns:\n  bool: True if loading, False otherwise",
                "snippet": "value = stage_utils.is_stage_loading()\n"
                },
                {
                "title": "open_stage",
                "description": "Open the given usd file and replace currently opened stage.\n\nArgs:\n  usd_path (str): Path to the USD file to open.\n\nRaises:\n  ValueError: When input path is not a supported file type by USD.\n\nReturns:\n  bool: True if operation is successful, otherwise false.",
                "snippet": "value = stage_utils.open_stage(usd_path=usd_path)  # str\n"
                },
                {
                "title": "open_stage_async",
                "description": "Open the given usd file and replace currently opened stage (asynchronous version).\n\nArgs:\n  usd_path (str): Path to the USD file to open.\n\nRaises:\n  ValueError: When input path is not a supported file type by USD.\n\nReturns:\n  bool: True if operation is successful, otherwise false.",
                "snippet": "value = stage_utils.open_stage_async(usd_path=usd_path)  # str\n"
                },
                {
                "title": "print_stage_prim_paths",
                "description": "Traverses the stage and prints all prim paths.",
                "snippet": "stage_utils.print_stage_prim_paths()\n"
                },
                {
                "title": "save_stage",
                "description": "Save usd file to path, it will be overwritten with the current stage\n\nArgs:\n  usd_path (str): File path to save the current stage to\n  save_and_reload_in_place (bool, optional): use save_as_stage to save and reload the root layer in place. Defaults to True.\n\nRaises:\n  ValueError: When input path is not a supported file type by USD.\n\nReturns:\n  bool: True if operation is successful, otherwise false.",
                "snippet": "value = stage_utils.save_stage(usd_path=usd_path,  # str\n                               save_and_reload_in_place=True)\n"
                },
                {
                "title": "set_livesync_stage",
                "description": "[summary]\n\nArgs:\n  usd_path (str): path to enable live sync for, t will be overwritten with the current stage\n  enable (bool): True to enable livesync, false to disable livesync\n\nReturns:\n  bool: True if operation is successful, otherwise false.",
                "snippet": "value = stage_utils.set_livesync_stage(usd_path=usd_path,  # str\n                                       enable=enable)  # bool\n"
                },
                {
                "title": "set_stage_units",
                "description": "Set the stage meters per unit\n\nArgs:\n  stage_units_in_meters (float): units for stage, 1.0 means meters, 0.01 mean centimeters",
                "snippet": "stage_utils.set_stage_units(stage_units_in_meters=stage_units_in_meters)  # float\n"
                },
                {
                "title": "set_stage_up_axis",
                "description": "Change the up axis of the current stage\n\nArgs:\n  axis (UsdGeom.Tokens, optional): valid values are \"x\" and \"y\"",
                "snippet": "stage_utils.set_stage_up_axis(axis=\"z\")  # str\n"
                },
                {
                "title": "traverse_stage",
                "description": "Traverse through prims in the opened USd stage.\n\nReturns:\n  typing.Iterable: Generator which yields prims from the stage in depth-first-traversal order.",
                "snippet": "value = stage_utils.traverse_stage()\n"
                },
                {
                "title": "update_stage",
                "description": "Update the current USD stage.",
                "snippet": "stage_utils.update_stage()\n"
                },
                {
                "title": "update_stage_async",
                "description": "Update the current USD stage (asynchronous version).",
                "snippet": "stage_utils.update_stage_async()\n"
                }
                ]
                },
                {
                "title": "String",
                "snippets": [
                {
                "title": "find_root_prim_path_from_regex",
                "description": "Find the first prim above the regex pattern prim and its position.\n\nArgs:\n  prim_path_regex (str): full prim path including the regex pattern prim.\n\nReturns:\n  Tuple[str, int]: First position is the prim path to the parent of the regex prim.\n  Second position represents the level of the regex prim in the USD stage tree representation.\n",
                "snippet": "value = string_utils.find_root_prim_path_from_regex(prim_path_regex=prim_path_regex)  # str\n"
                },
                {
                "title": "find_unique_string_name",
                "description": "Find a unique string name based on the predicate function provided.\n\nThe string is appended with \"_N\", where N is a natural number till the resultant string \nis unique.\n\nArgs:\n  initial_name (str): The initial string name.\n  is_unique_fn (Callable[[str], bool]): The predicate function to validate against.\n\nReturns:\n  str: A unique string based on input function.",
                "snippet": "value = string_utils.find_unique_string_name(initial_name=initial_name,  # str\n                                             is_unique_fn=is_unique_fn)  # typing.Callable[[str], bool]\n"
                }
                ]
                },
                {
                "title": "Transformations",
                "snippets": [
                {
                "title": "get_relative_transform",
                "description": "Get the relative transformation matrix from the source prim to the target prim.\n\nArgs:\n  source_prim (Usd.Prim): source prim from which frame to compute the relative transform.\n  target_prim (Usd.Prim): target prim to which frame to compute the relative transform.\n\nReturns:\n  np.ndarray: Column-major transformation matrix with shape (4, 4).",
                "snippet": "value = transformations_utils.get_relative_transform(source_prim=source_prim,  # pxr.Usd.Prim\n                                                     target_prim=target_prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "get_translation_from_target",
                "description": "Get a translation with respect to the target's frame, from a translation in the source's frame.\n\nArgs:\n  translation_from_source (np.ndarray): translation from the frame of the prim at source_path. Shape is (3, ).\n  source_prim (Usd.Prim): prim path of the prim whose frame the original/untransformed translation\n   (translation_from_source) is defined with respect to.\n  target_prim (Usd.Prim): prim path of the prim whose frame corresponds to the target frame that the returned\n   translation will be defined with respect to.\n\nReturns:\n  np.ndarray: translation with respect to the target's frame. Shape is (3, ).",
                "snippet": "value = transformations_utils.get_translation_from_target(translation_from_source=translation_from_source,  # numpy.ndarray\n                                                          source_prim=source_prim,  # pxr.Usd.Prim\n                                                          target_prim=target_prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "get_world_pose_from_relative",
                "description": "Get a pose defined in the world frame from a pose defined relative to the frame of the coord_prim.\n\nArgs:\n  coord_prim (Usd.Prim): path of the prim whose frame the relative pose is defined with respect to.\n  relative_translation (np.ndarray): translation relative to the frame of the prim at prim_path. Shape is (3, ).\n  relative_orientation (np.ndarray): quaternion orientation relative to the frame of the prim at prim_path.\n   Quaternion is scalar-first (w, x, y, z). Shape is (4, ).\n\nReturns:\n  Tuple[np.ndarray, np.ndarray]: first index is position in the world frame. Shape is (3, ). Second index is\n   quaternion orientation in the world frame. Quaternion is scalar-first\n   (w, x, y, z). Shape is (4, ).",
                "snippet": "value = transformations_utils.get_world_pose_from_relative(coord_prim=coord_prim,  # pxr.Usd.Prim\n                                                           relative_translation=relative_translation,  # numpy.ndarray\n                                                           relative_orientation=relative_orientation)  # numpy.ndarray\n"
                },
                {
                "title": "pose_from_tf_matrix",
                "description": "Gets pose corresponding to input transformation matrix.\n\nArgs:\n  transformation (np.ndarray): Column-major transformation matrix. shape is (4, 4).\n\nReturns:\n  Tuple[np.ndarray, np.ndarray]: first index is translation corresponding to transformation. shape is (3, ).\n   second index is quaternion orientation corresponding to transformation.\n   quaternion is scalar-first (w, x, y, z). shape is (4, ).",
                "snippet": "value = transformations_utils.pose_from_tf_matrix(transformation=transformation)  # numpy.ndarray\n"
                },
                {
                "title": "tf_matrices_from_poses",
                "description": "[summary]\n\nArgs:\n  translations (Union[np.ndarray, torch.Tensor]): translations with shape (N, 3).\n  orientations (Union[np.ndarray, torch.Tensor]): quaternion representation (scalar first) with shape (N, 4).\n\nReturns:\n  Union[np.ndarray, torch.Tensor]: transformation matrices with shape (N, 4, 4)",
                "snippet": "value = transformations_utils.tf_matrices_from_poses(translations=translations,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                                     orientations=orientations)  # typing.Union[numpy.ndarray, torch.Tensor]\n"
                },
                {
                "title": "tf_matrix_from_pose",
                "description": "Compute input pose to transformation matrix.\n\nArgs:\n  pos (Sequence[float]): The translation vector.\n  rot (Sequence[float]): The orientation quaternion.\n\nReturns:\n  np.ndarray: A 4x4 matrix.",
                "snippet": "value = transformations_utils.tf_matrix_from_pose(translation=translation,  # typing.Sequence[float]\n                                                  orientation=orientation)  # typing.Sequence[float]\n"
                }
                ]
                },
                {
                "title": "Torch",
                "snippets": [
                {
                "title": "as_type",
                "description": "",
                "snippet": "torch_utils.as_type(data=data,\n                    dtype=dtype)\n"
                },
                {
                "title": "clone_tensor",
                "description": "",
                "snippet": "torch_utils.clone_tensor(data=data,\n                         device=device)\n"
                },
                {
                "title": "convert",
                "description": "",
                "snippet": "torch_utils.convert(data=data,\n                    device=device)\n"
                },
                {
                "title": "cos",
                "description": "",
                "snippet": "torch_utils.cos(data=data)\n"
                },
                {
                "title": "create_tensor_from_list",
                "description": "",
                "snippet": "torch_utils.create_tensor_from_list(data=data,\n                                    dtype=dtype,\n                                    device=None)\n"
                },
                {
                "title": "create_zeros_tensor",
                "description": "",
                "snippet": "torch_utils.create_zeros_tensor(shape=shape,\n                                dtype=dtype,\n                                device=None)\n"
                },
                {
                "title": "deg2rad",
                "description": "_summary_\n\nArgs:\n  degree_value (torch.Tensor): _description_\n  device (_type_, optional): _description_. Defaults to None.\n\nReturns:\n  torch.Tensor: _description_",
                "snippet": "value = torch_utils.deg2rad(degree_value=degree_value,  # float\n                            device=None)\n"
                },
                {
                "title": "euler_angles_to_quats",
                "description": "Vectorized version of converting euler angles to quaternion (scalar first)\n\nArgs:\n  euler_angles (typing.Union[np.ndarray, torch.Tensor]): euler angles with shape (N, 3) representation XYZ\n  degrees (bool, optional): True if degrees, False if radians. Defaults to False.\n\nReturns:\n  typing.Union[np.ndarray, torch.Tensor]: quaternions representation of the angles (N, 4) - scalar first.",
                "snippet": "value = torch_utils.euler_angles_to_quats(euler_angles=euler_angles,  # torch.Tensor\n                                          degrees=False,  # bool\n                                          device=None)\n"
                },
                {
                "title": "expand_dims",
                "description": "",
                "snippet": "torch_utils.expand_dims(data=data,\n                        axis=axis)\n"
                },
                {
                "title": "get_local_from_world",
                "description": "",
                "snippet": "torch_utils.get_local_from_world(parent_transforms=parent_transforms,\n                                 positions=positions,\n                                 orientations=orientations,\n                                 device=device)\n"
                },
                {
                "title": "get_pose",
                "description": "",
                "snippet": "torch_utils.get_pose(positions=positions,\n                     orientations=orientations,\n                     device=device)\n"
                },
                {
                "title": "get_world_from_local",
                "description": "",
                "snippet": "torch_utils.get_world_from_local(parent_transforms=parent_transforms,\n                                 translations=translations,\n                                 orientations=orientations,\n                                 device=device)\n"
                },
                {
                "title": "gf_quat_to_tensor",
                "description": "Converts a pxr Quaternion type to a torch array (scalar first).\n\nArgs:\n  orientation (typing.Union[Gf.Quatd, Gf.Quatf, Gf.Quaternion]): [description]\n\nReturns:\n   torch.Tensor: [description]",
                "snippet": "value = torch_utils.gf_quat_to_tensor(orientation=orientation,  # typing.Union[pxr.Gf.Quatd, pxr.Gf.Quatf, pxr.Gf.Quaternion]\n                                      device=None)\n"
                },
                {
                "title": "inverse",
                "description": "",
                "snippet": "torch_utils.inverse(data=data)\n"
                },
                {
                "title": "matmul",
                "description": "",
                "snippet": "torch_utils.matmul(matrix_a=matrix_a,\n                   matrix_b=matrix_b)\n"
                },
                {
                "title": "move_data",
                "description": "",
                "snippet": "torch_utils.move_data(data=data,\n                      device=device)\n"
                },
                {
                "title": "move_to_gpu",
                "description": "",
                "snippet": "torch_utils.move_to_gpu(data=data)\n"
                },
                {
                "title": "normalise_quat_in_pose",
                "description": "Takes a pose and normalises the quaternion portion of it.\n\nArgs:\n  pose: shape N, 7\nReturns:\n  Pose with normalised quat. Shape N, 7",
                "snippet": "torch_utils.normalise_quat_in_pose(pose=pose)\n"
                },
                {
                "title": "pad",
                "description": "",
                "snippet": "torch_utils.pad(data=data,\n                pad_width=pad_width,\n                mode=\"constant\",\n                value=None)\n"
                },
                {
                "title": "rad2deg",
                "description": "_summary_\n\nArgs:\n  radian_value (torch.Tensor): _description_\n  device (_type_, optional): _description_. Defaults to None.\n\nReturns:\n  torch.Tensor: _description_",
                "snippet": "value = torch_utils.rad2deg(radian_value=radian_value,  # torch.Tensor\n                            device=None)\n"
                },
                {
                "title": "resolve_indices",
                "description": "",
                "snippet": "torch_utils.resolve_indices(indices=indices,\n                            count=count,\n                            device=device)\n"
                },
                {
                "title": "set_seed",
                "description": " set seed across modules ",
                "snippet": "torch_utils.set_seed(seed=seed,\n                     torch_deterministic=False)\n"
                },
                {
                "title": "sin",
                "description": "",
                "snippet": "torch_utils.sin(data=data)\n"
                },
                {
                "title": "tensor_cat",
                "description": "",
                "snippet": "torch_utils.tensor_cat(data=data,\n                       dim=-1)\n"
                },
                {
                "title": "tensor_stack",
                "description": "",
                "snippet": "torch_utils.tensor_stack(data=data,\n                         dim=0)\n"
                },
                {
                "title": "tf_matrices_from_poses",
                "description": "[summary]\n\nArgs:\n  translations (Union[np.ndarray, torch.Tensor]): translations with shape (N, 3).\n  orientations (Union[np.ndarray, torch.Tensor]): quaternion representation (scalar first) with shape (N, 4).\n\nReturns:\n  Union[np.ndarray, torch.Tensor]: transformation matrices with shape (N, 4, 4)",
                "snippet": "value = torch_utils.tf_matrices_from_poses(translations=translations,  # torch.Tensor\n                                           orientations=orientations,  # torch.Tensor\n                                           device=None)\n"
                },
                {
                "title": "transpose_2d",
                "description": "",
                "snippet": "torch_utils.transpose_2d(data=data)\n"
                },
                {
                "title": "unscale_np",
                "description": "",
                "snippet": "torch_utils.unscale_np(x=x,\n                       lower=lower,\n                       upper=upper)\n"
                }
                ]
                },
                {
                "title": "Types",
                "snippets": [
                {
                "title": "ArticulationAction",
                "snippets": [
                {
                "title": "ArticulationAction",
                "description": "[summary]\n\n Args:\n joint_positions (Optional[Union[List, np.ndarray]], optional): [description]. Defaults to None.\n joint_velocities (Optional[Union[List, np.ndarray]], optional): [description]. Defaults to None.\n joint_efforts (Optional[Union[List, np.ndarray]], optional): [description]. Defaults to None.\n ",
                "snippet": "articulation_action = ArticulationAction(joint_positions=None,  # typing.Union[typing.List, numpy.ndarray, NoneType]\n                                         joint_velocities=None,  # typing.Union[typing.List, numpy.ndarray, NoneType]\n                                         joint_efforts=None,  # typing.Union[typing.List, numpy.ndarray, NoneType]\n                                         joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "get_dict",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "dict = articulation_action.get_dict()\n"
                },
                {
                "title": "get_dof_action",
                "description": "[summary]\n\n  Args:\n  index (int): [description]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "dof_action = articulation_action.get_dof_action(index=index)  # int\n"
                },
                {
                "title": "get_length",
                "description": "[summary]\n\n  Returns:\n  Optional[int]: [description]\n  ",
                "snippet": "length = articulation_action.get_length()\n"
                }
                ]
                },
                {
                "title": "ArticulationActions",
                "description": "[summary]\n\n Args:\n joint_positions (Optional[Union[List, np.ndarray]], optional): [description]. Defaults to None.\n joint_velocities (Optional[Union[List, np.ndarray]], optional): [description]. Defaults to None.\n joint_efforts (Optional[Union[List, np.ndarray]], optional): [description]. Defaults to None.\n ",
                "snippet": "articulation_actions = ArticulationActions(joint_positions=None,  # typing.Union[typing.List, numpy.ndarray, NoneType]\n                                           joint_velocities=None,  # typing.Union[typing.List, numpy.ndarray, NoneType]\n                                           joint_efforts=None,  # typing.Union[typing.List, numpy.ndarray, NoneType]\n                                           joint_indices=None)  # typing.Union[typing.List, numpy.ndarray, NoneType]\n"
                },
                {
                "title": "DataFrame",
                "snippets": [
                {
                "title": "DataFrame",
                "description": "[summary]\n\n Args:\n current_time_step (int): [description]\n current_time (float): [description]\n data (dict): [description]\n ",
                "snippet": "data_frame = DataFrame(current_time_step=current_time_step,  # int\n                       current_time=current_time,  # float\n                       data=data)  # dict\n"
                },
                {
                "title": "get_dict",
                "description": "[summary]\n\n  Returns:\n  dict: [description]\n  ",
                "snippet": "dict = data_frame.get_dict()\n"
                }
                ]
                },
                {
                "title": "DOFInfo",
                "description": "[summary]\n\n Args:\n prim_path (str): [description]\n handle (int): [description]\n prim (Usd.Prim): [description]\n index (int): [description]\n ",
                "snippet": "dof_Info = DOFInfo(prim_path=prim_path,  # str\n                   handle=handle,  # int\n                   prim=prim,  # pxr.Usd.Prim\n                   index=index)  # int\n"
                },
                {
                "title": "DynamicState",
                "description": "[summary]\n\n Args:\n position (np.ndarray): [description]\n orientation (np.ndarray): [description]\n ",
                "snippet": "dynamic_state = DynamicState(position=position,  # numpy.ndarray\n                             orientation=orientation,  # numpy.ndarray\n                             linear_velocity=linear_velocity,  # numpy.ndarray\n                             angular_velocity=angular_velocity)  # numpy.ndarray\n"
                },
                {
                "title": "DynamicsViewState",
                "description": "[summary]\n\n Args:\n position (np.ndarray): [description]\n orientation (np.ndarray): [description]\n ",
                "snippet": "dynamics_view_state = DynamicsViewState(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                        orientations=orientations,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                        linear_velocities=linear_velocities,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                        angular_velocities=angular_velocities)  # typing.Union[numpy.ndarray, torch.Tensor]\n"
                },
                {
                "title": "JointsState",
                "description": "[summary]\n\n Args:\n positions (np.ndarray): [description]\n velocities (np.ndarray): [description]\n efforts (np.ndarray): [description]\n ",
                "snippet": "joints_state = JointsState(positions=positions,  # numpy.ndarray\n                           velocities=velocities,  # numpy.ndarray\n                           efforts=efforts)  # numpy.ndarray\n"
                },
                {
                "title": "XFormPrimState",
                "description": "[summary]\n\n Args:\n position (np.ndarray): [description]\n orientation (np.ndarray): [description]\n ",
                "snippet": "xform_prim_state = XFormPrimState(position=position,  # numpy.ndarray\n                                  orientation=orientation)  # numpy.ndarray\n"
                },
                {
                "title": "XFormPrimViewState",
                "description": "[summary]\n\n Args:\n positions (Union[np.ndarray, torch.Tensor]): positions with shape of (N, 3).\n orientations (Union[np.ndarray, torch.Tensor]): quaternion representation of orientation (scalar first) with shape (N, 4).\n ",
                "snippet": "xform_prim_view_state = XFormPrimViewState(positions=positions,  # typing.Union[numpy.ndarray, torch.Tensor]\n                                           orientations=orientations)  # typing.Union[numpy.ndarray, torch.Tensor]\n"
                }
                ]
                },
                {
                "title": "Viewports",
                "snippets": [
                {
                "title": "add_aov_to_viewport",
                "description": "",
                "snippet": "viewports_utils.add_aov_to_viewport(viewport_api=viewport_api,\n                                    aov_name=aov_name)  # str\n"
                },
                {
                "title": "backproject_depth",
                "description": "Backproject depth image to image space\n\nArgs:\n  depth_image (np.array): Depth image buffer\n  viewport_api (Any): Handle to viewport api\n  max_clip_depth (float): Depth values larger than this will be clipped\n\nReturns:\n  np.array: [description]",
                "snippet": "value = viewports_utils.backproject_depth(depth_image=depth_image,  # numpy.array\n                                          viewport_api=viewport_api,  # typing.Any\n                                          max_clip_depth=max_clip_depth)  # float\n"
                },
                {
                "title": "get_id_from_index",
                "description": "Get the viewport id for a given index. \nThis function was added for backwards compatibility for VP2 as viewport IDs are not the same as the viewport index\n\nArgs:\n  index (_type_): viewport index to retrieve ID for\n\nReturns:\n  viewport id : Returns None if window index was not found",
                "snippet": "viewports_utils.get_id_from_index(index=index)\n"
                },
                {
                "title": "get_intrinsics_matrix",
                "description": "Get intrinsic matrix for the camera attached to a specific viewport\n\nArgs:\n  viewport (Any): Handle to viewport api\n\nReturns:\n  np.ndarray: the intrinsic matrix associated with the specified viewport\n  The following image convention is assumed:\n  +x should point to the right in the image\n  +y should point down in the image",
                "snippet": "value = viewports_utils.get_intrinsics_matrix(viewport_api=viewport_api)  # typing.Any\n"
                },
                {
                "title": "get_viewport_names",
                "description": "Get list of all viewport names\n\nArgs:\n  usd_context_name (str, optional):  usd context to use. Defaults to None.\n\nReturns:\n  List[str]: List of viewport names",
                "snippet": "value = viewports_utils.get_viewport_names(usd_context_name=None)  # str\n"
                },
                {
                "title": "get_window_from_id",
                "description": "Find window that matches a given viewport id\n\nArgs:\n  id (_type_): Viewport ID to get window for\n  usd_context_name (str, optional): usd context to use. Defaults to None.\n\nReturns:\n  Window : Returns None if window with matching ID was not found",
                "snippet": "viewports_utils.get_window_from_id(id=id,\n                                   usd_context_name=None)  # str\n"
                },
                {
                "title": "project_depth_to_worldspace",
                "description": "Project depth image to world space\n\nArgs:\n  depth_image (np.array): Depth image buffer\n  viewport_api (Any): Handle to viewport api\n  max_clip_depth (float): Depth values larger than this will be clipped\n\nReturns:\n  List[carb.Float3]: List of points from depth in world space",
                "snippet": "value = viewports_utils.project_depth_to_worldspace(depth_image=depth_image,  # numpy.array\n                                                    viewport_api=viewport_api,  # typing.Any\n                                                    max_clip_depth=max_clip_depth)  # float\n"
                },
                {
                "title": "set_camera_view",
                "description": "Set the location and target for a camera prim in the stage given its path\n\nArgs:\n  eye (np.ndarray): Location of camera.\n  target (np.ndarray,): Location of camera target.\n  camera_prim_path (str, optional): Path to camera prim being set. Defaults to \"/OmniverseKit_Persp\".",
                "snippet": "viewports_utils.set_camera_view(eye=eye,  # numpy.array\n                                target=target,  # numpy.array\n                                camera_prim_path=\"/OmniverseKit_Persp\",  # str\n                                viewport_api=None)\n"
                },
                {
                "title": "set_intrinsics_matrix",
                "description": "Set intrinsic matrix for the camera attached to a specific viewport\n\nNote:\n  We assume cx and cy are centered in the camera\n  horizontal_aperture_offset and vertical_aperture_offset are computed and set on the camera prim but are not used\n\nArgs:\n  viewport (Any): Handle to viewport api\n  intrinsics_matrix (np.ndarray): A 3x3 intrinsic matrix\n  focal_length (float, optional): Default focal length to use when computing aperture values. Defaults to 1.0.\n\nRaises:\n  ValueError: If intrinsic matrix is not a 3x3 matrix.\n  ValueError: If camera prim is not valid",
                "snippet": "viewports_utils.set_intrinsics_matrix(viewport_api=viewport_api,  # typing.Any\n                                      intrinsics_matrix=intrinsics_matrix,  # numpy.ndarray\n                                      focal_length=1.0)  # float\n"
                }
                ]
                },
                {
                "title": "XForms",
                "snippets": [
                {
                "title": "clear_xform_ops",
                "description": " Remove all xform ops from input prim.\n\nArgs:\n  prim (Usd.Prim): The input USD prim.",
                "snippet": "xforms_utils.clear_xform_ops(prim=prim)  # pxr.Usd.Prim\n"
                },
                {
                "title": "reset_and_set_xform_ops",
                "description": "Reset xform ops to isaac sim defaults, and set their values\n\nArgs:\n  prim (Usd.Prim): Prim to reset\n  translation (Gf.Vec3d): translation to set\n  orientation (Gf.Quatd): orientation to set\n  scale (Gf.Vec3d, optional): scale to set. Defaults to Gf.Vec3d([1.0, 1.0, 1.0]).",
                "snippet": "xforms_utils.reset_and_set_xform_ops(prim=prim,  # pxr.Usd.Prim\n                                     translation=translation,  # pxr.Gf.Vec3d\n                                     orientation=orientation,  # pxr.Gf.Quatd\n                                     scale=(1, 1, 1))  # pxr.Gf.Vec3d\n"
                },
                {
                "title": "reset_xform_ops",
                "description": "Reset xform ops for a prim to isaac sim defaults, \n\nArgs:\n  prim (Usd.Prim): Prim to reset xform ops on",
                "snippet": "xforms_utils.reset_xform_ops(prim=prim)  # pxr.Usd.Prim\n"
                }
                ]
                }
            ]
        }
    ]
}